<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>MyBatis笔记</title>
    <link href="/2022/02/09/MyBatis/"/>
    <url>/2022/02/09/MyBatis/</url>
    
    <content type="html"><![CDATA[<h1 id="第一章-概念"><a href="#第一章-概念" class="headerlink" title="第一章  概念"></a>第一章  概念</h1><p><a href="https://mybatis.org/mybatis-3/zh/configuration.html">mybatis官方文档</a></p><h2 id="1-三层架构"><a href="#1-三层架构" class="headerlink" title="1.三层架构"></a>1.三层架构</h2><p>界面层：和用户打交道的，接收用户的请求参数，显示处理结果。（jsp，html负责显示参数，servlet负责接收请求参数）</p><p>业务逻辑层：接收界面层传递的数据，计算逻辑，调用数据库获取数据</p><p>数据访问层（持久层）：访问数据库，执行对数据的查询、修改、删除等。</p><h3 id="三层对应的包"><a href="#三层对应的包" class="headerlink" title="三层对应的包"></a>三层对应的包</h3><p>​    界面层：controller 包（servlet）</p><p>​    业务逻辑层：service包（XXXService类）</p><p>​    数据访问层：dao包（XXXDao类）</p><h3 id="三层中类的交互"><a href="#三层中类的交互" class="headerlink" title="三层中类的交互"></a>三层中类的交互</h3><p>​    用户使用界面层–&gt;业务逻辑层–&gt;数据访问层–&gt;数据库</p><h3 id="三层对应的处理框架"><a href="#三层对应的处理框架" class="headerlink" title="三层对应的处理框架"></a>三层对应的处理框架</h3><p>​    界面层—–servlet—–$\textcolor{Red}{springmvc} $</p><p>​    业务逻辑层—–service类—–$\textcolor{Red}{spring} $</p><p>​    数据访问层—–dao类—–$\textcolor{Red}{mybatis} $</p><p>&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;     &#x3D;&#x3D;&#x3D;&#x3D;</p><p>所以mybatis是用来访问数据库的一个基本框架</p><h2 id="2-MyBatis框架"><a href="#2-MyBatis框架" class="headerlink" title="2.MyBatis框架"></a>2.MyBatis框架</h2><p>1.SQL Mapper：SQL映射</p><p>​    可以把数据库表中的一行数据映射为一个java对象</p><p>​    一行数据可以看做是一个java对象，操作这个对象即操作表中的数据</p><p>2.Data Access Object(DAOs)：数据访问，对数据库进行增删改查</p><h3 id="提供的功能"><a href="#提供的功能" class="headerlink" title="提供的功能"></a>提供的功能</h3><p>1.提供了创建Connection  , Statement , ResultSet的能力</p><p>2.提供了执行sql语句的能力，不需要开发人员执行sql语句</p><p>3.提供了循环sql，把sql的结果转换成java对象，List集合的能力</p><p>在JDBC中有这样的代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><pre><code class="hljs JDBC">while(rs.next())&#123;<br>Student stu = new Student();<br>stu.setId(rs.getInt(&quot;id&quot;)):<br>stu.setName(rs.getInt(&quot;name&quot;)):<br>stu.setAge(rs.getInt(&quot;age&quot;)):<br>//从数据库取出数据转化成Student对象，封装到List集合<br>stuList.add(stu);<br>&#125;<br></code></pre></td></tr></table></figure><p>4.提供了关闭资源的能力，不需要手动关闭Connection, Statement, ResultSet</p><img src="/2022/02/09/MyBatis/mybatis-1627872197463.png" style="zoom:80%;"><p>主配置文件一定在资源文件夹下（main目录下）：</p><img src="/2022/02/09/MyBatis/image-20210802105622067.png" alt="image-20210802105622067" style="zoom: 80%;"><p>主配置文件主要做两件事情：</p><p>连接数据库和指定mapper文件的位置</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java">&lt;environments <span class="hljs-keyword">default</span>=<span class="hljs-string">&quot;mydev&quot;</span>&gt;<br>    &lt;environment id=<span class="hljs-string">&quot;mydev&quot;</span>&gt;<br>        &lt;transactionManager type=<span class="hljs-string">&quot;JDBC&quot;</span>/&gt;<br>        &lt;!-- 表示数据源，连接数据库的，type表示数据源的类型，<span class="hljs-string">&quot;POOLED&quot;</span>表示连接池--&gt;<br>        &lt;dataSource type=<span class="hljs-string">&quot;POOLED&quot;</span>&gt;<br>            &lt;!--数据库的驱动类名 --&gt;<br>            &lt;property name=<span class="hljs-string">&quot;driver&quot;</span> value=<span class="hljs-string">&quot;$&#123;jdbc.driver&#125;&quot;</span>/&gt;<br>            &lt;!--                连接数据库的url字符串,这个地方localhost:<span class="hljs-number">1234</span>一定是：，指的是端口--&gt;<br>            &lt;property name=<span class="hljs-string">&quot;url&quot;</span> value=<span class="hljs-string">&quot;$&#123;jdbc.url&#125;&quot;</span>/&gt;<br>            &lt;!--                访问数据库的用户名称--&gt;<br>            &lt;property name=<span class="hljs-string">&quot;username&quot;</span> value=<span class="hljs-string">&quot;$&#123;jdbc.username&#125;&quot;</span>/&gt;<br>            &lt;!--                数据库密码--&gt;<br>            &lt;property name=<span class="hljs-string">&quot;password&quot;</span> value=<span class="hljs-string">&quot;$&#123;jdbc.password&#125;&quot;</span>/&gt;<br>        &lt;/dataSource&gt;<br>    &lt;/environment&gt;<br>&lt;/environments&gt;<br>                <br>&lt;mappers&gt;<br>&lt;!--        &lt;mapper resource=<span class="hljs-string">&quot;twinkle/dao/StudentDao.xml&quot;</span>/&gt;--&gt;<br>&lt;<span class="hljs-keyword">package</span> name=<span class="hljs-string">&quot;twinkle.dao&quot;</span>/&gt;<br>&lt;/mappers&gt;<br></code></pre></td></tr></table></figure><h1 id="第二章-方法"><a href="#第二章-方法" class="headerlink" title="第二章 方法"></a>第二章 方法</h1><h2 id="一、传统Dao方法（概念及理解，不用）"><a href="#一、传统Dao方法（概念及理解，不用）" class="headerlink" title="一、传统Dao方法（概念及理解，不用）"></a>一、传统Dao方法（概念及理解，不用）</h2><p>1.创建Maven模板的Module</p><p>2.修改pom.xml文件中的配置，加入依赖库</p><p>3.创建表中每一行数据对应的对象类（domain）</p><p>4.创建Dao</p><p>​    Dao接口：写方法（对应mapper文件中的sql执行语句）</p><p>​    mapper文件：指定好namespace、id（和Dao接口中方法名称对应），写sql语言</p><p>5.主配置文件——java同级目录下创建根资源文件夹，并在此文件夹中创建主配置文件</p><p>6.写utils工具包——得到SqlSessionFactory和SqlSession对象</p><p>7.实现Dao接口——通过utils工具包得到SqlSession对象，并执行sql语句，进行增删改查</p><h2 id="二、动态代理"><a href="#二、动态代理" class="headerlink" title="二、动态代理"></a>二、动态代理</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyBatisUtils</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">SqlSessionFactory</span> <span class="hljs-variable">factory</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>    <span class="hljs-comment">//得到唯一的SqlSessionFactory对象</span><br>    <span class="hljs-keyword">static</span> &#123;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">config</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;Mybatis.xml&quot;</span>;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-type">InputStream</span> <span class="hljs-variable">in</span> <span class="hljs-operator">=</span> Resources.getResourceAsStream(config);<br>            factory = <span class="hljs-keyword">new</span> <span class="hljs-title class_">SqlSessionFactoryBuilder</span>().build(in);<br>        &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 在此基础上创建SqlSession</span><br><span class="hljs-comment">     * 静态方法，直接类名.方法名，</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> SqlSession</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> SqlSession <span class="hljs-title function_">getSqlSession</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-comment">//5.获取SqlSession对象，从SqlSessionFactory中获取</span><br>        <span class="hljs-type">SqlSession</span> <span class="hljs-variable">sqlSession</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>        <span class="hljs-keyword">if</span>(factory != <span class="hljs-literal">null</span>)&#123;<br>            sqlSession = factory.openSession();<br>        &#125;<br>        <span class="hljs-keyword">return</span> sqlSession;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="1-sqlSession-getMapper-接口-class-，调用接口方法，不需要实现接口"><a href="#1-sqlSession-getMapper-接口-class-，调用接口方法，不需要实现接口" class="headerlink" title="1.sqlSession.getMapper(接口.class)，调用接口方法，不需要实现接口"></a>1.sqlSession.getMapper(接口.class)，调用接口方法，不需要实现接口</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//得到了SqlSession对象</span><br><span class="hljs-type">SqlSession</span> <span class="hljs-variable">sqlSession</span> <span class="hljs-operator">=</span> MyBatisUtils.getsqlsession();<br><span class="hljs-type">StudentDao</span> <span class="hljs-variable">mapper</span> <span class="hljs-operator">=</span> sqlSession.getMapper(StudentDao.class);<br>mapper.XXX(方法名)<br></code></pre></td></tr></table></figure><h3 id="2-传参"><a href="#2-传参" class="headerlink" title="2.传参"></a>2.传参</h3><h4 id="1-mapper中获取简单类型的一个参数的值：-任意字符"><a href="#1-mapper中获取简单类型的一个参数的值：-任意字符" class="headerlink" title="(1) mapper中获取简单类型的一个参数的值：#{任意字符}"></a>(1) mapper中获取简单类型的一个参数的值：#{任意字符}</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//接口</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">StudentDao</span> &#123;<br>    <span class="hljs-keyword">public</span> Student <span class="hljs-title function_">selectOneStudent</span><span class="hljs-params">(Integer id)</span>;<br>&#125;<br><span class="hljs-comment">//mapper文件，这里where id=#&#123;任意字符&#125;</span><br>&lt;select id=<span class="hljs-string">&quot;selectOneStudent&quot;</span> resultType=<span class="hljs-string">&quot;twinkle.domain.Student&quot;</span>&gt;<br>    select id,name,email,age from student where id=#&#123;studentID&#125;<br>&lt;/select&gt;<br></code></pre></td></tr></table></figure><h4 id="2-多个参数，使用Param传参：-Param-“字符和mapper文件中的对应”"><a href="#2-多个参数，使用Param传参：-Param-“字符和mapper文件中的对应”" class="headerlink" title="(2)多个参数，使用Param传参： @Param(“字符和mapper文件中的对应”)"></a>(2)多个参数，使用Param传参： @Param(“字符和mapper文件中的对应”)</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//接口</span><br><span class="hljs-keyword">public</span> List&lt;Student&gt; <span class="hljs-title function_">selectStudentByMulti</span><span class="hljs-params">(<span class="hljs-meta">@Param(&quot;id&quot;)</span> Integer id, </span><br><span class="hljs-params">                                          <span class="hljs-meta">@Param(&quot;name&quot;)</span> String name)</span>;<br><span class="hljs-comment">//mapper文件</span><br>&lt;select id=<span class="hljs-string">&quot;selectStudentByMulti&quot;</span> resultType=<span class="hljs-string">&quot;twinkle.domain.Student&quot;</span>&gt;<br>    select * from student where id=#&#123;id&#125; or name=#&#123;name&#125;<br>&lt;/select&gt;<br><br><span class="hljs-comment">//main()</span><br>    List&lt;Student&gt; selectstulist = mapper.selectStudentByMulti(<span class="hljs-number">1002</span>,<span class="hljs-string">&quot;Jack&quot;</span>);<br></code></pre></td></tr></table></figure><h4 id="3-多个参数，使用对象传参，这个对象可以是自定义的"><a href="#3-多个参数，使用对象传参，这个对象可以是自定义的" class="headerlink" title="(3)多个参数，使用对象传参，这个对象可以是自定义的"></a>(3)多个参数，使用对象传参，这个对象可以是自定义的</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//接口</span><br><span class="hljs-keyword">public</span> List&lt;Student&gt; <span class="hljs-title function_">selectStudentByObj</span><span class="hljs-params">(Student student)</span>;<br><br><span class="hljs-comment">//mapper文件，其中where id=#&#123;id&#125;中占位符里的id必须和对象的属性名称保持一致</span><br>&lt;select id=<span class="hljs-string">&quot;selectStudentByObj&quot;</span> resultType=<span class="hljs-string">&quot;twinkle.domain.Student&quot;</span>&gt;<br>    select * from student where id=#&#123;id&#125; or age=#&#123;age&#125;<br>&lt;/select&gt;<br>    <br><span class="hljs-comment">//main()</span><br>List&lt;Student&gt; selectstulist = mapper.selectStudentByObj(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Student</span>(<span class="hljs-number">1002</span>,<span class="hljs-number">30</span>));<br></code></pre></td></tr></table></figure><h2 id="三、-或者"><a href="#三、-或者" class="headerlink" title="三、$  或者#"></a>三、$  或者#</h2><p>#：使用？在sql语句中进行$\textcolor{Red}{占位，} $使用PerparedStatement执行sql，效率高；避免sql注入，更安全</p><p>$：在sql语句中进行字符串拼接，使用Statement对象执行sql效率低。test程序可以通过拼接字符串多加其他的sql语句，有sql注入的风险</p><h2 id="四、MyBatis输出结果"><a href="#四、MyBatis输出结果" class="headerlink" title="四、MyBatis输出结果"></a>四、MyBatis输出结果</h2><h3 id="1-ResultType结果类型"><a href="#1-ResultType结果类型" class="headerlink" title="1.ResultType结果类型"></a>1.ResultType结果类型</h3><h4 id="1-全限定名称（包名-类名）or别名"><a href="#1-全限定名称（包名-类名）or别名" class="headerlink" title="(1)全限定名称（包名+类名）or别名"></a>(1)全限定名称（包名+类名）or别名</h4><p>可以返回一个简单类型(int等)，或对象</p><p>其中别名有：</p><img src="/2022/02/09/MyBatis/image-20210803153140277.png" alt="image-20210803153140277 " style="zoom:67%;"><img src="/2022/02/09/MyBatis/image-20210803153150511.png" alt=" " style="zoom:67%;"><h5 id="自定义别名："><a href="#自定义别名：" class="headerlink" title="自定义别名："></a>自定义别名：</h5><p>a.新的Aliase</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">&lt;typeAliases&gt;<br>    &lt;typeAlias type=<span class="hljs-string">&quot;twinkle.domain.Student&quot;</span> alias=<span class="hljs-string">&quot;student&quot;</span>&gt;&lt;/typeAlias&gt;<br>&lt;/typeAliases&gt;<br></code></pre></td></tr></table></figure><p>b.用类名作Aliase，domain包里的类都有别名</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">&lt;typeAliases&gt;<br>    &lt;<span class="hljs-keyword">package</span> name=<span class="hljs-string">&quot;twinkle.domain&quot;</span>/&gt;<br>&lt;/typeAliases&gt;<br></code></pre></td></tr></table></figure><h4 id="2-返回值为Map"><a href="#2-返回值为Map" class="headerlink" title="(2)返回值为Map"></a>(2)返回值为Map</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//接口</span><br><span class="hljs-comment">//可以返回为一个map的List</span><br><span class="hljs-keyword">public</span> List&lt;Map&lt;Object,Object&gt;&gt; <span class="hljs-title function_">selectStudentMap</span><span class="hljs-params">(<span class="hljs-meta">@Param(&quot;id&quot;)</span> Integer id)</span>;<br><span class="hljs-comment">//mapper</span><br>&lt;select id=<span class="hljs-string">&quot;selectStudentMap&quot;</span> resultType=<span class="hljs-string">&quot;map&quot;</span>&gt;<br>    select * from student where id&gt;#&#123;id&#125;<br>&lt;/select&gt;<br><span class="hljs-comment">//main</span><br>List&lt;Map&lt;Object,Object&gt;&gt; map = mapper.selectStudentMap(<span class="hljs-number">1001</span>);<br>System.out.println(<span class="hljs-string">&quot;map&quot;</span> + map);<br></code></pre></td></tr></table></figure><h3 id="2-ResultMap（结果映射，即可以自定义表中列值和对象属性的对应关系）"><a href="#2-ResultMap（结果映射，即可以自定义表中列值和对象属性的对应关系）" class="headerlink" title="2.ResultMap（结果映射，即可以自定义表中列值和对象属性的对应关系）"></a>2.ResultMap（结果映射，即可以自定义表中列值和对象属性的对应关系）</h3><p>如果Student类重写了包含所有列名的有参构造方法，那么就可以查出来完整的信息！！！</p><p>（实际项目开发的时候可以试一下，重写全部参数的构造方法，看能否解决名称不对应的问题，如果不行，则用ResultMap）</p><p>(1)接口写方法名</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> List&lt;Student&gt; <span class="hljs-title function_">selectResultMap</span><span class="hljs-params">(<span class="hljs-meta">@Param(&quot;id&quot;)</span> Integer id)</span>;<br></code></pre></td></tr></table></figure><p>(2)mapper文件中定义ResultMap</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java">&lt;!--    定义ResultMap--&gt;<br>&lt;resultMap id=<span class="hljs-string">&quot;StudentMap&quot;</span> type=<span class="hljs-string">&quot;twinkle.domain.Student&quot;</span>&gt;<br>    &lt;!--主键列用id--&gt;<br>    &lt;id column=<span class="hljs-string">&quot;id&quot;</span> property=<span class="hljs-string">&quot;age&quot;</span>/&gt;<br>    &lt;!--非主键列用result--&gt;<br>    &lt;result column=<span class="hljs-string">&quot;name&quot;</span> property=<span class="hljs-string">&quot;name&quot;</span>/&gt;<br>    &lt;result column=<span class="hljs-string">&quot;email&quot;</span> property=<span class="hljs-string">&quot;email&quot;</span>/&gt;<br>    &lt;result column=<span class="hljs-string">&quot;age&quot;</span> property=<span class="hljs-string">&quot;id&quot;</span>/&gt;<br>&lt;/resultMap&gt;<br></code></pre></td></tr></table></figure><p>(3)mapper文件中写select字段</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">&lt;select id=<span class="hljs-string">&quot;selectResultMap&quot;</span> resultMap=<span class="hljs-string">&quot;StudentMap&quot;</span>&gt;<br>select * from student where id=#&#123;id&#125;<br>&lt;/select&gt;<br></code></pre></td></tr></table></figure><p>3.实体类属性名和表中列名不同处理方法</p><p>(1)使用resuleMap</p><p>(2)使用列别名和resultType</p><p>select id as xxx, name as xxx from student</p><h1 id="第三章-动态sql"><a href="#第三章-动态sql" class="headerlink" title="第三章 动态sql"></a>第三章 动态sql</h1><p>1.if</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java">&lt;select id=<span class="hljs-string">&quot;selectStudentIf&quot;</span> resultType=<span class="hljs-string">&quot;twinkle.domain.Student&quot;</span>&gt;<br>    select id,name,email,age from student<br>    where <span class="hljs-number">1</span>=<span class="hljs-number">1</span><br>    &lt;<span class="hljs-keyword">if</span> test=<span class="hljs-string">&quot;name != null and name !=&#x27;&#x27; &quot;</span>&gt;<br>        <span class="hljs-type">and</span> <span class="hljs-variable">name</span> <span class="hljs-operator">=</span> #&#123;name&#125;<br>    &lt;/<span class="hljs-keyword">if</span>&gt;<br>    &lt;<span class="hljs-keyword">if</span> test=<span class="hljs-string">&quot;age &gt; 0&quot;</span>&gt;<br>        and age &gt; #&#123;age&#125;<br>    &lt;/<span class="hljs-keyword">if</span>&gt;<br>&lt;/select&gt;<br></code></pre></td></tr></table></figure><p>2.where + if</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java">&lt;select id=<span class="hljs-string">&quot;selectStudentIf&quot;</span> resultType=<span class="hljs-string">&quot;twinkle.domain.Student&quot;</span>&gt;<br>    select * from student<br>    &lt;where&gt;<br>        &lt;<span class="hljs-keyword">if</span> test=<span class="hljs-string">&quot;name != null and name != &#x27;&#x27;&quot;</span>&gt;<br>            name = #&#123;name&#125;<br>        &lt;/<span class="hljs-keyword">if</span>&gt;<br>        &lt;<span class="hljs-keyword">if</span> test=<span class="hljs-string">&quot;age &gt; 0&quot;</span>&gt;<br>            age &gt; #&#123;age&#125;<br>        &lt;/<span class="hljs-keyword">if</span>&gt;<br>    &lt;/where&gt;<br>&lt;/select&gt;<br></code></pre></td></tr></table></figure><p>3.foreach</p><p>最终输出为select * from student where id in (?,?,?)，其中</p><p>collection：</p><p>item:循环的对象，主代码中需要传入的，可以是简单类型，也可以是对象，如果需要使用对象的属性值，</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java">&lt;select id=<span class="hljs-string">&quot;selectStudentForeachP&quot;</span> resultType=<span class="hljs-string">&quot;twinkle.domain.Student&quot;</span>&gt;<br>    select * from student where id in<br>    &lt;foreach collection=<span class="hljs-string">&quot;list&quot;</span> item=<span class="hljs-string">&quot;mystu&quot;</span> open=<span class="hljs-string">&quot;(&quot;</span> close=<span class="hljs-string">&quot;)&quot;</span> separator=<span class="hljs-string">&quot;,&quot;</span>&gt;<br>        #&#123;mystu.id&#125;<br>    &lt;/foreach&gt;<br>&lt;/select&gt;<br></code></pre></td></tr></table></figure><p>open：开始符号</p><p>close：结束符号</p><p>separator：分隔符</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java">select * from student where id in<br>&lt;foreach collection=<span class="hljs-string">&quot;list&quot;</span> item=<span class="hljs-string">&quot;myid&quot;</span> open=<span class="hljs-string">&quot;(&quot;</span> close=<span class="hljs-string">&quot;)&quot;</span> separator=<span class="hljs-string">&quot;,&quot;</span>&gt;<br>    #&#123;myid&#125;<br>&lt;/foreach&gt;<br><span class="hljs-comment">//main</span><br>List&lt;Integer&gt; list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>list.add(<span class="hljs-number">1001</span>);<br>list.add(<span class="hljs-number">1002</span>);<br>list.add(<span class="hljs-number">1003</span>);<br>List&lt;Student&gt; studentList = mapper.selectStudentForeach(list);<br></code></pre></td></tr></table></figure><p>4.sql代码片段</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java">&lt;sql id=<span class="hljs-string">&quot;studentsql&quot;</span>&gt;<br>    select * from student<br>&lt;/sql&gt;<br><br>&lt;select id=<span class="hljs-string">&quot;selectStudentIf&quot;</span> resultType=<span class="hljs-string">&quot;twinkle.domain.Student&quot;</span>&gt;<br>&lt;include refid=<span class="hljs-string">&quot;studentsql&quot;</span>/&gt;<br>&lt;/select&gt;<br></code></pre></td></tr></table></figure><h1 id="第四章-补充知识"><a href="#第四章-补充知识" class="headerlink" title="第四章  补充知识"></a>第四章  补充知识</h1><h2 id="1-数据库连接封装"><a href="#1-数据库连接封装" class="headerlink" title="1.数据库连接封装"></a>1.数据库连接封装</h2><p>resource目录下新增.properties文件，在文件中写数据库的连接信息</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-attr">jdbc.driver</span> = com.mysql.jdbc.Driver<br><span class="hljs-attr">jdbc.url</span> = jdbc:mysql://localhost:<span class="hljs-number">1234</span>/mybatis<br><span class="hljs-attr">jdbc.username</span> = root<br><span class="hljs-attr">jdbc.password</span> = <span class="hljs-number">333</span><br></code></pre></td></tr></table></figure><p>主配置文件中写.properties文件的位置</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">&lt;properties resource=<span class="hljs-string">&quot;jdbc.properties&quot;</span>/&gt;<br></code></pre></td></tr></table></figure><p>environment中的value值为${key}</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">&lt;property name=<span class="hljs-string">&quot;driver&quot;</span> value=<span class="hljs-string">&quot;$&#123;jdbc.driver&#125;&quot;</span>/&gt;<br></code></pre></td></tr></table></figure><h2 id="2-多个mapper文件"><a href="#2-多个mapper文件" class="headerlink" title="2.多个mapper文件"></a>2.多个mapper文件</h2><p>(1)主配置文件中<mappers>中依次添加<mapper></mapper></mappers></p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs routeros">&lt;mapper <span class="hljs-attribute">resource</span>=<span class="hljs-string">&quot;twinkle/dao/StudentDao.xml&quot;</span>/&gt;<br></code></pre></td></tr></table></figure><p>(2)主配置文件中<mappers>中添加<package></package></mappers></p><p>有如下要求：</p><p>i. mapper文件名需要和接口名称一样，区分大小写</p><p>ii. mapper文件和接口需要在同一目录下</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs routeros">&lt;package <span class="hljs-attribute">name</span>=<span class="hljs-string">&quot;twinkle.dao&quot;</span>/&gt;<br></code></pre></td></tr></table></figure><h2 id="3-PageHelper"><a href="#3-PageHelper" class="headerlink" title="3.PageHelper"></a>3.PageHelper</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java">&lt;!--pom文件，加载资源--&gt;<br>&lt;dependency&gt;<br>  &lt;groupId&gt;com.github.pagehelper&lt;/groupId&gt;<br>  &lt;artifactId&gt;pagehelper&lt;/artifactId&gt;<br>  &lt;version&gt;<span class="hljs-number">5.1</span><span class="hljs-number">.10</span>&lt;/version&gt;<br>&lt;/dependency&gt;<br></code></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--主配置文件，配置插件--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">plugins</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">plugin</span> <span class="hljs-attr">interceptor</span>=<span class="hljs-string">&quot;com.github.pagehelper.PageInterceptor&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">plugins</span>&gt;</span><br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">PageHelper.startPage(pageNum,pageSize);<span class="hljs-comment">//得到第几页的几个数据</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>MySQL初级笔记</title>
    <link href="/2022/02/09/MySQL%E5%88%9D%E7%BA%A7%E7%AC%94%E8%AE%B0/"/>
    <url>/2022/02/09/MySQL%E5%88%9D%E7%BA%A7%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<h1 id="一、一些杂七杂八"><a href="#一、一些杂七杂八" class="headerlink" title="一、一些杂七杂八"></a>一、一些杂七杂八</h1><h2 id="1-端口"><a href="#1-端口" class="headerlink" title="1.端口"></a>1.端口</h2><p>文件下载（FTP）：21</p><p>MySQL:3306(默认)</p><p>本机MySLQ port: 1234</p><p>Oracle:1521</p><h2 id="2-卸载"><a href="#2-卸载" class="headerlink" title="2.卸载"></a>2.卸载</h2><p>(1)直接在安装包里删掉软件和服务</p><p>(2)C:\Program Files\MySQL  此安装目录要手动删干净</p><p>​    C:\ProgramData\MySQL  这个手动删干净</p><h2 id="3-命令"><a href="#3-命令" class="headerlink" title="3.命令"></a>3.命令</h2><p>(1) 如果sql数据量太大，使用source命令初始化sql脚本</p><p>(2) mysql -u****-p****</p><p>(3) show databases;（查看有哪些数据库）</p><p>(4) create database aaa(数据库的名字);</p><p>(5) use aaa;(使用具体的数据库)</p><p>(6) show tables;(查看该数据库下的表)</p><p>(7)desc 表名;（查看表的结构）</p><p>(8)导入表（库）：</p><p>​    create database 表&#x2F;库名;</p><p>​    use 表&#x2F;库名;</p><p>​    source 表&#x2F;库名.sql;</p><p>(9)drop table if exists 表名;</p><p>(10)drop table 表名;    (这个更通用一些)</p><p>注意：</p><p>1.sql语句中，字符串用&#x3D;&#x3D;单引号&#x3D;&#x3D;（在Oracle和其他数据库中也是这样用的）</p><p>2.&#x3D;&#x3D;增删改查 CRUD&#x3D;&#x3D; (Create增加 Retrieve检索 Update Delete)</p><h2 id="4-关系型数据库和非关系型数据库"><a href="#4-关系型数据库和非关系型数据库" class="headerlink" title="4.关系型数据库和非关系型数据库"></a>4.关系型数据库和非关系型数据库</h2><h3 id="（1）关系型数据库"><a href="#（1）关系型数据库" class="headerlink" title="（1）关系型数据库"></a>（1）关系型数据库</h3><p>MySQL是关系型数据库，采用了关系模型来组织数据的数据库。</p><p>关系模型指的是&#x3D;&#x3D;二维表格&#x3D;&#x3D;，一个关系型数据库就是由二维表格及其之间的联系所组成的一个数据组织。</p><p>数据库事务具有&#x3D;&#x3D;ACID特性&#x3D;&#x3D;，Atomic原子性、Consistency一致性、Isolation隔离性、Durability持久性</p><p>优点：容易理解、使用方便、易于维护（丰富的完整性大大降低了数据冗余和数据不一致的概率）</p><p>瓶颈：</p><p>​        高并发读写需求；网站用户并发性非常高，往往每秒上万次读写请求，对于传统关系型数据库来说，磁盘IO是一个很大的问题</p><p>​        海量数据的高效率读写；在一张包含海量数据的表中查询，效率非常低</p><p>​        高扩展性和可用性；数据库升级和扩展往往需要停机维护和数据迁移。</p><h3 id="（2）非关系型数据库"><a href="#（2）非关系型数据库" class="headerlink" title="（2）非关系型数据库"></a>（2）非关系型数据库</h3><p>数据结构化存储方法的集合</p><ul><li>面向&#x3D;&#x3D;高性能并发读写&#x3D;&#x3D;的key-value数据库：</li></ul><p>key-value数据库的主要特点即使具有极高的并发读写性能，&#x3D;&#x3D;Redis,Tokyo Cabinet,Flare&#x3D;&#x3D;就是这类的代表</p><ul><li>面向&#x3D;&#x3D;海量数据访问&#x3D;&#x3D;的面向文档数据库：</li></ul><p>这类数据库的特点是，可以在海量的数据中快速的查询数据，典型代表为&#x3D;&#x3D;MongoDB&#x3D;&#x3D;以及&#x3D;&#x3D;CouchDB&#x3D;&#x3D;</p><ul><li>面向&#x3D;&#x3D;可扩展性&#x3D;&#x3D;的分布式数据库：</li></ul><p>这类数据库想解决的问题就是传统数据库存在可扩展性上的缺陷，这类数据库可以适应数据量的增加以及数据结构的变化</p><h1 id="二、MySQL"><a href="#二、MySQL" class="headerlink" title="二、MySQL"></a>二、MySQL</h1><ol><li><p>DB : DataBase （数据库，是一个文件）</p></li><li><p>DBMS: DataBase Management System（数据库管理系统，例如 MySQL  Oracle  DB2   Sybase  SqlServer…）</p></li><li><p>SQL:结构化查询语言，标准的SQL适合于所有的数据库产品</p><p>总结：DBMS使用SQL管理DB</p></li></ol><p>1.SQL语句的分类：</p><p>DQL（Data Query Language数据查询语言）：查询语句，凡是$\textcolor{red}{select}$（查找）语句都是DQL</p><p>DML（Data Manipulation Language数据操作语言）：$\textcolor{red}{insert}$（插入） $\textcolor{red}{delete}$（删除）$\textcolor{red}{update}$（修改），对<strong>表中的数据</strong>进行增删改</p><p>DDL（Data Definition Language数据定义语言）：create（创建）  drop（丢弃）  alter（修改），对<strong>表结构</strong>的增删改</p><p>TCL（Transaction Control Language事务控制语言）： commit（提交事务）  rollback（回滚事务）</p><p>DCL（Data Control Language数据控制语言）：grant（授权）  revoke（撤销权限）等</p><p>mysql&gt; source ***.sql            批量地执行sql语句（特别是sql语句很多的情况下）</p><h1 id="三、必须掌握语句"><a href="#三、必须掌握语句" class="headerlink" title="三、必须掌握语句"></a>三、必须掌握语句</h1><h2 id="1-查询"><a href="#1-查询" class="headerlink" title="1.查询"></a>1.查询</h2><h3 id="1）简单查询"><a href="#1）简单查询" class="headerlink" title="1）简单查询"></a>1）简单查询</h3><figure class="highlight sql"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> empno, ename <span class="hljs-keyword">as</span> <span class="hljs-string">&#x27;重命名&#x27;</span> <span class="hljs-keyword">from</span> emp(表名);<br><br><span class="hljs-operator">/</span><span class="hljs-operator">/</span>直接使用空格代替<span class="hljs-keyword">as</span><br><span class="hljs-keyword">select</span> sal <span class="hljs-operator">*</span> <span class="hljs-number">12</span> <span class="hljs-string">&#x27;年薪&#x27;</span> <span class="hljs-keyword">from</span> emp;<br></code></pre></td></tr></table></figure><h3 id="2）条件查询"><a href="#2）条件查询" class="headerlink" title="2）条件查询"></a>2）条件查询</h3><p>select</p><p>​        字段,字段…</p><p>from </p><p>​        表名</p><p>where</p><p>​        条件；</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> sal <span class="hljs-operator">*</span> <span class="hljs-number">12</span> yealsal <span class="hljs-keyword">from</span> emp <span class="hljs-keyword">where</span> sal<span class="hljs-operator">=</span><span class="hljs-number">800</span><br></code></pre></td></tr></table></figure><p>&#x3D;&#x3D;执行顺序： from、where、select&#x3D;&#x3D;</p><table><thead><tr><th>运算符</th><th>说明</th></tr></thead><tbody><tr><td>&#x3D;</td><td>等于</td></tr><tr><td>&lt;&gt;或!&#x3D;</td><td>不等于</td></tr><tr><td>&lt;</td><td>小于</td></tr><tr><td>&lt;&#x3D;</td><td>小于等于</td></tr><tr><td>&gt;</td><td>大于</td></tr><tr><td>&gt;&#x3D;</td><td>大于等于</td></tr><tr><td>between … and ….</td><td>两个值之间,<strong>等同于 &gt;&#x3D; and &lt;&#x3D;</strong>  (使用的时候，必须左小右大)</td></tr><tr><td>&#x3D;&#x3D;is null&#x3D;&#x3D;</td><td>为null（is not null 不为空）</td></tr><tr><td><strong>and</strong></td><td>并且</td></tr><tr><td><strong>or</strong></td><td>或者</td></tr><tr><td>in</td><td>包含，相当于多个or（not in不在这个范围中）,in后面的不是区间，而是具体的值</td></tr><tr><td>not</td><td>not可以取非，主要用在is 或in中</td></tr><tr><td>like</td><td>like称为模糊查询，支持%或下划线匹配  %匹配任意个字符  下划线，一个下划线只匹配一个字符</td></tr></tbody></table><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> ename, job <span class="hljs-keyword">from</span> emp <span class="hljs-keyword">where</span> job <span class="hljs-keyword">in</span>(<span class="hljs-string">&#x27;salesman&#x27;</span>, <span class="hljs-string">&#x27;manager&#x27;</span>);<br><span class="hljs-operator">/</span><span class="hljs-operator">/</span>找出工资等于<span class="hljs-number">1000</span>和等于<span class="hljs-number">5000</span>的<br><span class="hljs-keyword">select</span> ename, job <span class="hljs-keyword">from</span> emp <span class="hljs-keyword">where</span> sal <span class="hljs-keyword">in</span>(<span class="hljs-number">1000</span>, <span class="hljs-number">2000</span>);<br></code></pre></td></tr></table></figure><h3 id="3）模糊查询"><a href="#3）模糊查询" class="headerlink" title="3）模糊查询"></a>3）模糊查询</h3><figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs axapta"><span class="hljs-comment">//找出名字里有O的</span><br><span class="hljs-keyword">select</span> ename <span class="hljs-keyword">from</span> emp <span class="hljs-keyword">where</span> ename <span class="hljs-keyword">like</span> <span class="hljs-string">&#x27;%o%&#x27;</span>;<br><span class="hljs-comment">//找出名字的第二个字母是A的</span><br><span class="hljs-keyword">select</span> ename <span class="hljs-keyword">from</span> emp <span class="hljs-keyword">where</span> ename <span class="hljs-keyword">like</span> <span class="hljs-string">&#x27;_a%&#x27;</span>;<br><span class="hljs-comment">//找出名字中有_的，需要转义字符</span><br><span class="hljs-keyword">select</span> ename <span class="hljs-keyword">from</span> emp <span class="hljs-keyword">where</span> ename <span class="hljs-keyword">like</span> <span class="hljs-string">&#x27;%/_%&#x27;</span><br></code></pre></td></tr></table></figure><h2 id="2-排序"><a href="#2-排序" class="headerlink" title="2.排序"></a>2.排序</h2><p>select </p><p>​    字段</p><p>from </p><p>​    字段 </p><p>order by </p><p>​    字段; （默认采用升序asc）</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-operator">/</span><span class="hljs-operator">/</span>按照工资降序排<br><span class="hljs-keyword">select</span> ename <span class="hljs-keyword">from</span> emp <span class="hljs-keyword">order</span> <span class="hljs-keyword">by</span> sal <span class="hljs-keyword">desc</span>;<span class="hljs-operator">/</span><span class="hljs-operator">/</span>降序descend，升序是<span class="hljs-keyword">asc</span>,ascend<br><span class="hljs-operator">/</span><span class="hljs-operator">/</span>按照工资降序排，当工资一样的时候，按照名字升序排<br><span class="hljs-keyword">select</span> ename <span class="hljs-keyword">from</span> emp <span class="hljs-keyword">order</span> <span class="hljs-keyword">by</span> sal <span class="hljs-keyword">desc</span>, ename <span class="hljs-keyword">asc</span>;<br><span class="hljs-operator">/</span><span class="hljs-operator">/</span><br><span class="hljs-keyword">select</span> ename , job, sal <span class="hljs-keyword">from</span> emp <span class="hljs-keyword">where</span> job<span class="hljs-operator">=</span><span class="hljs-string">&#x27;salesman&#x27;</span> <span class="hljs-keyword">order</span> <span class="hljs-keyword">by</span> sal <span class="hljs-keyword">desc</span>;<br></code></pre></td></tr></table></figure><h2 id="3-单行处理函数"><a href="#3-单行处理函数" class="headerlink" title="3.单行处理函数"></a>3.单行处理函数</h2><p>&#x3D;&#x3D;只要式子中有值为NULL，则运算后的值都是NULL&#x3D;&#x3D;</p><p>ifnull(可能为NULL的数据,被当做什么来处理)</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> ename,(sal<span class="hljs-operator">+</span>ifnull(comm,<span class="hljs-number">0</span>))<span class="hljs-operator">*</span><span class="hljs-number">12</span> <span class="hljs-keyword">as</span> yearsal <span class="hljs-keyword">from</span> emp<br></code></pre></td></tr></table></figure><h2 id="4-多行处理函数（分组函数、聚合函数）（只有5个）"><a href="#4-多行处理函数（分组函数、聚合函数）（只有5个）" class="headerlink" title="4.多行处理函数（分组函数、聚合函数）（只有5个）"></a>4.多行处理函数（分组函数、聚合函数）（只有5个）</h2><p>分组函数一般和group by联合使用，所以叫做分组函数，</p><p>分组函数在group by语句执行完后才会执行</p><p>(1)多行处理函数（输入多行、输出一行），&#x3D;&#x3D;多行处理函数自动忽略NULL&#x3D;&#x3D;（即使有NULL，但是运算后值不为NULL）</p><p>(2)&#x3D;&#x3D;分组函数不能直接使用在where子句中&#x3D;&#x3D;(这和执行顺序有关！！！)</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-operator">/</span><span class="hljs-operator">/</span>找出工资大于平均工资的员工<br><span class="hljs-keyword">select</span> ename, sal <span class="hljs-keyword">from</span> emp <span class="hljs-keyword">where</span> sal <span class="hljs-operator">&gt;</span> (<span class="hljs-keyword">select</span> <span class="hljs-built_in">avg</span>(sal) <span class="hljs-keyword">from</span> emp);<br></code></pre></td></tr></table></figure><p>sum() 求和</p><p>max() 最大数</p><p>min() 最小数</p><p>avg() 平均数</p><p>count() 求和</p><p>​    &#x3D;&#x3D;count(*)为总记录条数&#x3D;&#x3D;</p><p>​    &#x3D;&#x3D;count(字段)为不为空的字段条数&#x3D;&#x3D;</p><h2 id="5-group-by-和having"><a href="#5-group-by-和having" class="headerlink" title="5.group by 和having"></a>5.group by 和having</h2><p>group by :按照某个字段或者某些字段进行过滤</p><p>having:对分组之后的数据进行再次过滤</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-operator">/</span><span class="hljs-operator">/</span>找出每个工作岗位的最高薪资<br><span class="hljs-keyword">select</span> <span class="hljs-built_in">max</span>(sal) <span class="hljs-keyword">from</span> emp <span class="hljs-keyword">group</span> <span class="hljs-keyword">by</span> job;<br><span class="hljs-operator">/</span><span class="hljs-operator">/</span>找出某个工作岗位的最高薪资<br><span class="hljs-keyword">select</span> <span class="hljs-built_in">max</span>(sal), job <span class="hljs-keyword">from</span> emp <span class="hljs-keyword">where</span> job<span class="hljs-operator">=</span><span class="hljs-string">&#x27;clerk&#x27;</span> <span class="hljs-keyword">group</span> <span class="hljs-keyword">by</span> job;<br><span class="hljs-operator">/</span><span class="hljs-operator">/</span>找出每个部门(deptno)每个工作岗位(job)的平均薪资<br><span class="hljs-keyword">select</span> <span class="hljs-built_in">avg</span>(sal), job, deptno <span class="hljs-keyword">from</span> emp <span class="hljs-keyword">group</span> <span class="hljs-keyword">by</span> deptno, job;<br></code></pre></td></tr></table></figure><p>&#x3D;&#x3D;group by后才能执行分组函数&#x3D;&#x3D;</p><p>&#x3D;&#x3D;如果sql语句用了group by，那么select后只能跟group by的参数和分组函数&#x3D;&#x3D;（mysql里是没有意义的，oracle里是报错的）</p><p>group by 解释：<a href="https://blog.csdn.net/zj20142213/article/details/81073428">https://blog.csdn.net/zj20142213/article/details/81073428</a></p><h2 id="6-having和where"><a href="#6-having和where" class="headerlink" title="6.having和where"></a>6.having和where</h2><p>1)where和having都能使用的情况用where，否则用having</p><p>where在group by 前执行，且只能操作原始数据</p><p>having在group by 后执行，可以操作分组函数</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-operator">/</span><span class="hljs-operator">/</span>找出每个部门的最高薪资，要求显示薪资大于<span class="hljs-number">3000</span>的数据<br><span class="hljs-keyword">select</span> <span class="hljs-built_in">max</span>(sal),deptno <span class="hljs-keyword">from</span> emp <span class="hljs-keyword">where</span> sal<span class="hljs-operator">&gt;</span><span class="hljs-number">3000</span> <span class="hljs-keyword">group</span> <span class="hljs-keyword">by</span> deptno;<br><span class="hljs-operator">/</span><span class="hljs-operator">/</span>找出每个部门的平均薪资，要求显示薪资大于<span class="hljs-number">2000</span>的数据<br><span class="hljs-keyword">select</span> <span class="hljs-built_in">avg</span>(sal) average, deptno <span class="hljs-keyword">from</span> emp <span class="hljs-keyword">group</span> <span class="hljs-keyword">by</span> deptno <span class="hljs-keyword">having</span> average<span class="hljs-operator">&gt;</span><span class="hljs-number">2000</span>;<br></code></pre></td></tr></table></figure><h2 id="7-执行顺序问题"><a href="#7-执行顺序问题" class="headerlink" title="7.执行顺序问题"></a>7.执行顺序问题</h2><p>选中某张表，确定where位置，是否group by ，过滤having，选择select，最后order by显示出来</p><p>select             5</p><p>​    ..</p><p>from             1</p><p>​    ..</p><p>where            2</p><p>​    ..</p><p>group by            3（group by之后，才能使用分组函数）</p><p>​    ..</p><p>having            4</p><p>​    ..    </p><p>order by            6</p><p>​    ..</p><p>limit                7</p><p>​    ..</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-number">1.</span><span class="hljs-keyword">FROM</span> <span class="hljs-operator">&lt;</span>left_table<span class="hljs-operator">&gt;</span><br><span class="hljs-number">2.</span><span class="hljs-keyword">ON</span> <span class="hljs-operator">&lt;</span>join_condition<span class="hljs-operator">&gt;</span><br><span class="hljs-number">3.</span><span class="hljs-operator">&lt;</span>join_type<span class="hljs-operator">&gt;</span> <span class="hljs-keyword">JOIN</span> <span class="hljs-operator">&lt;</span>right_table<span class="hljs-operator">&gt;</span><br><span class="hljs-number">4.</span><span class="hljs-keyword">WHERE</span> <span class="hljs-operator">&lt;</span>where_conditon<span class="hljs-operator">&gt;</span><br><span class="hljs-number">5.</span><span class="hljs-keyword">GROUP</span> <span class="hljs-keyword">BY</span> <span class="hljs-operator">&lt;</span>group_by_list<span class="hljs-operator">&gt;</span><br><span class="hljs-number">6.</span><span class="hljs-keyword">HAVING</span><br><span class="hljs-number">7.</span><span class="hljs-keyword">SELECT</span><br><span class="hljs-number">8.</span><span class="hljs-keyword">DISTINCT</span> <span class="hljs-operator">&lt;</span>select_list<span class="hljs-operator">&gt;</span><br><span class="hljs-number">9.</span><span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> <span class="hljs-operator">&lt;</span>order_by_condition<span class="hljs-operator">&gt;</span><br><span class="hljs-number">10.</span>LIMIT <span class="hljs-operator">&lt;</span>limit_number<span class="hljs-operator">&gt;</span><br></code></pre></td></tr></table></figure><h2 id="8-去除查询记录集里的重复记录distinct"><a href="#8-去除查询记录集里的重复记录distinct" class="headerlink" title="8.去除查询记录集里的重复记录distinct"></a>8.去除查询记录集里的重复记录distinct</h2><p>只是对查询结果集去重，但是不改变表的数据</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-operator">/</span><span class="hljs-operator">/</span>统计所有的岗位<br><span class="hljs-keyword">select</span> <span class="hljs-keyword">distinct</span> job <span class="hljs-keyword">from</span> emp;<br><span class="hljs-operator">/</span><span class="hljs-operator">/</span><span class="hljs-keyword">distinct</span>需放在所有的字段前，后面的字段联合<br><span class="hljs-keyword">select</span> <span class="hljs-keyword">distinct</span> job,deptno <span class="hljs-keyword">from</span> emp;<br></code></pre></td></tr></table></figure><h2 id="9-union"><a href="#9-union" class="headerlink" title="9.union"></a>9.union</h2><p>将查询的结果集拼接起来（只能拼接列数一样的查询结果集）</p><h1 id="四、连接查询"><a href="#四、连接查询" class="headerlink" title="四、连接查询"></a>四、连接查询</h1><h2 id="1-什么是连接查询"><a href="#1-什么是连接查询" class="headerlink" title="1.什么是连接查询"></a>1.什么是连接查询</h2><p>多张表联合查询取出最终的记录</p><h2 id="2-连接查询的分类"><a href="#2-连接查询的分类" class="headerlink" title="2.连接查询的分类"></a>2.连接查询的分类</h2><p>根据表的连接方式来划分，包括：</p><p>​        内连接：</p><p>​            等值连接</p><p>​            非等值连接</p><p>​            自连接</p><p>​        外连接：</p><p>​            左外连接（左连接，LEFT JOIN）</p><p>​            右外连接（右连接，RIGHT JOIN）</p><p>&#x3D;&#x3D;内连接&#x3D;&#x3D;：假设A和B两张表进行连接，AB两张表没有主副之分，A和B的数据匹配不上就不查</p><p>&#x3D;&#x3D;外连接&#x3D;&#x3D;：假设A和B两张表进行连接，有一张表是主表，一张是副表，当副表中的数据没有和主表中的数据匹配上，副表自动模拟出NULL与之匹配</p><h2 id="3-笛卡尔乘积现象："><a href="#3-笛卡尔乘积现象：" class="headerlink" title="3.笛卡尔乘积现象："></a>3.笛卡尔乘积现象：</h2><p>如果两张表连接，没有任何条件限制，那么查询结果条数就是两张表记录条数的乘积</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> ename, dname <span class="hljs-keyword">from</span> emp, dept;<br><span class="hljs-operator">/</span><span class="hljs-operator">/</span>一共有<span class="hljs-number">56</span>条记录，每个ename都会和每个dname匹配<br></code></pre></td></tr></table></figure><img src="/2022/02/09/MySQL%E5%88%9D%E7%BA%A7%E7%AC%94%E8%AE%B0/LanguageLearning\MySQL\MySQL初级笔记.assets\image-20210923142329662.png" alt="image-20210923142329662 " style="zoom:80%;"><img src="/2022/02/09/MySQL%E5%88%9D%E7%BA%A7%E7%AC%94%E8%AE%B0/LanguageLearning\MySQL\MySQL初级笔记.assets\image-20210923142319051.png" alt="image-20210923142319051 " style="zoom:80%;"><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sql">案例：找出每一个员工的部门名称，要求显示员工名和部门名<br><span class="hljs-keyword">select</span> e.ename, d.dname <span class="hljs-keyword">from</span> emp e, dept d <span class="hljs-keyword">where</span> e.deptno <span class="hljs-operator">=</span> d.deptno;<br></code></pre></td></tr></table></figure><p>如何避免笛卡尔乘积现象？——加条件进行过滤</p><p>但是&#x3D;&#x3D;不会减少记录的匹配次数&#x3D;&#x3D;，只是显示的是有效记录</p><h2 id="4-内连接-join-on"><a href="#4-内连接-join-on" class="headerlink" title="4.内连接 join on"></a>4.内连接 join on</h2><p>假设A和B两张表进行连接，AB两张表没有主副之分，A和B的数据匹配不上就不查</p><p>… A(表) (inner) join B(表) on 连接条件 where…</p><p>其中on后面接连接条件，where后跟过滤条件</p><p>1）内连接中的等值连接和非等值连接</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> e.ename, d.dname <span class="hljs-keyword">from</span> emp e, dept d <span class="hljs-keyword">where</span> e.deptno <span class="hljs-operator">=</span> d.deptno;`<span class="hljs-operator">/</span><span class="hljs-operator">/</span>SQL92语句<br><span class="hljs-operator">/</span><span class="hljs-operator">/</span>内连接中的等值连接<br><span class="hljs-operator">/</span><span class="hljs-operator">/</span>找出员工以及所对应的部门名称<br><span class="hljs-keyword">select</span> <br>e.ename, d.dname <br><span class="hljs-keyword">from</span> <br>emp e <br>(<span class="hljs-keyword">inner</span>) <span class="hljs-keyword">join</span>  <br>dept d <br><span class="hljs-keyword">on</span> <br>e.deptno <span class="hljs-operator">=</span> d.deptno;<span class="hljs-operator">/</span><span class="hljs-operator">/</span>SQL99语句<br><br><span class="hljs-operator">/</span><span class="hljs-operator">/</span>内连接中的非等值连接<br><span class="hljs-operator">/</span><span class="hljs-operator">/</span>找出员工以及所对应的工资等级<br><span class="hljs-keyword">select</span> e.ename, s.grade <span class="hljs-keyword">from</span> emp e <span class="hljs-keyword">join</span> salgrade s <span class="hljs-keyword">on</span> e.sal <span class="hljs-keyword">between</span> s.losal <span class="hljs-keyword">and</span> s.hisal;<br></code></pre></td></tr></table></figure><p>2）内连接中的自连接</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-operator">/</span><span class="hljs-operator">/</span>找出每个员工的上级领导，要求显示员工名和对应的领导名<br><span class="hljs-operator">/</span><span class="hljs-operator">/</span>此时员工中的king没有领导，没有记录<br><span class="hljs-operator">+</span><span class="hljs-comment">-------+--------+-------+</span><br><span class="hljs-operator">|</span> empno <span class="hljs-operator">|</span> ename  <span class="hljs-operator">|</span> ename <span class="hljs-operator">|</span><br><span class="hljs-operator">+</span><span class="hljs-comment">-------+--------+-------+</span><br><span class="hljs-operator">|</span>  <span class="hljs-number">7369</span> <span class="hljs-operator">|</span> SMITH  <span class="hljs-operator">|</span> FORD  <span class="hljs-operator">|</span><br><span class="hljs-operator">|</span>  <span class="hljs-number">7499</span> <span class="hljs-operator">|</span> ALLEN  <span class="hljs-operator">|</span> BLAKE <span class="hljs-operator">|</span><br><span class="hljs-operator">|</span>  <span class="hljs-number">7521</span> <span class="hljs-operator">|</span> WARD   <span class="hljs-operator">|</span> BLAKE <span class="hljs-operator">|</span><br><span class="hljs-operator">|</span>  <span class="hljs-number">7566</span> <span class="hljs-operator">|</span> JONES  <span class="hljs-operator">|</span> KING  <span class="hljs-operator">|</span><br><span class="hljs-operator">|</span>  <span class="hljs-number">7654</span> <span class="hljs-operator">|</span> MARTIN <span class="hljs-operator">|</span> BLAKE <span class="hljs-operator">|</span><br><span class="hljs-operator">|</span>  <span class="hljs-number">7698</span> <span class="hljs-operator">|</span> BLAKE  <span class="hljs-operator">|</span> KING  <span class="hljs-operator">|</span><br><span class="hljs-operator">|</span>  <span class="hljs-number">7782</span> <span class="hljs-operator">|</span> CLARK  <span class="hljs-operator">|</span> KING  <span class="hljs-operator">|</span><br><span class="hljs-operator">|</span>  <span class="hljs-number">7788</span> <span class="hljs-operator">|</span> SCOTT  <span class="hljs-operator">|</span> JONES <span class="hljs-operator">|</span><br><span class="hljs-operator">|</span>  <span class="hljs-number">7844</span> <span class="hljs-operator">|</span> TURNER <span class="hljs-operator">|</span> BLAKE <span class="hljs-operator">|</span><br><span class="hljs-operator">|</span>  <span class="hljs-number">7876</span> <span class="hljs-operator">|</span> ADAMS  <span class="hljs-operator">|</span> SCOTT <span class="hljs-operator">|</span><br><span class="hljs-operator">|</span>  <span class="hljs-number">7900</span> <span class="hljs-operator">|</span> JAMES  <span class="hljs-operator">|</span> BLAKE <span class="hljs-operator">|</span><br><span class="hljs-operator">|</span>  <span class="hljs-number">7902</span> <span class="hljs-operator">|</span> FORD   <span class="hljs-operator">|</span> JONES <span class="hljs-operator">|</span><br><span class="hljs-operator">|</span>  <span class="hljs-number">7934</span> <span class="hljs-operator">|</span> MILLER <span class="hljs-operator">|</span> CLARK <span class="hljs-operator">|</span><br><span class="hljs-operator">+</span><span class="hljs-comment">-------+--------+-------+</span><br><span class="hljs-number">13</span> <span class="hljs-keyword">rows</span> <span class="hljs-keyword">in</span> <span class="hljs-keyword">set</span> (<span class="hljs-number">0.00</span> sec)<br><br><span class="hljs-keyword">select</span> <br>e1.empno, e1.ename, e2.ename <br><span class="hljs-keyword">from</span> <br>emp e1 <br><span class="hljs-keyword">join</span> <br>emp e2 <br><span class="hljs-keyword">on</span> <br>e1.mgr <span class="hljs-operator">=</span> e2.empno;<br></code></pre></td></tr></table></figure><h2 id="5-外连接"><a href="#5-外连接" class="headerlink" title="5.外连接"></a>5.外连接</h2><p>当副表中的数据没有和主表中的数据匹配上，副表自动模拟出NULL与之匹配</p><p>左连接就是以join左边的表为主表，右连接以join右边的表为主表</p><p>… A(表) left&#x2F;right (outer) join B(表) on 连接条件 where…</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-operator">/</span><span class="hljs-operator">/</span>找出“每个”员工的上级领导<br><span class="hljs-keyword">select</span> employee.ename , employer.ename <span class="hljs-keyword">from</span> emp employee <span class="hljs-keyword">left</span> <span class="hljs-keyword">join</span> emp employer <span class="hljs-keyword">on</span> employee.mgr<span class="hljs-operator">=</span>employer.empno;<br><span class="hljs-operator">+</span><span class="hljs-comment">--------+-------+</span><br><span class="hljs-operator">|</span> ename  <span class="hljs-operator">|</span> ename <span class="hljs-operator">|</span><br><span class="hljs-operator">+</span><span class="hljs-comment">--------+-------+</span><br><span class="hljs-operator">|</span> SMITH  <span class="hljs-operator">|</span> FORD  <span class="hljs-operator">|</span><br><span class="hljs-operator">|</span> ALLEN  <span class="hljs-operator">|</span> BLAKE <span class="hljs-operator">|</span><br><span class="hljs-operator">|</span> WARD   <span class="hljs-operator">|</span> BLAKE <span class="hljs-operator">|</span><br><span class="hljs-operator">|</span> JONES  <span class="hljs-operator">|</span> KING  <span class="hljs-operator">|</span><br><span class="hljs-operator">|</span> MARTIN <span class="hljs-operator">|</span> BLAKE <span class="hljs-operator">|</span><br><span class="hljs-operator">|</span> BLAKE  <span class="hljs-operator">|</span> KING  <span class="hljs-operator">|</span><br><span class="hljs-operator">|</span> CLARK  <span class="hljs-operator">|</span> KING  <span class="hljs-operator">|</span><br><span class="hljs-operator">|</span> SCOTT  <span class="hljs-operator">|</span> JONES <span class="hljs-operator">|</span><br><span class="hljs-operator">|</span> KING   <span class="hljs-operator">|</span> <span class="hljs-keyword">NULL</span>  <span class="hljs-operator">|</span><br><span class="hljs-operator">|</span> TURNER <span class="hljs-operator">|</span> BLAKE <span class="hljs-operator">|</span><br><span class="hljs-operator">|</span> ADAMS  <span class="hljs-operator">|</span> SCOTT <span class="hljs-operator">|</span><br><span class="hljs-operator">|</span> JAMES  <span class="hljs-operator">|</span> BLAKE <span class="hljs-operator">|</span><br><span class="hljs-operator">|</span> FORD   <span class="hljs-operator">|</span> JONES <span class="hljs-operator">|</span><br><span class="hljs-operator">|</span> MILLER <span class="hljs-operator">|</span> CLARK <span class="hljs-operator">|</span><br><span class="hljs-operator">+</span><span class="hljs-comment">--------+-------+</span><br><span class="hljs-number">14</span> <span class="hljs-keyword">rows</span> <span class="hljs-keyword">in</span> <span class="hljs-keyword">set</span> (<span class="hljs-number">0.00</span> sec)<br><span class="hljs-operator">/</span><span class="hljs-operator">/</span>找出哪个部门没有员工<br><span class="hljs-operator">/</span><span class="hljs-operator">/</span>不用连接，直接筛选出emp表中员工所在部分的记录，选出不在这个记录中的，即没有员工<br><span class="hljs-keyword">select</span> d.deptno <span class="hljs-keyword">from</span> dept d <span class="hljs-keyword">where</span> d.deptno <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> (<span class="hljs-keyword">select</span> <span class="hljs-keyword">distinct</span> deptno <span class="hljs-keyword">from</span> emp);<br><span class="hljs-operator">/</span><span class="hljs-operator">/</span>用连接，拼接两张表的重合部分，然后挑选出为空的部分<br><span class="hljs-keyword">select</span> e.<span class="hljs-operator">*</span>,d.<span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> dept d <span class="hljs-keyword">left</span> <span class="hljs-keyword">join</span> emp e <span class="hljs-keyword">on</span> d.deptno <span class="hljs-operator">=</span> e.deptno <span class="hljs-keyword">where</span> e.ename <span class="hljs-keyword">is</span> <span class="hljs-keyword">null</span>;<br></code></pre></td></tr></table></figure><h2 id="6-三张表及以上的连接查询-可以分开写表的内连接-x2F-外连接"><a href="#6-三张表及以上的连接查询-可以分开写表的内连接-x2F-外连接" class="headerlink" title="6.三张表及以上的连接查询(可以分开写表的内连接&#x2F;外连接)"></a>6.三张表及以上的连接查询(可以分开写表的内连接&#x2F;外连接)</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-operator">/</span><span class="hljs-operator">/</span>找出每一个员工的部门名称、工资等级以及上级领导的名字（主要是上级领导的名字，如果用普通连接或者内连接，不会自动补全<span class="hljs-keyword">NULL</span>，只有外连接会补全<span class="hljs-keyword">NULL</span>）<br><span class="hljs-keyword">select</span> e1.ename,d.dname, s.grade, e2.ename <span class="hljs-keyword">from</span> emp e1, emp e2, dept d, salgrade s <span class="hljs-keyword">where</span> e1.sal <span class="hljs-keyword">between</span> s.losal <span class="hljs-keyword">and</span> s.hisal <span class="hljs-keyword">and</span> d.deptno<span class="hljs-operator">=</span>e1.deptno <span class="hljs-keyword">and</span> e1.mgr<span class="hljs-operator">=</span>e2.empno;<br><span class="hljs-operator">+</span><span class="hljs-comment">--------+------------+-------+-------+</span><br><span class="hljs-operator">|</span> ename  <span class="hljs-operator">|</span> dname      <span class="hljs-operator">|</span> grade <span class="hljs-operator">|</span> ename <span class="hljs-operator">|</span><br><span class="hljs-operator">+</span><span class="hljs-comment">--------+------------+-------+-------+</span><br><span class="hljs-operator">|</span> SMITH  <span class="hljs-operator">|</span> RESEARCH   <span class="hljs-operator">|</span>     <span class="hljs-number">1</span> <span class="hljs-operator">|</span> FORD  <span class="hljs-operator">|</span><br><span class="hljs-operator">|</span> ALLEN  <span class="hljs-operator">|</span> SALES      <span class="hljs-operator">|</span>     <span class="hljs-number">3</span> <span class="hljs-operator">|</span> BLAKE <span class="hljs-operator">|</span><br><span class="hljs-operator">|</span> WARD   <span class="hljs-operator">|</span> SALES      <span class="hljs-operator">|</span>     <span class="hljs-number">2</span> <span class="hljs-operator">|</span> BLAKE <span class="hljs-operator">|</span><br><span class="hljs-operator">|</span> JONES  <span class="hljs-operator">|</span> RESEARCH   <span class="hljs-operator">|</span>     <span class="hljs-number">4</span> <span class="hljs-operator">|</span> KING  <span class="hljs-operator">|</span><br><span class="hljs-operator">|</span> MARTIN <span class="hljs-operator">|</span> SALES      <span class="hljs-operator">|</span>     <span class="hljs-number">2</span> <span class="hljs-operator">|</span> BLAKE <span class="hljs-operator">|</span><br><span class="hljs-operator">|</span> BLAKE  <span class="hljs-operator">|</span> SALES      <span class="hljs-operator">|</span>     <span class="hljs-number">4</span> <span class="hljs-operator">|</span> KING  <span class="hljs-operator">|</span><br><span class="hljs-operator">|</span> CLARK  <span class="hljs-operator">|</span> ACCOUNTING <span class="hljs-operator">|</span>     <span class="hljs-number">4</span> <span class="hljs-operator">|</span> KING  <span class="hljs-operator">|</span><br><span class="hljs-operator">|</span> SCOTT  <span class="hljs-operator">|</span> RESEARCH   <span class="hljs-operator">|</span>     <span class="hljs-number">4</span> <span class="hljs-operator">|</span> JONES <span class="hljs-operator">|</span><br><span class="hljs-operator">|</span> TURNER <span class="hljs-operator">|</span> SALES      <span class="hljs-operator">|</span>     <span class="hljs-number">3</span> <span class="hljs-operator">|</span> BLAKE <span class="hljs-operator">|</span><br><span class="hljs-operator">|</span> ADAMS  <span class="hljs-operator">|</span> RESEARCH   <span class="hljs-operator">|</span>     <span class="hljs-number">1</span> <span class="hljs-operator">|</span> SCOTT <span class="hljs-operator">|</span><br><span class="hljs-operator">|</span> JAMES  <span class="hljs-operator">|</span> SALES      <span class="hljs-operator">|</span>     <span class="hljs-number">1</span> <span class="hljs-operator">|</span> BLAKE <span class="hljs-operator">|</span><br><span class="hljs-operator">|</span> FORD   <span class="hljs-operator">|</span> RESEARCH   <span class="hljs-operator">|</span>     <span class="hljs-number">4</span> <span class="hljs-operator">|</span> JONES <span class="hljs-operator">|</span><br><span class="hljs-operator">|</span> MILLER <span class="hljs-operator">|</span> ACCOUNTING <span class="hljs-operator">|</span>     <span class="hljs-number">2</span> <span class="hljs-operator">|</span> CLARK <span class="hljs-operator">|</span><br><span class="hljs-operator">+</span><span class="hljs-comment">--------+------------+-------+-------+</span><br><span class="hljs-number">13</span> <span class="hljs-keyword">rows</span> <span class="hljs-keyword">in</span> <span class="hljs-keyword">set</span> (<span class="hljs-number">0.00</span> sec)<br>此时只有<span class="hljs-number">13</span>条数据<br><span class="hljs-keyword">select</span> <br>e.ename, employer.ename, s.grade, d.dname <br><span class="hljs-keyword">from</span> <br>emp e <br><span class="hljs-keyword">join</span> <br>emp employer <br><span class="hljs-keyword">on</span> <br>e.mgr<span class="hljs-operator">=</span>employer.empno <br><span class="hljs-keyword">join</span> <br>dept d <br><span class="hljs-keyword">on</span> <br>d.deptno<span class="hljs-operator">=</span>e.deptno <br><span class="hljs-keyword">left</span> <span class="hljs-keyword">join</span> <br>salgrade s <br><span class="hljs-keyword">on</span> <br>e.sal <br><span class="hljs-keyword">between</span> <br>s.losal <span class="hljs-keyword">and</span> s.hisal;<br><span class="hljs-operator">+</span><span class="hljs-comment">--------+-------+-------+------------+</span><br><span class="hljs-operator">|</span> ename  <span class="hljs-operator">|</span> ename <span class="hljs-operator">|</span> grade <span class="hljs-operator">|</span> dname      <span class="hljs-operator">|</span><br><span class="hljs-operator">+</span><span class="hljs-comment">--------+-------+-------+------------+</span><br><span class="hljs-operator">|</span> SMITH  <span class="hljs-operator">|</span> FORD  <span class="hljs-operator">|</span>     <span class="hljs-number">1</span> <span class="hljs-operator">|</span> RESEARCH   <span class="hljs-operator">|</span><br><span class="hljs-operator">|</span> ALLEN  <span class="hljs-operator">|</span> BLAKE <span class="hljs-operator">|</span>     <span class="hljs-number">3</span> <span class="hljs-operator">|</span> SALES      <span class="hljs-operator">|</span><br><span class="hljs-operator">|</span> WARD   <span class="hljs-operator">|</span> BLAKE <span class="hljs-operator">|</span>     <span class="hljs-number">2</span> <span class="hljs-operator">|</span> SALES      <span class="hljs-operator">|</span><br><span class="hljs-operator">|</span> JONES  <span class="hljs-operator">|</span> KING  <span class="hljs-operator">|</span>     <span class="hljs-number">4</span> <span class="hljs-operator">|</span> RESEARCH   <span class="hljs-operator">|</span><br><span class="hljs-operator">|</span> MARTIN <span class="hljs-operator">|</span> BLAKE <span class="hljs-operator">|</span>     <span class="hljs-number">2</span> <span class="hljs-operator">|</span> SALES      <span class="hljs-operator">|</span><br><span class="hljs-operator">|</span> BLAKE  <span class="hljs-operator">|</span> KING  <span class="hljs-operator">|</span>     <span class="hljs-number">4</span> <span class="hljs-operator">|</span> SALES      <span class="hljs-operator">|</span><br><span class="hljs-operator">|</span> CLARK  <span class="hljs-operator">|</span> KING  <span class="hljs-operator">|</span>     <span class="hljs-number">4</span> <span class="hljs-operator">|</span> ACCOUNTING <span class="hljs-operator">|</span><br><span class="hljs-operator">|</span> SCOTT  <span class="hljs-operator">|</span> JONES <span class="hljs-operator">|</span>     <span class="hljs-number">4</span> <span class="hljs-operator">|</span> RESEARCH   <span class="hljs-operator">|</span><br><span class="hljs-operator">|</span> KING   <span class="hljs-operator">|</span> <span class="hljs-keyword">NULL</span>  <span class="hljs-operator">|</span>     <span class="hljs-number">5</span> <span class="hljs-operator">|</span> ACCOUNTING <span class="hljs-operator">|</span><br><span class="hljs-operator">|</span> TURNER <span class="hljs-operator">|</span> BLAKE <span class="hljs-operator">|</span>     <span class="hljs-number">3</span> <span class="hljs-operator">|</span> SALES      <span class="hljs-operator">|</span><br><span class="hljs-operator">|</span> ADAMS  <span class="hljs-operator">|</span> SCOTT <span class="hljs-operator">|</span>     <span class="hljs-number">1</span> <span class="hljs-operator">|</span> RESEARCH   <span class="hljs-operator">|</span><br><span class="hljs-operator">|</span> JAMES  <span class="hljs-operator">|</span> BLAKE <span class="hljs-operator">|</span>     <span class="hljs-number">1</span> <span class="hljs-operator">|</span> SALES      <span class="hljs-operator">|</span><br><span class="hljs-operator">|</span> FORD   <span class="hljs-operator">|</span> JONES <span class="hljs-operator">|</span>     <span class="hljs-number">4</span> <span class="hljs-operator">|</span> RESEARCH   <span class="hljs-operator">|</span><br><span class="hljs-operator">|</span> MILLER <span class="hljs-operator">|</span> CLARK <span class="hljs-operator">|</span>     <span class="hljs-number">2</span> <span class="hljs-operator">|</span> ACCOUNTING <span class="hljs-operator">|</span><br><span class="hljs-operator">+</span><span class="hljs-comment">--------+-------+-------+------------+</span><br><span class="hljs-number">14</span> <span class="hljs-keyword">rows</span> <span class="hljs-keyword">in</span> <span class="hljs-keyword">set</span> (<span class="hljs-number">0.00</span> sec)<br></code></pre></td></tr></table></figure><h1 id="五、子查询"><a href="#五、子查询" class="headerlink" title="五、子查询"></a>五、子查询</h1><h2 id="1-概念"><a href="#1-概念" class="headerlink" title="1.概念"></a>1.概念</h2><p>select语句当中嵌套select语句，被嵌套的select语句就是子查询</p><p>主要出现于：</p><p>select </p><p>​    …(select).</p><p>from </p><p>​    (select)</p><p>where</p><p>​    (select)</p><h2 id="2-from里面子查询（临时表，但是可能降低效率，权衡）"><a href="#2-from里面子查询（临时表，但是可能降低效率，权衡）" class="headerlink" title="2.from里面子查询（临时表，但是可能降低效率，权衡）"></a>2.from里面子查询（临时表，但是可能降低效率，权衡）</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-operator">/</span><span class="hljs-operator">/</span>案例：找出每个部门平均薪水的薪资等级<br><span class="hljs-operator">/</span><span class="hljs-operator">/</span>先找出每个部门的平均薪水<br><span class="hljs-keyword">select</span> deptno, <span class="hljs-built_in">avg</span>(sal) avg <span class="hljs-keyword">from</span> emp <span class="hljs-keyword">group</span> <span class="hljs-keyword">by</span> deptno;<br><span class="hljs-operator">/</span><span class="hljs-operator">/</span>再找出薪资等级<br><span class="hljs-keyword">select</span> emp.ename, emp.sal, salgrade.grade <span class="hljs-keyword">from</span> emp <span class="hljs-keyword">left</span> <span class="hljs-keyword">join</span> salgrade <span class="hljs-keyword">on</span> emp.sal <span class="hljs-keyword">between</span> salgrade.losal <span class="hljs-keyword">and</span> salgrade.hisal;<br><span class="hljs-operator">/</span><span class="hljs-operator">/</span>将两个逻辑拼接在一起<br><span class="hljs-keyword">select</span> e.<span class="hljs-operator">*</span>,s.grade <span class="hljs-keyword">from</span> (<span class="hljs-keyword">select</span> deptno, <span class="hljs-built_in">avg</span>(sal) avg <span class="hljs-keyword">from</span> emp <span class="hljs-keyword">group</span> <span class="hljs-keyword">by</span> deptno) e <span class="hljs-keyword">left</span> <span class="hljs-keyword">join</span> salgrade s <span class="hljs-keyword">on</span> e.avg <span class="hljs-keyword">between</span> s.losal <span class="hljs-keyword">and</span> s.hisal;<br><span class="hljs-operator">+</span><span class="hljs-comment">--------+-------------+-------+</span><br><span class="hljs-operator">|</span> deptno <span class="hljs-operator">|</span> avg         <span class="hljs-operator">|</span> grade <span class="hljs-operator">|</span><br><span class="hljs-operator">+</span><span class="hljs-comment">--------+-------------+-------+</span><br><span class="hljs-operator">|</span>     <span class="hljs-number">10</span> <span class="hljs-operator">|</span> <span class="hljs-number">2916.666667</span> <span class="hljs-operator">|</span>     <span class="hljs-number">4</span> <span class="hljs-operator">|</span><br><span class="hljs-operator">|</span>     <span class="hljs-number">20</span> <span class="hljs-operator">|</span> <span class="hljs-number">2175.000000</span> <span class="hljs-operator">|</span>     <span class="hljs-number">4</span> <span class="hljs-operator">|</span><br><span class="hljs-operator">|</span>     <span class="hljs-number">30</span> <span class="hljs-operator">|</span> <span class="hljs-number">1566.666667</span> <span class="hljs-operator">|</span>     <span class="hljs-number">3</span> <span class="hljs-operator">|</span><br><span class="hljs-operator">+</span><span class="hljs-comment">--------+-------------+-------+</span><br><span class="hljs-number">3</span> <span class="hljs-keyword">rows</span> <span class="hljs-keyword">in</span> <span class="hljs-keyword">set</span> (<span class="hljs-number">0.00</span> sec)<br><br><span class="hljs-operator">/</span><span class="hljs-operator">/</span>案例：找出每个部门平均的薪水等级（先求薪水等级，再部门平均）<br><span class="hljs-operator">/</span><span class="hljs-operator">/</span>求出薪水等级<br><span class="hljs-keyword">select</span> emp.ename, emp.sal, salgrade.grade <span class="hljs-keyword">from</span> emp <span class="hljs-keyword">left</span> <span class="hljs-keyword">join</span> salgrade <span class="hljs-keyword">on</span> emp.sal <span class="hljs-keyword">between</span> salgrade.losal <span class="hljs-keyword">and</span> salgrade.hisal;<br><span class="hljs-operator">/</span><span class="hljs-operator">/</span>再部门平均（<span class="hljs-keyword">group</span> <span class="hljs-keyword">by</span>）效率不高！！！！！<br><span class="hljs-keyword">select</span> <span class="hljs-built_in">avg</span>(grade), deptno <span class="hljs-keyword">from</span> (<span class="hljs-keyword">select</span> emp.ename, emp.sal, salgrade.grade, emp.deptno <span class="hljs-keyword">from</span> emp <span class="hljs-keyword">left</span> <span class="hljs-keyword">join</span> salgrade <span class="hljs-keyword">on</span> emp.sal <span class="hljs-keyword">between</span> salgrade.losal <span class="hljs-keyword">and</span> salgrade.hisal) t <span class="hljs-keyword">group</span> <span class="hljs-keyword">by</span> deptno;<br><span class="hljs-operator">/</span><span class="hljs-operator">/</span>以上语句执行效率低！！！可以直接在临时表后面<span class="hljs-keyword">group</span> <span class="hljs-keyword">by</span> <br><span class="hljs-keyword">select</span> e.deptno, <span class="hljs-built_in">avg</span>(salgrade.grade) <span class="hljs-keyword">from</span> emp e <span class="hljs-keyword">join</span> salgrade <span class="hljs-keyword">on</span> e.sal <span class="hljs-keyword">between</span> salgrade.losal <span class="hljs-keyword">and</span> salgrade.hisal <span class="hljs-keyword">group</span> <span class="hljs-keyword">by</span> e.deptno;<br><span class="hljs-operator">+</span><span class="hljs-comment">--------+---------------------+</span><br><span class="hljs-operator">|</span> deptno <span class="hljs-operator">|</span> <span class="hljs-built_in">avg</span>(salgrade.grade) <span class="hljs-operator">|</span><br><span class="hljs-operator">+</span><span class="hljs-comment">--------+---------------------+</span><br><span class="hljs-operator">|</span>     <span class="hljs-number">10</span> <span class="hljs-operator">|</span>              <span class="hljs-number">3.6667</span> <span class="hljs-operator">|</span><br><span class="hljs-operator">|</span>     <span class="hljs-number">20</span> <span class="hljs-operator">|</span>              <span class="hljs-number">2.8000</span> <span class="hljs-operator">|</span><br><span class="hljs-operator">|</span>     <span class="hljs-number">30</span> <span class="hljs-operator">|</span>              <span class="hljs-number">2.5000</span> <span class="hljs-operator">|</span><br><span class="hljs-operator">+</span><span class="hljs-comment">--------+---------------------+</span><br><span class="hljs-number">3</span> <span class="hljs-keyword">rows</span> <span class="hljs-keyword">in</span> <span class="hljs-keyword">set</span> (<span class="hljs-number">0.00</span> sec)<br></code></pre></td></tr></table></figure><h2 id="3-select后面子查询（显示，语句执行过程倒数第二）"><a href="#3-select后面子查询（显示，语句执行过程倒数第二）" class="headerlink" title="3.select后面子查询（显示，语句执行过程倒数第二）"></a>3.select后面子查询（显示，语句执行过程倒数第二）</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-operator">/</span><span class="hljs-operator">/</span>找出每个员工所在的部门名称，要求显示员工名和部门名<br><span class="hljs-operator">/</span><span class="hljs-operator">/</span>不用子查询的写法<br><span class="hljs-keyword">select</span> e.ename, d.dname <span class="hljs-keyword">from</span> emp e <span class="hljs-keyword">join</span> dept d <span class="hljs-keyword">on</span> e.deptno<span class="hljs-operator">=</span>d.deptno;<br><span class="hljs-operator">/</span><span class="hljs-operator">/</span>使用子查询的写法，<br><span class="hljs-keyword">select</span> e.ename, (<span class="hljs-keyword">select</span> d.dname <span class="hljs-keyword">from</span> dept d <span class="hljs-keyword">where</span> e.deptno<span class="hljs-operator">=</span>d.deptno) dname <span class="hljs-keyword">from</span> emp e;<br></code></pre></td></tr></table></figure><h1 id="六、limit"><a href="#六、limit" class="headerlink" title="六、limit"></a>六、limit</h1><h2 id="1-limit是mysql特有的，oracle中是rownum"><a href="#1-limit是mysql特有的，oracle中是rownum" class="headerlink" title="1.limit是mysql特有的，oracle中是rownum"></a>1.limit是mysql特有的，oracle中是rownum</h2><h2 id="2-语法机制"><a href="#2-语法机制" class="headerlink" title="2.语法机制"></a>2.语法机制</h2><p>limit startIndex, length</p><p>startIndex表示起始位置，从0开始，</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-operator">/</span><span class="hljs-operator">/</span>取出工资前五名的员工<br><span class="hljs-keyword">select</span> ename,sal <span class="hljs-keyword">from</span> emp <span class="hljs-keyword">order</span> <span class="hljs-keyword">by</span> sal <span class="hljs-keyword">desc</span> limit <span class="hljs-number">0</span>,<span class="hljs-number">5</span>;<br><span class="hljs-operator">/</span><span class="hljs-operator">/</span>如果从<span class="hljs-number">0</span>开始，那么<span class="hljs-number">0</span>可以省略<br><span class="hljs-keyword">select</span> ename,sal <span class="hljs-keyword">from</span> emp <span class="hljs-keyword">order</span> <span class="hljs-keyword">by</span> sal <span class="hljs-keyword">desc</span> limit <span class="hljs-number">5</span>;<br></code></pre></td></tr></table></figure><h2 id="3-通用的标准分页sql语句"><a href="#3-通用的标准分页sql语句" class="headerlink" title="3.通用的标准分页sql语句"></a>3.通用的标准分页sql语句</h2><p>每页显示3条记录：</p><p>第1页：0,3</p><p>第2页：3,3</p><p>第3页：6,3</p><p>第4页：9,3</p><p>每页显示pageSize条记录：</p><p>第pageNo页：(pageNo-1)*pageSize, pageSize</p><h1 id="七、表"><a href="#七、表" class="headerlink" title="七、表"></a>七、表</h1><h2 id="1-建表语法格式"><a href="#1-建表语法格式" class="headerlink" title="1.建表语法格式"></a>1.建表语法格式</h2><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs lua"><span class="hljs-built_in">create</span> <span class="hljs-built_in">table</span> 表名(<br>字段名<span class="hljs-number">1</span> 数据类型,<br>字段名<span class="hljs-number">2</span> 数据类型,<br>字段名<span class="hljs-number">3</span> 数据类型,<br>...<br>);<br></code></pre></td></tr></table></figure><table><thead><tr><th>类型</th><th>描述</th></tr></thead><tbody><tr><td>Char(长度)</td><td>定长字符串，存储空间大小固定，适合作为主键或外键(String)</td></tr><tr><td>Varchar(长度)</td><td>变长字符串，存储空间等于实际数据空间 ，最大255(StringBuffer&#x2F;StringBuilder)</td></tr><tr><td>double(有效数字位数，小数位)</td><td>数值型</td></tr><tr><td>Float(有效数字位数，小数位)</td><td>数值型</td></tr><tr><td>Int( 长度)</td><td>整型</td></tr><tr><td>bigint(长度)</td><td>长整型  （java中的long）</td></tr><tr><td>Date</td><td>日期型 年月日（也是个字符串）</td></tr><tr><td>DateTime</td><td>日期型 年月日 时分秒 毫秒（也是个字符串）</td></tr><tr><td>time</td><td>日期型 时分秒</td></tr><tr><td>BLOB</td><td>Binary Large OBject（二进制大对象）  储存流媒体信息</td></tr><tr><td>CLOB</td><td>Character Large OBject（字符大对象）  储存较大文本</td></tr><tr><td>其它…………………</td><td></td></tr></tbody></table><h2 id="2-插入语句"><a href="#2-插入语句" class="headerlink" title="2.插入语句"></a>2.插入语句</h2><p>插入数据后，表格里一定&#x3D;&#x3D;多一条数据&#x3D;&#x3D;</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">insert</span> into 表名(字段名<span class="hljs-number">1</span>,字段名<span class="hljs-number">2</span>,字段名<span class="hljs-number">3</span>...) values (值<span class="hljs-number">1</span>,值<span class="hljs-number">2</span>,值<span class="hljs-number">3</span>...);<br></code></pre></td></tr></table></figure><p>注意：</p><p>1.有字段名X和值X，两个的类型和位置要对应，并且可以只插某几个字段，其他字段不插，用默认值填充</p><p>2.字段名省略的，如下，…里的内容需要和表格里字段顺序和数量匹配</p><figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs n1ql"><span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> t_student <span class="hljs-keyword">values</span>(...);<br></code></pre></td></tr></table></figure><h2 id="3-表的复制"><a href="#3-表的复制" class="headerlink" title="3.表的复制"></a>3.表的复制</h2><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">//将查询结果当做表创建出来<br><span class="hljs-keyword">create</span> <span class="hljs-keyword">table</span> 表名 <span class="hljs-keyword">as</span> <span class="hljs-keyword">select</span>语句;<br>eg. <br><span class="hljs-keyword">create</span> <span class="hljs-keyword">table</span> t_student1 <span class="hljs-keyword">as</span> <span class="hljs-keyword">select</span> * <span class="hljs-keyword">from</span> t_student;<br>//将查询结果插入到一张表当中<br><span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> t_student1 <span class="hljs-keyword">select</span> * <span class="hljs-keyword">from</span> t_student;<br></code></pre></td></tr></table></figure><h2 id="4-更新"><a href="#4-更新" class="headerlink" title="4.更新"></a>4.更新</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">update</span> 表名 <span class="hljs-keyword">set</span> 字段名<span class="hljs-operator">=</span>值<span class="hljs-number">1</span>,字段名<span class="hljs-number">2</span><span class="hljs-operator">=</span>值<span class="hljs-number">2.</span>.. <span class="hljs-keyword">where</span> 条件;<br></code></pre></td></tr></table></figure><p>注意：没有条件整张表全部更新</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs routeros">update dept1 <span class="hljs-built_in">set</span> <span class="hljs-attribute">LOC</span>=<span class="hljs-string">&#x27;SHANGHAI&#x27;</span>, <span class="hljs-attribute">DNAME</span>=<span class="hljs-string">&#x27;RENSHIB&#x27;</span> where <span class="hljs-attribute">deptno</span>=10;<br></code></pre></td></tr></table></figure><h2 id="5-删除"><a href="#5-删除" class="headerlink" title="5.删除"></a>5.删除</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">delete</span> <span class="hljs-keyword">from</span> 表名 <span class="hljs-keyword">where</span> 条件;<br>eg.<br><span class="hljs-keyword">delete</span> <span class="hljs-keyword">from</span> dept1 <span class="hljs-keyword">where</span> deptno<span class="hljs-operator">=</span><span class="hljs-number">10</span>;<br></code></pre></td></tr></table></figure><p>删除大表中的数据不能恢复</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">truncate</span> <span class="hljs-keyword">table</span> 表名;<span class="hljs-operator">/</span><span class="hljs-operator">/</span>表被截断，不可回滚，永久丢失<br></code></pre></td></tr></table></figure><h1 id="八、约束"><a href="#八、约束" class="headerlink" title="八、约束"></a>八、约束</h1><p>a)    非空约束，not null</p><p>b)    唯一约束，unique </p><p>c)    主键约束，primary key </p><p>d)    外键约束，foreign key</p><p>e)     检查约束，check(在Oracle中使用，mysql中不使用)</p><h2 id="1-非空约束-not-null"><a href="#1-非空约束-not-null" class="headerlink" title="1.非空约束 not null"></a>1.非空约束 not null</h2><p>只有列级定义方式【只能加在字段后面】</p><h2 id="2-唯一性约束unique"><a href="#2-唯一性约束unique" class="headerlink" title="2.唯一性约束unique"></a>2.唯一性约束unique</h2><p>字段具有唯一性，不能重复，但是可以为NULL（换言之，&#x3D;&#x3D;NULL！&#x3D;NULL&#x3D;&#x3D;）</p><p>有【列级约束】和【表级约束】两种级别</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-operator">/</span><span class="hljs-operator">/</span>案例，给某一个字段添加<span class="hljs-keyword">unique</span><br><span class="hljs-keyword">drop</span> <span class="hljs-keyword">table</span> t_student;<br><span class="hljs-keyword">create</span> <span class="hljs-keyword">table</span> t_student(<br>id <span class="hljs-type">int</span>,<br>    name <span class="hljs-type">varchar</span>(<span class="hljs-number">255</span>) <span class="hljs-keyword">unique</span>【列级约束】<br>);<br><span class="hljs-operator">+</span><span class="hljs-comment">------+----------+</span><br><span class="hljs-operator">|</span> id   <span class="hljs-operator">|</span> name     <span class="hljs-operator">|</span><br><span class="hljs-operator">+</span><span class="hljs-comment">------+----------+</span><br><span class="hljs-operator">|</span> <span class="hljs-number">1001</span> <span class="hljs-operator">|</span> zhangsan <span class="hljs-operator">|</span><br><span class="hljs-operator">|</span>    <span class="hljs-number">2</span> <span class="hljs-operator">|</span> <span class="hljs-keyword">NULL</span>     <span class="hljs-operator">|</span><br><span class="hljs-operator">|</span>    <span class="hljs-number">3</span> <span class="hljs-operator">|</span> <span class="hljs-keyword">NULL</span>     <span class="hljs-operator">|</span><br><span class="hljs-operator">|</span>    <span class="hljs-number">4</span> <span class="hljs-operator">|</span> <span class="hljs-keyword">NULL</span>     <span class="hljs-operator">|</span><br><span class="hljs-operator">+</span><span class="hljs-comment">------+----------+</span><br><br><span class="hljs-operator">/</span><span class="hljs-operator">/</span>案例，给某两个字段联合起来具有唯一性<br><span class="hljs-keyword">drop</span> <span class="hljs-keyword">table</span> t_student;<br><span class="hljs-keyword">create</span> <span class="hljs-keyword">table</span> t_student(<br>id <span class="hljs-type">int</span>,<br>    name <span class="hljs-type">varchar</span>(<span class="hljs-number">255</span>),<br>    <span class="hljs-keyword">unique</span>(id,name)【表级约束】<br>); <br><span class="hljs-operator">+</span><span class="hljs-comment">------+----------+</span><br><span class="hljs-operator">|</span> id   <span class="hljs-operator">|</span> name     <span class="hljs-operator">|</span><br><span class="hljs-operator">+</span><span class="hljs-comment">------+----------+</span><br><span class="hljs-operator">|</span> <span class="hljs-number">1001</span> <span class="hljs-operator">|</span> zhangsan <span class="hljs-operator">|</span><br><span class="hljs-operator">|</span> <span class="hljs-number">1002</span> <span class="hljs-operator">|</span> zhangsan <span class="hljs-operator">|</span><br><span class="hljs-operator">|</span> <span class="hljs-number">1003</span> <span class="hljs-operator">|</span> zhangsan <span class="hljs-operator">|</span><br><span class="hljs-operator">+</span><span class="hljs-comment">------+----------+</span><br></code></pre></td></tr></table></figure><h2 id="3-主键约束primary-key"><a href="#3-主键约束primary-key" class="headerlink" title="3.主键约束primary key"></a>3.主键约束primary key</h2><p>主键约束：primary key</p><p>主键字段：primary key修饰的字段名称</p><p>主键值：主键字段中的每一个值</p><p>&#x3D;&#x3D;某一行记录的唯一标识，不能为空，也不能重复&#x3D;&#x3D;，一个表只能有一个主键，最好不要和业务有关的字段挂钩，&#x3D;&#x3D;自然主键&#x3D;&#x3D;</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-operator">/</span><span class="hljs-operator">/</span>案例<br><span class="hljs-keyword">drop</span> <span class="hljs-keyword">table</span> t_student;<br><span class="hljs-keyword">create</span> <span class="hljs-keyword">table</span> t_student(<br>id <span class="hljs-type">int</span> <span class="hljs-keyword">primary</span> key,<br>    name <span class="hljs-type">varchar</span>(<span class="hljs-number">255</span>)<br>); <br></code></pre></td></tr></table></figure><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">//主键自增 auto_increment,插入的时候就不需要写主键值了<br><span class="hljs-keyword">drop</span> <span class="hljs-keyword">table</span> t_student;<br><span class="hljs-keyword">create</span> <span class="hljs-keyword">table</span> t_student(<br>id <span class="hljs-type">int</span> <span class="hljs-keyword">primary key</span> auto_increment,<br>    <span class="hljs-type">name</span> <span class="hljs-type">varchar</span>(<span class="hljs-number">255</span>)<br>); <br><br><span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> t_student(<span class="hljs-type">name</span>) <span class="hljs-keyword">values</span> (<span class="hljs-string">&#x27;zhangsan&#x27;</span>);<br><span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> t_student(<span class="hljs-type">name</span>) <span class="hljs-keyword">values</span> (<span class="hljs-string">&#x27;lisio&#x27;</span>);<br><span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> t_student(<span class="hljs-type">name</span>) <span class="hljs-keyword">values</span> (<span class="hljs-string">&#x27;wangwu&#x27;</span>);<br><br></code></pre></td></tr></table></figure><h2 id="4-外键约束-foreign-key"><a href="#4-外键约束-foreign-key" class="headerlink" title="4.外键约束 foreign key"></a>4.外键约束 foreign key</h2><p>子表中的某个字段引用了父表中的某个字段，那么子表中的字段的值一定是在父表引用字段值的范围内，否则会报错1452</p><p>外键值（外键字段中的值）可以为NULL，被引用的字段需要具有唯一性（可以不是主键）</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs sql">父表t_class，班级编号和名称<br><span class="hljs-operator">+</span><span class="hljs-comment">-----+------------+</span><br><span class="hljs-operator">|</span> cno <span class="hljs-operator">|</span> cname      <span class="hljs-operator">|</span><br><span class="hljs-operator">+</span><span class="hljs-comment">-----+------------+</span><br><span class="hljs-operator">|</span> <span class="hljs-number">101</span> <span class="hljs-operator">|</span> gaosan1ban <span class="hljs-operator">|</span><br><span class="hljs-operator">|</span> <span class="hljs-number">102</span> <span class="hljs-operator">|</span> gaosan2ban <span class="hljs-operator">|</span><br><span class="hljs-operator">+</span><span class="hljs-comment">-----+------------+</span><br>子表t_student，个人信息<br><span class="hljs-operator">+</span><span class="hljs-comment">-----+----------+---------+</span><br><span class="hljs-operator">|</span> sno <span class="hljs-operator">|</span> sname    <span class="hljs-operator">|</span> classno <span class="hljs-operator">|</span><br><span class="hljs-operator">+</span><span class="hljs-comment">-----+----------+---------+</span><br><span class="hljs-operator">|</span>   <span class="hljs-number">1</span> <span class="hljs-operator">|</span> zhangsan <span class="hljs-operator">|</span>     <span class="hljs-number">101</span> <span class="hljs-operator">|</span><br><span class="hljs-operator">|</span>   <span class="hljs-number">2</span> <span class="hljs-operator">|</span> zhangsan <span class="hljs-operator">|</span>     <span class="hljs-number">102</span> <span class="hljs-operator">|</span><br><span class="hljs-operator">|</span>   <span class="hljs-number">4</span> <span class="hljs-operator">|</span> zhangsan <span class="hljs-operator">|</span>     <span class="hljs-number">102</span> <span class="hljs-operator">|</span><br><span class="hljs-operator">+</span><span class="hljs-comment">-----+----------+---------+</span><br>其中t_student中的classno引用自t_class中的cno，那么classno不能出现<span class="hljs-number">101</span>和<span class="hljs-number">102</span>以外的值，除非t_class有其他的字段<br></code></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">foreign</span> key(classno) reference t_class(cno)<br></code></pre></td></tr></table></figure> <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-operator">/</span><span class="hljs-operator">/</span>先删子表，再删父表<br><span class="hljs-keyword">drop</span> <span class="hljs-keyword">table</span> if <span class="hljs-keyword">exists</span> t_student;<br><span class="hljs-keyword">drop</span> <span class="hljs-keyword">table</span> if <span class="hljs-keyword">exists</span> t_class;<br><span class="hljs-operator">/</span><span class="hljs-operator">/</span>先创父表，再创子表<br><span class="hljs-keyword">create</span> <span class="hljs-keyword">table</span> t_class(<br>cno <span class="hljs-type">int</span> <span class="hljs-keyword">primary</span> key,<br>cname <span class="hljs-type">varchar</span>(<span class="hljs-number">255</span>)<br>);<br><br><span class="hljs-keyword">create</span> <span class="hljs-keyword">table</span> t_student(<br>sno <span class="hljs-type">int</span> <span class="hljs-keyword">primary</span> key,<br>sname <span class="hljs-type">varchar</span>(<span class="hljs-number">255</span>),<br>classno <span class="hljs-type">int</span>,<br><span class="hljs-keyword">foreign</span> key(classno) <span class="hljs-keyword">references</span> t_class(cno)<br>);<br><span class="hljs-operator">/</span><span class="hljs-operator">/</span>先加父表，再加子表<br><span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> t_class <span class="hljs-keyword">values</span> (<span class="hljs-number">101</span>,<span class="hljs-string">&#x27;gaosan1ban&#x27;</span>);<br><span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> t_class <span class="hljs-keyword">values</span> (<span class="hljs-number">102</span>,<span class="hljs-string">&#x27;gaosan2ban&#x27;</span>);<br><span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> t_student <span class="hljs-keyword">values</span> (<span class="hljs-number">1</span>,<span class="hljs-string">&#x27;zhangsan&#x27;</span>,<span class="hljs-number">101</span>);<br><span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> t_student <span class="hljs-keyword">values</span> (<span class="hljs-number">2</span>,<span class="hljs-string">&#x27;zhangsan&#x27;</span>,<span class="hljs-number">102</span>);<br><span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> t_student <span class="hljs-keyword">values</span> (<span class="hljs-number">3</span>,<span class="hljs-string">&#x27;zhangsan&#x27;</span>,<span class="hljs-number">103</span>);<br><span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> t_student <span class="hljs-keyword">values</span> (<span class="hljs-number">4</span>,<span class="hljs-string">&#x27;zhangsan&#x27;</span>,<span class="hljs-number">102</span>);<br></code></pre></td></tr></table></figure><h1 id="九、存储引擎"><a href="#九、存储引擎" class="headerlink" title="九、存储引擎"></a>九、存储引擎</h1><h2 id="1-MyISAM"><a href="#1-MyISAM" class="headerlink" title="1.MyISAM"></a>1.MyISAM</h2><p>采用三个文件组织一张表</p><p>xxx.frm（存储格式的文件）</p><p>xxx.MYD（存储表中数据的文件）</p><p>xxx.MYI（存储表中索引的文件）</p><p>优点：可被压缩，节省储存空间，并且可以转换为只读表，提高检索效率</p><p>缺点：不支持事务</p><h2 id="2-InnoDB"><a href="#2-InnoDB" class="headerlink" title="2.InnoDB"></a>2.InnoDB</h2><p>优点：支持事务，最安全（mysql默认存储引擎）</p><p>xxx.frm（存储格式的文件）</p><p>tablespace（表空间）存储数据的地方，逻辑概念</p><p>在MySQL数据库崩溃的时候提供自动恢复机制</p><p>支持级联删除和级联更新</p><h2 id="3-MEMORY"><a href="#3-MEMORY" class="headerlink" title="3.MEMORY"></a>3.MEMORY</h2><h1 id="十、索引"><a href="#十、索引" class="headerlink" title="十、索引"></a>十、索引</h1><h2 id="1-什么时候给字段添加索引"><a href="#1-什么时候给字段添加索引" class="headerlink" title="1.什么时候给字段添加索引"></a>1.什么时候给字段添加索引</h2><p>1.数据量庞大</p><p>2.该字段有很少的DML(Data Manipulate Language)操作（因为字段进行修改操作，索引也需要维护）</p><p>3.该字段经常出现在where语句中（经常根据哪个字段进行查询）</p><p>注意：主键和具有unique约束的字段会自动添加索引</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-operator">/</span><span class="hljs-operator">/</span>添加索引对象：<br><span class="hljs-keyword">create</span> index 索引名称 <span class="hljs-keyword">on</span> 表名(字段名);<br><span class="hljs-operator">/</span><span class="hljs-operator">/</span>删除索引对象：<br><span class="hljs-keyword">drop</span> index 索引名称 <span class="hljs-keyword">on</span> 表名;<br></code></pre></td></tr></table></figure><h2 id="2-实现原理"><a href="#2-实现原理" class="headerlink" title="2.实现原理"></a>2.实现原理</h2><img src="/2022/02/09/MySQL%E5%88%9D%E7%BA%A7%E7%AC%94%E8%AE%B0/LanguageLearning\MySQL\MySQL初级笔记.assets\image-20210928182126858.png" alt="image-20210928182126858 " style="zoom:90%;"><p>通过B + Tree缩小扫描范围，底层索引进行排序、分区</p><p>索引会携带数据在表中的“物理地址”，最终通过索引检索到数据后，获取到关联的物理地址，通过物理地址定位表中的数据（不在表中进行查找，直接物理地址定位）</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> ename <span class="hljs-keyword">from</span> emp <span class="hljs-keyword">where</span> ename <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;SMITH&#x27;</span>;<br>变成<br><span class="hljs-keyword">select</span> ename <span class="hljs-keyword">from</span> emp <span class="hljs-keyword">where</span> 物理地址 <span class="hljs-operator">=</span> <span class="hljs-number">0x3</span>;<br></code></pre></td></tr></table></figure><img src="/2022/02/09/MySQL%E5%88%9D%E7%BA%A7%E7%AC%94%E8%AE%B0/LanguageLearning\MySQL\MySQL初级笔记.assets\image-20210928185900804.png" alt="image-20210928185900804 " style="zoom:90%;"><p>浅蓝色为磁盘块，当中有深蓝色的数据块和指针块</p><p>叶子节点为数据库中的数据，非叶子节点不是真实数据，只储存指引搜索方向的数据项，例如17、35不是真实存在数据表中</p><p>要查找数据项29，那么把磁盘块1加载进内存，发生一次磁盘IO，29在17和35之间，那么锁定P2指针，通过磁盘块1的P2指针的磁盘地址，把磁盘块3加载到内存，发生第二次磁盘IO，29在26和30之间，锁定磁盘3的P2指针，通过磁盘地址将磁盘块8加载进内存，发生第三次磁盘IO，用二分法查找到29，结束查询。</p><h3 id="B-树性质"><a href="#B-树性质" class="headerlink" title="B+树性质"></a>B+树性质</h3><p>1.索引字段尽量小</p><p>IO的次数取决于b+树的高度。</p><p>假设数据表的数据为N，每块磁盘数据项的数量为m，b+树的高度为h，h&#x3D;㏒(m+1)N，m&#x3D;磁盘块的大小&#x2F;数据项的大小，其中磁盘块的大小是固定的（一个数据页的大小）。那么如果数据项（索引字段）越小，则m越大，则h越小，即磁盘IO的次数越小。</p><p>2.索引最左匹配特性</p><p>当b+树的数据项是复合的数据结构，比如(name,age,sex)的时候，b+数是按照从左到右的顺序来建立搜索树的，比如当(张三,20,F)这样的数据来检索的时候，b+树会优先比较name来确定下一步的所搜方向，如果name相同再依次比较age和sex，最后得到检索的数据；但当(20,F)这样的没有name的数据来的时候，b+树就不知道下一步该查哪个节点，因为建立搜索树的时候name就是第一个比较因子，必须要先根据name来搜索才能知道下一步去哪里查询。比如当(张三,F)这样的数据来检索时，b+树可以用name来指定搜索方向，但下一个字段age的缺失，所以只能把名字等于张三的数据都找到，然后再匹配性别是F的数据了， 这个是非常重要的性质，即索引的最左匹配特性。</p><h2 id="3-索引的分类"><a href="#3-索引的分类" class="headerlink" title="3.索引的分类"></a>3.索引的分类</h2><p>单一索引：给单个字段添加索引</p><p>复合索引：给多个字段联合起来添加一个索引</p><p>主键索引：主键上会自动添加索引</p><p>唯一索引：有unique约束的字段上会自动添加索引</p><h2 id="4-索引的失效"><a href="#4-索引的失效" class="headerlink" title="4.索引的失效"></a>4.索引的失效</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> ename <span class="hljs-keyword">from</span> emp <span class="hljs-keyword">where</span> ename <span class="hljs-keyword">like</span> <span class="hljs-string">&#x27;%A%&#x27;</span>;<br></code></pre></td></tr></table></figure><h1 id="十一、视图"><a href="#十一、视图" class="headerlink" title="十一、视图"></a>十一、视图</h1><p>可以通过操作视图来操作表，操作视图和操作表的方法是一样的，update 和delete</p><p>视图可以隐藏表的实现细节</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-operator">/</span><span class="hljs-operator">/</span>创建视图<br><span class="hljs-keyword">create</span> <span class="hljs-keyword">view</span> 视图名 <span class="hljs-keyword">as</span> <span class="hljs-keyword">select</span> ...(字段) <span class="hljs-keyword">from</span> 表名;<br><span class="hljs-operator">/</span><span class="hljs-operator">/</span>删除视图<br><span class="hljs-keyword">drop</span> <span class="hljs-keyword">view</span> 视图名;<br></code></pre></td></tr></table></figure><p>十二、其他</p><h2 id="1-mysql备份"><a href="#1-mysql备份" class="headerlink" title="1.mysql备份"></a>1.mysql备份</h2><p>DBA命令（dos命令行的命令）</p><p>​    1.导出整个库</p><p>​        mysqldump 库名&gt;地址 -uroot -p333</p><p>​    2.导出指定数据库中的指定表</p><p>​        mysqldump 库名 表名&gt;地址 -uroot -p333 </p><h2 id="2-数据库设计三范式"><a href="#2-数据库设计三范式" class="headerlink" title="2.数据库设计三范式"></a>2.数据库设计三范式</h2><p>三范式的目的是让表的设计没有冗余。</p><p>第一范式：任何一张表都应该有主键，并且每一个字段原子性不可再分；</p><p>第二范式：建立在第一范式的基础上，所有非主键字段完全依赖主键，不能产生【部分依赖】（即多个主键的情况）；</p><p>​            【多对多？三张表，关系表两个外键】</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-string">学生编号(PK)</span><span class="hljs-string">教师编号(PK)</span><span class="hljs-string">学生姓名</span>  <span class="hljs-string">教师姓名</span><br><span class="hljs-number">1001         </span><span class="hljs-number">001</span>       <span class="hljs-string">张三</span><span class="hljs-string">王老师</span><br><span class="hljs-number">1002         </span><span class="hljs-number">002</span>       <span class="hljs-string">李四</span><span class="hljs-string">赵老师</span><br><span class="hljs-number">1003         </span><span class="hljs-number">001</span>   <span class="hljs-string">王五</span><span class="hljs-string">王老师</span><br><span class="hljs-number">1001         </span><span class="hljs-number">002</span>   <span class="hljs-string">张三</span><span class="hljs-string">赵老师</span><br></code></pre></td></tr></table></figure><p>第三范式：建立在第二范式的基础上，所有非主键字段直接依赖主键，不能产生【传递依赖】</p><p>​            【一对多？两张表，多的表加外键】</p><p>  &#x3D;&#x3D;在实际的开发过程中，以满足客户的需求为主，有的时候会拿冗余换速度。&#x3D;&#x3D;</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>JVM详解</title>
    <link href="/2022/02/09/JVM/"/>
    <url>/2022/02/09/JVM/</url>
    
    <content type="html"><![CDATA[<h1 id="一、简介"><a href="#一、简介" class="headerlink" title="一、简介"></a>一、简介</h1><ol><li><strong>定义</strong></li></ol><p> Java Virtual Machine  Java二进制字节码的运行环境，是一套规范</p><ol start="2"><li><strong>好处</strong></li></ol><ul><li>一次编写，到处运行</li><li>自动内存管理，垃圾回收功能</li><li>数组下标越界的越界检查</li><li>多态（我去，这个底层是怎么实现的？？？  0119回答：见类加载机制多态的底层字节码指令，在类加载的时候就已经加载了具体的对象，而不是父类）</li></ul><ol start="3"><li><strong>常见的 JVM</strong></li></ol><p><img src="/2022/02/09/JVM/image-20211114165203597.png" alt="image-20211114165203597"></p><ol start="4"><li><strong>学习路线</strong></li></ol><img src="/2022/02/09/JVM/image-20211114165654954.png" alt="image-20211114165654954 " style="zoom:67%;"><h1 id="二、JVM运行时内存结构-Runtime-data-area"><a href="#二、JVM运行时内存结构-Runtime-data-area" class="headerlink" title="二、JVM运行时内存结构(Runtime data area)"></a>二、JVM运行时内存结构(Runtime data area)</h1><img src="/2022/02/09/JVM/2123988-20210114183030899-547261528.png" alt="img " style="zoom:50%;"><p>二进制字节码文件保存【类基本信息（类的版本信息、字段、方法以及接口等描述符信息）、常量池表（Constant Pool Table）、类方法定义】，在bin目录结构中</p><p>下图是进行了反编译字节码文件javap -V XXX.class</p><img src="/2022/02/09/JVM/image-20211120153945300.png" alt="image-20211120153945300 " style="zoom:67%;"><img src="/2022/02/09/JVM/image-20211120153838835.png" alt="image-20211120153838835" style="zoom:67%;"><h2 id="1-程序计数器"><a href="#1-程序计数器" class="headerlink" title="1. 程序计数器"></a>1. 程序计数器</h2><p>Program Counter Register  程序计数器（寄存器）</p><p><strong>记住下一条jvm指令的执行地址</strong></p><p><strong>特点</strong>：</p><ul><li>线程私有【即每一条线程都有一个程序计数器，随着线程的创建而创建，销毁而销毁】</li><li>唯一一个不会存在内存溢出的区</li><li>是一块比较小的内存空间</li></ul><h2 id="2-虚拟机栈"><a href="#2-虚拟机栈" class="headerlink" title="2. 虚拟机栈"></a>2. 虚拟机栈</h2><h3 id="2-1-定义"><a href="#2-1-定义" class="headerlink" title="2.1 定义"></a>2.1 定义</h3><img src="/2022/02/09/JVM/image-20211115200831828.png" alt="image-20211115200831828 " style="zoom:50%;"><p>虚拟机栈(Stack)——<strong>线程运行需要的内存空间</strong>，一个栈由多个栈帧组成</p><p>栈帧(Frame)——每个方法运行时需要的内存【例如方法参数、局部变量、方法返回地址】</p><p>&#x3D;&#x3D;每个线程只能有一个活动栈帧&#x3D;&#x3D;，对应着当前正在执行的那个方法 </p><ul><li>问题：<ul><li>栈内存分配越大越好吗？【No!  栈内存越大，即线程运行的内存空间越大，所能运行的线程数变少】</li><li>方法内的局部变量是否是线程安全？<ul><li>如果方法内局部变量没有逃离方法的作用范围，那么就是线程安全的</li><li>如果局部变量引用了对象且<strong>逃离方法的作用范围</strong>（实参、返回值等），则有线程安全的风险</li></ul></li></ul></li></ul><h3 id="2-2-栈内存溢出"><a href="#2-2-栈内存溢出" class="headerlink" title="2.2 栈内存溢出"></a>2.2 栈内存溢出</h3><p> 异常：&#x3D;&#x3D;StackOverflowError&#x3D;&#x3D;</p><h3 id="2-3-线程运行诊断"><a href="#2-3-线程运行诊断" class="headerlink" title="2.3 线程运行诊断"></a>2.3 线程运行诊断</h3><p>&#x3D;&#x3D;【这里有一个线程和进程的区别】&#x3D;&#x3D;</p><p>Linux：</p><figure class="highlight shell"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="language-bash">找到cpu占用高的进程</span><br>top<br><span class="hljs-meta">#</span><span class="language-bash">找到相应的线程（用grep过滤想要的进程<span class="hljs-built_in">id</span>）</span><br>ps H -eo pid,tid,%cpu | grep 进程id<br><span class="hljs-meta">#</span><span class="language-bash">根据进程<span class="hljs-built_in">id</span>找到有问题的线程，并进一步locate到代码行数【这里对应的线程<span class="hljs-built_in">id</span>需要做十六进制转换】</span><br>jstack 进程id    <br></code></pre></td></tr></table></figure><h2 id="3-本地方法栈"><a href="#3-本地方法栈" class="headerlink" title="3. 本地方法栈"></a>3. 本地方法栈</h2><p>只讲了哪些方法用了native【看一下native】</p><h2 id="4-堆"><a href="#4-堆" class="headerlink" title="4. 堆"></a>4. 堆</h2><h3 id="４-1-定义"><a href="#４-1-定义" class="headerlink" title="４.1 定义"></a>４.1 定义</h3><p>Heap，存放：</p><ol><li>存储的全部是对象，每个对象都包含一个与之对应的class信息。(class的目的是得到操作指令)</li><li>jvm只有一个堆区(heap)被所有线程共享，堆中不存放基本类型和对象引用，只存放对象本身</li></ol><p>特点：</p><ul><li><strong>线程共享</strong>的，堆中的对象都需要考虑线程安全的问题</li><li>有<strong>垃圾回收机制</strong></li></ul><h3 id="4-2-堆内存溢出及诊断"><a href="#4-2-堆内存溢出及诊断" class="headerlink" title="4.2 堆内存溢出及诊断"></a>4.2 堆内存溢出及诊断</h3><p><strong>java.lang.OutOfMemoryError: Java heap space</strong></p><p>可以将内存设置得小一些来看是否有堆内存溢出的可能</p><figure class="highlight diff"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs diff"><span class="hljs-deletion">-Xmx10m</span><br></code></pre></td></tr></table></figure><p><strong>堆内存诊断</strong></p><p>Linux：</p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm"><span class="hljs-keyword">jps工具：查看当前系统中有哪些java进程</span><br><span class="hljs-keyword"></span><span class="hljs-keyword">jmap工具：查看堆内存占用情况 </span>  <br><span class="hljs-keyword">jmap </span>-heap 进程id<br><span class="hljs-keyword">jconsole工具：图形界面的，多功能监测工具，可以连续监测 </span>  <br><span class="hljs-keyword">jconsole </span><br></code></pre></td></tr></table></figure><h2 id="5-方法区"><a href="#5-方法区" class="headerlink" title="5. 方法区"></a>5. 方法区</h2><h3 id="5-1-定义"><a href="#5-1-定义" class="headerlink" title="5.1 定义"></a>5.1 定义</h3><p>所有<strong>JVM线程共享</strong>的区域，它用于存储已被虚拟机加载的<strong>类型信息</strong>、<strong>常量</strong>、<strong>静态变量</strong>、<strong>即时编译器编译后的代码缓存</strong>等。</p><ul><li>类的结构相关的信息——完整类名、继承关系、类的修饰符【这些都是加载class文件得到的】</li><li>方法相关——声明的顺序、修饰符、返回值类型、名字、参数列表（有序保存）、异常表（方法抛出的异常）、方法字节码（native、abstract方法除外）、操作数栈和局部变量表大小【这些都是加载class文件得到的】</li><li>全局变量</li><li>全局常量【static final修饰的变量】 ，在编译的时候就会被分配了</li><li>static 变量——【1.7以前跟着instanceKlass存在方法区中，1.7及以后跟着类对象存在堆中】</li><li>&#x3D;&#x3D;运行时常量池&#x3D;&#x3D;【1.7版本以前包含StringTable，1.7及以后，StringTable在堆中】——运行时常量池中包含多种不同的常量，包括<strong>编译期就已经明确的数值字面量</strong>，也包括到<strong>运行期解析后才能够获得的方法或者字段引用</strong><ul><li><strong>为什么要调整StringTable的位置</strong>——永久代的回收效率很低，只有full gc时才会触发，而full gc被触发是因为老年代空间不足、永久代空间不足才会触发，导致StringTable的回收效率不高，放到堆里，能及时回收内存。</li></ul></li></ul><p>启动时被创建。</p><p>逻辑上是堆的组成部分，但是不同的JVM实现不一样</p><img src="/2022/02/09/JVM/image-20211120144944118.png" alt="image-20211120144944118 " style="zoom:100%;"><p>元空间默认情况使用系统内存，</p><img src="/2022/02/09/JVM/image-20211120144955570.png" alt="image-20211120144955570 " style="zoom:100%;"><h3 id="5-2-方法区内存溢出"><a href="#5-2-方法区内存溢出" class="headerlink" title="5.2 方法区内存溢出"></a>5.2 方法区内存溢出</h3><ul><li>1.7以前导致永久代内存溢出</li></ul><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-section">java.lang.OutOfMemoryError: PerGen space</span><br><span class="hljs-section">-XX:MaxPermSize=8m</span><br></code></pre></td></tr></table></figure><ul><li>1.7之后导致元空间内存溢出</li></ul><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-section">java.lang.OutOfMemoryError: Metaspace</span><br><span class="hljs-section">-XX:MaxMetaspace=8m</span><br></code></pre></td></tr></table></figure><p>在Spring和Mybatis中会&#x3D;&#x3D;动态加载字节码文件&#x3D;&#x3D;，所以会出现方法区内存溢出的可能。</p><h3 id="5-3-StringTable-x3D-x3D-P34-x3D-x3D"><a href="#5-3-StringTable-x3D-x3D-P34-x3D-x3D" class="headerlink" title="5.3 StringTable  &#x3D;&#x3D;P34&#x3D;&#x3D;"></a>5.3 StringTable  &#x3D;&#x3D;P34&#x3D;&#x3D;</h3><ul><li>常量池：一张表，加载二进制字节码文件（.class文件），表中储存要执行的类名、方法名、参数类型、字面量【例如字符串、布尔值等】等信息</li></ul><img src="/2022/02/09/JVM/image-20211120154544601.png" alt="image-20211120154544601 " style="zoom:67%;"><ul><li><p>运行时常量池：当该类被加载的时候，它的常量池信息就会放入<strong>运行时常量池</strong>，并把里面的符号变成真实地址。</p><p>但此时运行时常量池中的常量”a”只是符号，还没有变成java字符串对象，等待具体执行到某一行代码的时候String s1 &#x3D; “a”，将符号变成字符串对象，并准备好StringTable串池，以”a”字符串对象为key，在StringTable中找是否有相同的key，没有则将”a”字符串对象放入串池。</p></li><li><p><strong>StringTable字符串常量池，串池</strong>，底层HashTable</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">String</span> <span class="hljs-variable">s1</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;a&quot;</span>;<br><span class="hljs-type">String</span> <span class="hljs-variable">s2</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;b&quot;</span>;<br><span class="hljs-type">String</span> <span class="hljs-variable">s3</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;ab&quot;</span>;<br><span class="hljs-type">String</span> <span class="hljs-variable">s4</span> <span class="hljs-operator">=</span> s1 + s2;<span class="hljs-comment">//s1和s2为变量，则可能会发生修改，结果不是确定的，字节码文件中写的是创建StringBuilder等过程</span><br><span class="hljs-type">String</span> <span class="hljs-variable">s5</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;a&quot;</span> + <span class="hljs-string">&quot;b&quot;</span>;<span class="hljs-comment">//javac在编译期间的优化，结果已经在编译期间确定为ab，写进了字节码文件</span><br><span class="hljs-type">String</span> <span class="hljs-variable">s6</span> <span class="hljs-operator">=</span> s4.intern();<span class="hljs-comment">//串池中已有&quot;ab&quot;，则s6和s3相等，和s4不相等</span><br><br>System.out.println(s3 == s4);<span class="hljs-comment">//false</span><br>System.out.println(s3 == s5);<span class="hljs-comment">//true</span><br>System.out.println(s3 == s6);<span class="hljs-comment">//true</span><br><br><span class="hljs-type">String</span> <span class="hljs-variable">x2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(<span class="hljs-string">&quot;c&quot;</span>) + <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(<span class="hljs-string">&quot;d&quot;</span>);<span class="hljs-comment">//串池中放入&quot;c&quot;对象，堆中new String()值为“c”，串池中放入&quot;d&quot;对象，堆中new String()值为“d”，变量字符串拼接new StringBuilder.append(&quot;c&quot;).append(&quot;d&quot;).toString()，相当于new String(&quot;cd&quot;)，也是在堆中，&quot;cd&quot;不会放进串池中</span><br>x2.intern();<span class="hljs-comment">//串池中没有&quot;cd&quot;，放入</span><br><span class="hljs-type">String</span> <span class="hljs-variable">x1</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;cd&quot;</span>;<span class="hljs-comment">//直接映射到串池中已有的&quot;cd&quot;</span><br>System.out.println(x1 == x2);<span class="hljs-comment">//true</span><br></code></pre></td></tr></table></figure><p>s1、s2、s3保存的地址都是指向串池StringTable，且是运行过程执行到了这一行，才将对象放入串池中</p><p>s4是s1+s2，底层是&#x3D;&#x3D;new StringBuilder.append(“a”).append(“b”).toString()&#x3D;&#x3D;，而StringBuilder.toString()方法是new String(value,0 count)，则是创建了一个新的字符串对象，最后得到的是一个对象的引用</p><p>s5底层是直接在串池中查找String ab，和s3的底层过程是完全一样的，且发现串池中已经有了ab，则不再新建ab，直接指向原有的ab</p><p> <strong>5.3.1 特性</strong></p><ul><li>常量池中的字符串仅是符号，第一次用到时才变成对象，并将以该对象为key保存在串池中</li><li>利用串池HashTable的机制，来避免重复创建字符串对象</li><li>字符串**&#x3D;&#x3D;变量&#x3D;&#x3D;**拼接的原理是StringBuilder（jvm 1.8）</li><li>字符串**&#x3D;&#x3D;常量&#x3D;&#x3D;**拼接的原理是编译期优化</li><li>可以使用**intern()**方法，主动将串池中还没有的字符串对象放入串池<ul><li>1.6将这个字符串对象尝试方式串池，如果有则不会放入，如果没有<strong>会把此对象复制一份</strong>（此时原字符串和放入的字符串不一样），放入串池，再把串池中的对象返回。</li><li>1.7以后这个字符串对象尝试放入串池，如果有则不会放入，如果没有则放入串池，再把串池中的对象返回。</li></ul></li></ul><p><strong>5.3.2 位置</strong></p><p>在1.6版本及以前，StringTable存放在永久代PermGen中</p><p>在1.7版本及以后，StringTable存放在堆内存中</p><p>永久代的垃圾回收效率会很慢(在FULL GC时，才会进行垃圾回收，而Stringtable的更新十分频繁，所以不合适在永久代中，放在堆中可实现Minor GC即可回收)</p><p>&#x3D;&#x3D;<strong>5.3.3  StringTable的垃圾回收</strong>&#x3D;&#x3D;</p><p>StringTable会发生垃圾回收【这里具体是怎么进行垃圾回收的呢？】</p><p><strong>5.3.4  StringTable的性能调优</strong></p><p>扩大StringTable的buckets【桶】的个数，hash查找的速度会变快</p><figure class="highlight gams"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs gams">前面VM <span class="hljs-keyword">options</span>指打印StringTable的相关信息，后面VM <span class="hljs-keyword">Options</span>指修改StringTable的桶的个数<br>-XX:+PrintStringStatistics -XX:StringTableSize=<span class="hljs-number">1009</span><br></code></pre></td></tr></table></figure><h2 id="6-直接内存"><a href="#6-直接内存" class="headerlink" title="6. 直接内存"></a>6. 直接内存</h2><h1 id="三、垃圾回收【堆】"><a href="#三、垃圾回收【堆】" class="headerlink" title="三、垃圾回收【堆】"></a>三、垃圾回收【堆】</h1><h2 id="1-如何判断对象可以回收"><a href="#1-如何判断对象可以回收" class="headerlink" title="1.如何判断对象可以回收"></a>1.如何判断对象可以回收</h2><h3 id="1-1-引用计数法"><a href="#1-1-引用计数法" class="headerlink" title="1.1 引用计数法"></a>1.1 <strong>引用计数法</strong></h3><p>如果有变量引用了对象，则计数器+1，当该变量引用了其他对象，则计数器-1，计数器为0，该对象可以被回收。但是循环引用（如下图）即使没有用到对象，但是由于互相引用，还是不会被垃圾回收</p><img src="/2022/02/09/JVM/image-20211121151726713.png" alt="image-20211121151726713 " style="zoom:50%;"><h3 id="1-2-可达性分析算法"><a href="#1-2-可达性分析算法" class="headerlink" title="1.2 可达性分析算法"></a>1.2 <strong>可达性分析算法</strong></h3><ul><li>扫描堆中的对象，看是否能够沿着GC Root对象为七点的引用链找到该对象，如果找不到，则该对象可以回收</li><li>哪些对象可以作为GC Root对象？<ul><li>System Class系统类，核心类</li><li>Native Stack  操作系统在执行时引用的java对象</li><li>Thread 当前活动线程执行过程中，局部变量所引用的对象</li><li>Busy Monitor  被加锁的对象</li></ul></li></ul><h3 id="1-3-五种引用"><a href="#1-3-五种引用" class="headerlink" title="1.3 五种引用"></a>1.3 五种引用</h3><img src="/2022/02/09/JVM/image-20211121160307960.png" alt="image-20211121160307960" style="zoom:40%;"><p>1.强引用</p><ul><li>只有所有GC Root对象都不通过【强引用】引用该对象，该对象才能被垃圾回收</li></ul><p>2.软引用（SoftReference）</p><ul><li><strong>仅有</strong>软引用引用该对象时，在垃圾回收<strong>后</strong>，内存<strong>仍</strong>不足时会再次触发垃圾回收，回收软引用对象</li><li>可以配合引用队列来释放软引用自身</li></ul><p>3.弱引用（WeakReference）</p><ul><li><strong>仅有</strong>软引用引用该对象时，在垃圾回收<strong>时</strong>，无论内存是否充足，都会回收弱引用对象</li><li>可以配合引用队列来释放弱引用自身</li></ul><p>4.虚引用（PhantomReference）&#x2F;ˈfæntəm&#x2F; 幽灵</p><ul><li>必须配合引用队列使用。主要配合ByteBuffer<ul><li>创建ByteBuffer对象时，还会创建一个Cleaner虚引用对象，ByteBuffer会分配一块直接内存，并将直接内存地址传递给虚引用对象。当ByteBuffer不被强引用时垃圾回收，直接内存不会被java垃圾回收管理，此时让虚引用Cleaner对象进入引用队列，Refefence Handler线程定时确认队列中是否有新入的Cleaner，如果有，则调用Cleaner.clean()，根据直接内存地址调用Unsafe.freeMemory()释放直接内存。</li></ul></li></ul><img src="/2022/02/09/JVM/image-20211121160736903.png" alt="image-20211121160736903 " style="zoom:50%;"><p>4.虚引用</p><p>5.终结器引用（FinalReference）</p><ul><li>在垃圾回收时，终结器引用入队（被引用对象暂时没有被回收），再由Finalize Handler线程【优先级很低】通过终结器引用找到引用对象，调用其重写的finalize()方法，第二次GC时才能回收其引用对象</li></ul><p><strong>案例</strong></p><h2 id="2-垃圾回收-x2F-收集算法"><a href="#2-垃圾回收-x2F-收集算法" class="headerlink" title="2. 垃圾回收&#x2F;收集算法"></a>2. 垃圾回收&#x2F;收集算法</h2><h3 id="2-1-标记清除算法"><a href="#2-1-标记清除算法" class="headerlink" title="2.1 标记清除算法"></a>2.1 标记清除算法</h3><p>Mark Sweep</p><p>【标记阶段】对没有GC Root直接引用的对象进行标记</p><p>【清除阶段】将对象的开始结束地址放进空闲的地址列表里，下一次分配新对象的时候在空闲地址列表里找是否有合适内存空间</p><ul><li>优点：速度快，清除内存只是保存地址信息</li><li>缺点：容易产生内存碎片【原因：内存空间不连续】，容易产生内存溢出</li></ul><img src="/2022/02/09/JVM/image-20211208152202902.png" alt="image-20211208152202902" style="zoom:70%;"><h3 id="2-2-标记整理"><a href="#2-2-标记整理" class="headerlink" title="2.2 标记整理"></a>2.2 标记整理</h3><p>Mark Compact</p><p>【标记阶段】对没有GC Root直接引用的对象进行标记</p><p>【整理阶段】移动对象，进行内存整理</p><ul><li>优点：没有内存碎片</li><li>缺点：速度较慢</li></ul><img src="/2022/02/09/JVM/image-20211208152839135.png" alt="image-20211208152839135 " style="zoom:67%;"><h3 id="2-3-标记复制【半区复制】"><a href="#2-3-标记复制【半区复制】" class="headerlink" title="2.3 标记复制【半区复制】"></a>2.3 标记复制【半区复制】</h3><p>Copy</p><p>创建两个大小一模一样的堆内存空间，一个叫做【FROM】，一个叫做【TO】，每次只使用其中的一块</p><p>将存活对象复制到【TO】中，并按顺序分配空间，全部清除【FROM】中的可回收对象，最后交换【FROM】和【TO】的位置，<strong>保证【TO】里面是空的</strong></p><ul><li>优点：没有内存碎片</li><li>缺点：需要占用两倍内存空间</li><li><img src="/2022/02/09/JVM/image-20211208161229475.png" alt="image-20211208161229475 " style="zoom:67%;"></li></ul><h3 id="2-4-分代垃圾回收机制"><a href="#2-4-分代垃圾回收机制" class="headerlink" title="2.4 分代垃圾回收机制"></a>2.4 分代垃圾回收机制</h3><img src="/2022/02/09/JVM/image-20211208161242615.png" alt="image-20211208161242615 " style="zoom:80%;"><ul><li>对象首先分配在伊甸园区</li><li>新生代空间不足时，触发<strong>Minor GC</strong>， 对伊甸园区和【FROM】区使用复制标记算法——存活对象复制到【TO】，存活对象年龄加1，并删除其他所有的可回收对象，交换【FROM】和【TO】<ul><li>注1：Minor GC时会引发<strong>stop the world</strong>——暂停其他用户的线程，直到Minor GC结束，用户线程才恢复正常【一般时间比较短，因为存活对象少，复制量少】</li><li>注2：当对象寿命超过阈值【最大寿命是15(4bit)，也可能提前晋升】时，会晋升至老年代</li></ul></li><li>当老年代空间不足时，会先尝试触发<strong>Minor GC</strong>，如果之后空间仍然不足，触发<strong>Full GC</strong>，此时STW的时间更长【会采用标记清除或者标记整理算法】</li><li>当新生代本来空间就不足而老年代空间足够，会直接晋升，将大对象放入老年代中</li><li>当一个线程抛出OOM【OutOfMemoryError】异常，会清空该线程占用的堆内存</li></ul><table><thead><tr><th>含义</th><th>参数</th><th>举例</th></tr></thead><tbody><tr><td>堆初始大小</td><td>-Xms</td><td>-Xms20M</td></tr><tr><td>堆最大大小</td><td>-Xmx或-XX:MaxHeapSize&#x3D;size</td><td>-Xmx10M</td></tr><tr><td>新生代大小</td><td>-Xmn或-XX:NewSize&#x3D;size + -XX:MaxNewSize&#x3D;size</td><td>-Xmn10Ｍ</td></tr><tr><td>幸存区比例（动态）</td><td>-XX:InitialSurvivorRatio&#x3D;ratio和-XX:+UseAdaptiveSizePolicy，其中这个ratio是伊甸园的占比</td><td></td></tr><tr><td>幸存区比例</td><td>-XX:SurvivorRatio&#x3D;ratio</td><td></td></tr><tr><td>晋升阈值</td><td>-XX:MaxTenuringThreshold&#x3D;threshold</td><td></td></tr><tr><td>晋升详情</td><td>-XX:+PrintTenuringDistribution</td><td></td></tr><tr><td>GC详情</td><td>-XX:+PrintGCDetails -verbose:gc</td><td></td></tr><tr><td>FullGC前MinorGC</td><td>-XX:+ScavengeBeforeFullGC</td><td></td></tr></tbody></table><h2 id="3-垃圾回收器"><a href="#3-垃圾回收器" class="headerlink" title="3.垃圾回收器"></a>3.垃圾回收器</h2><p>新生代都采用复制算法，老年代串行和吞吐量优先采用标记整理算法，响应时间优先采用标记清除算法</p><h3 id="3-1-Serial串行"><a href="#3-1-Serial串行" class="headerlink" title="3.1 Serial串行"></a>3.1 Serial串行</h3><p>Serial：工作在新生代，采用的是<strong>复制算法</strong></p><p>SerialOld：工作在老年代，采用的是<strong>标记整理算法</strong></p><p>垃圾回收的时候此线程不阻塞，其他线程都处于阻塞状态</p><p>-XX:+UseSerialGC&#x3D;Serial+SerialOld</p><img src="/2022/02/09/JVM/image-20211208165715959.png" alt="image-20211208165715959 " style="zoom:67%;"><h3 id="3-2-Parallel-吞吐量优先"><a href="#3-2-Parallel-吞吐量优先" class="headerlink" title="3.2 Parallel 吞吐量优先"></a>3.2 Parallel 吞吐量优先</h3><p>UseParalleGC：Paralle是并行的意思，UseParalleGC工作在新生代，采用<strong>复制算法</strong></p><p>UseParalleoldGC：工作在老年代，采用<strong>标记整理算法</strong></p><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs stata">-XX:+UseParallelGC ~ -XX:+UseParallelOldGC【只要打开一个，另外一个就默认开启】<br>-XX:+UseAdaptiveSizePolicy【动态调整eden和survivor区的比例】<br>-XX:GCTimeRatio=<span class="hljs-keyword">ratio</span>【通过公式1/(1+<span class="hljs-keyword">ratio</span>)计算垃圾回收时间占总运行时间的比例，一般<span class="hljs-keyword">ratio</span>=19，<span class="hljs-keyword">ratio</span>越大，则占总运行时间越小，jvm内部会增大堆内存以减少GC次数，降低GC运行时间】（radio默认为99）【这里显示吞吐量，<span class="hljs-keyword">ratio</span>越大吞吐量越大】<br>-XX:MaxGCPauseMillis=ms【垃圾回收STW的时间，和<span class="hljs-keyword">ratio</span>之间需要权衡，<span class="hljs-keyword">ratio</span>↑，堆↑，暂停时间也会变大】（默认200ms）<br>-XX:ParallelGCThreads=<span class="hljs-keyword">n</span>【控制垃圾回收的线程数】<br></code></pre></td></tr></table></figure><p>多个线程运行到安全点的时候STW，垃圾回收器开启多个线程【线程数和已开启线程数相关】</p><img src="/2022/02/09/JVM/image-20211208211536605.png" alt="image-20211208211536605 " style="zoom:67%;"><h3 id="3-3-CMS响应时间优先"><a href="#3-3-CMS响应时间优先" class="headerlink" title="3.3 CMS响应时间优先"></a>3.3 CMS响应时间优先</h3><p>老年代<strong>标记清除算法</strong>的并发(Concurrent)CMS，当CMS发生并发失败【碎片太多】时，老年代算法变为SerialOld单线程GC，此时垃圾回收时间很长</p><p>新生代<strong>复制</strong>算法</p><p>这里并发是指：用户线程和垃圾回收线程并发执行</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs xml">-XX:+UseConcMarkSweepGC ~ -XX:+UseParNewGC ~ SerialOld<br>-XX:ParallelGCThreads=n ~ -XX:ConcGCThreads=threads<br>-XX:CMSInitiatingOccupancyFraction=percent【当老年代空间用了percent，开启CMS，这样做是预留空间给浮动垃圾】（默认68%）<br>-XX:+CMSScavengeBeforeRemark【在重新标记之前强制minor gc，减少remark的时间 +打开 -禁用】<br></code></pre></td></tr></table></figure><img src="/2022/02/09/JVM/image-20211208212814746.png" alt="image-20211208212814746" style="zoom:67%;"><p>初始标记(CMS-initial-mark)：标记<strong>根对象</strong>，较快，此时<strong>STW</strong></p><p>并发标记(CMS-concurrent-mark)：和用户线程并发执行，标记可回收对象</p><p>重新标记(CMS-remark)：标记在并发标记时没有标记到的对象，<strong>STW</strong></p><p>并发清理(CMS-concurrent-sweep)：和其他用户线程并发执行，但是无法清理此时用户线程产生的新垃圾【<strong>浮动垃圾</strong>】，要下次垃圾回收才能清理</p><h3 id="3-4-Garbage-First-G1——优先收集垃圾多的区域，达到最大暂停时间的目标"><a href="#3-4-Garbage-First-G1——优先收集垃圾多的区域，达到最大暂停时间的目标" class="headerlink" title="3.4 Garbage First  G1——优先收集垃圾多的区域，达到最大暂停时间的目标"></a>3.4 Garbage First  G1——优先收集垃圾多的区域，达到最大暂停时间的目标</h3><p>同时注重吞吐量（Throughput）和低延迟（Low latency），默认的暂停目标是 200 ms</p><p>超大堆内存，会将堆划分为多个大小相等的 Region</p><p>整体上是 标记+整理 算法，两个区域之间是 复制 算法</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs routeros">-XX:+UseG1GC【jdk1.8需要开启G1作为垃圾回收器】<br>-XX:<span class="hljs-attribute">G1HeapRegionSize</span>=size<br>-XX:<span class="hljs-attribute">MaxGCPauseMillis</span>=time<br></code></pre></td></tr></table></figure><h4 id="3-4-1工作流程"><a href="#3-4-1工作流程" class="headerlink" title="3.4.1工作流程"></a>3.4.1<strong>工作流程</strong></h4><p><img src="/2022/02/09/JVM/image-20220117133712153.png" alt="image-20220117133712153"></p><img src="/2022/02/09/JVM/image-20220116223304511.png" alt="image-20220116223304511" style="zoom:50%;"><h4 id="3-4-2-Young-Collection——会STW"><a href="#3-4-2-Young-Collection——会STW" class="headerlink" title="3.4.2 Young Collection——会STW"></a>3.4.2 <strong>Young Collection</strong>——会STW</h4><p>新创建的对象被分配到<strong>伊甸园区E</strong>，当被占满时会触发Young Collection，将E中的对象拷贝到<strong>幸存区S</strong>中，当幸存区满或幸存区中的对象年龄超过一定阈值，会触发Young Collection，S中的对象会晋升到<strong>老年代O</strong>中</p><img src="/2022/02/09/JVM/image-20220116225620091.png" alt="image-20220116225620091" style="zoom:67%;"><img src="/2022/02/09/JVM/image-20220116225710287.png" alt="image-20220116225710287" style="zoom:67%;"><h4 id="3-4-3-Young-Collection-Concurrent-Mark（并发标记）——"><a href="#3-4-3-Young-Collection-Concurrent-Mark（并发标记）——" class="headerlink" title="3.4.3 Young Collection + Concurrent Mark（并发标记）——"></a>3.4.3 Young Collection + Concurrent Mark（并发标记）——</h4><ul><li>在Young Collection时会进行GC Root的<strong>初始标记</strong></li><li>当老年代占用堆空间比例达到阈值时会进行CM（<strong>并发标记</strong>，在标记的同时不会影响到用户工作线程，在root的基础上通过引用链找到其他对象，不会STW），阈值由参数决定(-XX:InitiatingHeapOccupancyPercent&#x3D;percent)，默认45%</li></ul><img src="/2022/02/09/JVM/image-20220116230249008.png" alt="image-20220116230249008" style="zoom:67%;"><h4 id="3-4-4-Mixed-Collection——对E、S、O进行全面垃圾回收"><a href="#3-4-4-Mixed-Collection——对E、S、O进行全面垃圾回收" class="headerlink" title="3.4.4 Mixed Collection——对E、S、O进行全面垃圾回收"></a>3.4.4 <strong>Mixed Collection</strong>——对E、S、O进行全面垃圾回收</h4><ul><li>最终标记（Remark），会STW，弥补并发标记没有被标记的对象【在并发阶段还在工作的线程所产生的对象】</li><li>拷贝存活（Evacuation），会STW：</li></ul><p>​        E会复制到新的S中，满了的S也会复制到新的S中，满的S中够年龄的对象会被复制到O中</p><p>​        O【&#x3D;&#x3D;优先收集垃圾最多的区域&#x3D;&#x3D;】：根据最大暂停时间(-XX:MaxGCPauseMillis&#x3D;ms)有选择地对老年代进行垃圾回收，如果可能会超过这个时间，那么JVM会挑出最有回收价值的老年代区域【能释放的空间更大】进行回收，那么复制的区域少了，则复制时间更少。如果复制的对象没有那么多，则会回收所有的老年代——这也是叫做<strong>Garbage First的原因</strong></p><img src="/2022/02/09/JVM/image-20220116224538710.png" alt="image-20220116224538710" style="zoom:67%;"><h4 id="3-4-5-避免全堆扫描——Rememberd-Set-CardTable"><a href="#3-4-5-避免全堆扫描——Rememberd-Set-CardTable" class="headerlink" title="3.4.5 避免全堆扫描——Rememberd Set + CardTable"></a>3.4.5 <strong>避免全堆扫描——Rememberd Set + CardTable</strong></h4><p>每一个Region都有一个对应的Rememberd Set，在对Reference类型的数据进行写操作的时候，会产生一个Write Barrier暂时中断写操作，检查Reference引用的对象是否处于不同的Region之中，如果是，在concurrent refinememt threads线程中，通过CartTable将相关引用信息记录到被引用对象（新生代对象）所属Region的Rememberd Set中</p><p>新生代在GC Root的时候大部分是去老年代找，而老年代很大，直接找效率低，采用&#x3D;&#x3D;卡表&#x3D;&#x3D;Card Table的技术，将老年代的区域进行划分成Card，每一个区域512Kb</p><img src="/2022/02/09/JVM/image-20220116232640057.png" alt="image-20220116232640057" style="zoom:67%;"><p>粉红色的区是**&#x3D;&#x3D;脏卡区&#x3D;&#x3D;**，表示老年代的对象被新生代引用。</p><p>新生代中有**&#x3D;&#x3D;Rememberd Set&#x3D;&#x3D;**，记录in coming reference，有哪些脏卡，将来遍历GC Root</p><img src="/2022/02/09/JVM/image-20220116233223658.png" alt="image-20220116233223658" style="zoom:67%;"><h4 id="3-4-6-Final-Marking阶段细讲"><a href="#3-4-6-Final-Marking阶段细讲" class="headerlink" title="3.4.6 Final Marking阶段细讲"></a>3.4.6 <strong>Final Marking阶段细讲</strong></h4><p>在并发标记阶段，如果<strong>对象引用发生变化</strong>，则触发写屏障，将<strong>该对象的引用对象（如下图的A对象）</strong>加入到satb_mark_queue队列中，在Final Marking时将这中的数据进行检查合并到Remembered Set中</p><p>pre-write barrier +satb_mark_queue</p><img src="/2022/02/09/JVM/image-20220117135034871.png" alt="image-20220117135034871" style="zoom:67%;"><h4 id="3-4-7"><a href="#3-4-7" class="headerlink" title="3.4.7"></a>3.4.7</h4><h3 id="3-5-小总结"><a href="#3-5-小总结" class="headerlink" title="3.5 小总结"></a>3.5 小总结</h3><ul><li>SerialGC——<ul><li>新生代内存不足发生的垃圾收集：minor gc  <strong>Serial 复制算法</strong></li><li>老年代内存不足发生的垃圾收集：full gc    <strong>SerialOld  标记-整理算法</strong></li></ul></li><li>ParallelGC<ul><li>新生代内存不足发生的垃圾收集： minor gc  <strong>Parallel Scavenge 复制算法</strong></li><li>老年代内存不足发生的垃圾收集：full gc    <strong>ParallelOld  标记-整理算法</strong></li></ul></li><li>CMS<ul><li>新生代内存不足发生的垃圾收集： minor gc  <strong>Serial 复制算法</strong></li><li>老年代内存不足                                                  <ul><li>如果回收速度&gt;垃圾产生速度，<strong>CMS 标记-清除算法</strong></li><li>如果回收速度&lt;垃圾产生速度，退化为串行<strong>SerialOld</strong>收集</li></ul></li></ul></li><li>G1    <strong>标记-整理算法</strong><ul><li>新生代内存不足发生的垃圾收集： minor gc   </li><li>老年代内存不足（并发标记+混合收集）<ul><li>如果回收速度&gt;垃圾产生速度，则还处于Mixed Collection阶段，虽然也有STW，但是时间都没有full gc的STW时间长</li><li>如果回收速度&lt;垃圾产生速度，并发标记失败，退化为串行收集，更长时间STW</li></ul></li></ul></li></ul><p><img src="/2022/02/09/JVM/image-20220117195213775.png" alt="image-20220117195213775"></p><h2 id="4-垃圾回收调优"><a href="#4-垃圾回收调优" class="headerlink" title="4. 垃圾回收调优"></a>4. 垃圾回收调优</h2><h1 id="四、类加载与字节码技术-ClassLoader"><a href="#四、类加载与字节码技术-ClassLoader" class="headerlink" title="四、类加载与字节码技术(ClassLoader)"></a>四、类加载与字节码技术(ClassLoader)</h1><p><img src="/2022/02/09/JVM/image-20220117203826429.png" alt="image-20220117203826429"></p><h2 id="4-1-类文件【class文件】结构"><a href="#4-1-类文件【class文件】结构" class="headerlink" title="4.1 类文件【class文件】结构"></a>4.1 类文件【class文件】结构</h2><p><a href="https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-4.html">java虚拟机规范文档</a></p><p>魔数【0-3字节】、版本号【4-7字节】、<strong>常量池</strong>【到29 56结束】、访问标识与继承关系、Field信息、Method信息、附加属性</p><h2 id="4-2-字节码指令"><a href="#4-2-字节码指令" class="headerlink" title="4.2 字节码指令"></a>4.2 字节码指令</h2><h3 id="4-2-1字节码指令demo"><a href="#4-2-1字节码指令demo" class="headerlink" title="4.2.1字节码指令demo"></a>4.2.1字节码指令demo</h3><p>如下图的红框中是main函数的字节码指令</p><p><img src="/2022/02/09/JVM/image-20220117222505659.png" alt="image-20220117222505659"></p><p>类加载器加载class文件时，常量池的数据会放进运行时常量池，<strong>方法字节码指令</strong>【和方法有关】存入方法区</p><p><img src="/2022/02/09/JVM/image-20220117221347233.png" alt="image-20220117221347233"></p><p>执行引擎逐行执行方法区内的指令</p><p><img src="/2022/02/09/JVM/image-20220118142106682.png" alt="image-20220118142106682"></p><p>这里小的数字都是和字节码指令存在一起，超过 short 范围的数字存入了常量池</p><h3 id="4-2-2-经典面试题用字节码角度分析"><a href="#4-2-2-经典面试题用字节码角度分析" class="headerlink" title="4.2.2 经典面试题用字节码角度分析"></a>4.2.2 经典面试题用字节码角度分析</h3><p><strong>1.</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java">a = <span class="hljs-number">10</span>;<br>b = a++ + ++a + a--;<br>print(a);<br>print(b);<br></code></pre></td></tr></table></figure><p>最终，a &#x3D; 11， b &#x3D; 34</p><p><strong>过程见原笔记</strong></p><p><strong>2.x &#x3D; x++，最终x还是不变</strong></p><p>正常分析思路：x将值先赋给x，再自增，但是x还是x本身</p><p>字节码角度分析：iload_x将槽中的数读取出来放入操作数槽中，iinc x 1 将槽中的数+1，<strong>但是不影响操作数栈中的数值</strong>，istore x又将操作数栈中的数放入槽中，覆盖了原来的值，所以x的值一直不会变</p><p><strong>3.代码块执行顺序问题</strong></p><p>按照先后来分：静态代码块-&gt;非静态代码块-&gt;类的构造方法，</p><p>如果都是静态的或者都是非静态的，则按照程序的顺序进行加载</p><p><strong>4.不要在finally中写return，这样会吞掉所有的异常</strong>，但是可以在try中return，finally中也照样给抛出其他异常athrow</p><img src="/2022/02/09/JVM/image-20220118143527208.png" alt="image-20220118143527208 " style="zoom:67%;"><img src="/2022/02/09/JVM/image-20220118143543953.png" alt="image-20220118143543953 " style="zoom:67%;"><h3 id="4-2-3-多态原理"><a href="#4-2-3-多态原理" class="headerlink" title="4.2.3 多态原理"></a>4.2.3 多态原理</h3><h3 id="4-2-4-异常字节码指令"><a href="#4-2-4-异常字节码指令" class="headerlink" title="4.2.4 异常字节码指令"></a>4.2.4 异常字节码指令</h3><h2 id="4-3-编译期处理【语法糖优化】"><a href="#4-3-编译期处理【语法糖优化】" class="headerlink" title="4.3 编译期处理【语法糖优化】"></a>4.3 编译期处理【语法糖优化】</h2><p>将.java源码编译为.class字节码的过程，自动生成和转换的一些代码【class字节码的形式】</p><h3 id="4-3-1-默认生成构造器"><a href="#4-3-1-默认生成构造器" class="headerlink" title="4.3.1 默认生成构造器"></a>4.3.1 默认生成构造器</h3><h3 id="4-3-2-自动拆装箱"><a href="#4-3-2-自动拆装箱" class="headerlink" title="4.3.2 自动拆装箱"></a>4.3.2 自动拆装箱</h3><p>JDK5之后编译器自动加上的</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">Integer x = <span class="hljs-number">1</span>;<br><span class="hljs-built_in">int</span> y = x<br><br><span class="hljs-comment">//======================【自动拆装箱】生成的字节码的伪代码为:</span><br>Integer x = <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Integer</span>.</span></span>value<span class="hljs-constructor">Of(1)</span>;<br><span class="hljs-built_in">int</span> y = x.<span class="hljs-built_in">int</span><span class="hljs-constructor">Value()</span>;<br></code></pre></td></tr></table></figure><h3 id="4-3-3-泛型集合取值"><a href="#4-3-3-泛型集合取值" class="headerlink" title="4.3.3 泛型集合取值"></a>4.3.3 泛型集合取值</h3><p>泛型擦除——在编译时将泛型信息删除，泛型类型的参数被替换成Object类型，并在得到这个泛型数据的时候进行强制转换checkcast操作。</p><p>在字节码文件【LocalVariableTypeTable】中保存了泛型的信息，这个信息并没有被擦除</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Candy3</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        List&lt;Integer&gt; list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        list.add(<span class="hljs-number">10</span>); <span class="hljs-comment">// 实际调用的是 List.add(Object e)</span><br>        <span class="hljs-type">Integer</span> <span class="hljs-variable">x</span> <span class="hljs-operator">=</span> list.get(<span class="hljs-number">0</span>); <span class="hljs-comment">// 实际调用的是 Object obj = List.get(int index);</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="/2022/02/09/JVM/image-20220118165434177.png" alt="image-20220118165434177"></p><p><img src="/2022/02/09/JVM/image-20220118165711020.png" alt="image-20220118165711020"></p><h3 id="4-3-4-foreach循环"><a href="#4-3-4-foreach循环" class="headerlink" title="4.3.4 foreach循环"></a>4.3.4 foreach循环</h3><p>数组的foreach循环会被编译成正常的for循环</p><p>继承自Collection接口的集合的foreach循环会被编译成迭代器循环</p><h3 id="4-3-5-switch"><a href="#4-3-5-switch" class="headerlink" title="4.3.5 switch"></a>4.3.5 switch</h3><h2 id="4-4-类加载阶段"><a href="#4-4-类加载阶段" class="headerlink" title="4.4 类加载阶段"></a>4.4 类加载阶段</h2><h3 id="4-4-1-加载"><a href="#4-4-1-加载" class="headerlink" title="4.4.1 加载"></a>4.4.1 加载</h3><p>将类的字节码class文件载入方法区，内部采用C++的<strong>instanceKlass</strong>描述java类，它的重要field有：</p><ul><li>_java_mirror：java的类镜像，例如对于String来说，string.class【<strong>String的类对象</strong>】就是类镜像，作用是把<strong>klass</strong>暴露给java使用【使用者和klass之间的桥梁】</li><li>_super  父类</li><li>_fields  成员变量</li><li>_method  方法</li><li>_constants  常量池</li><li>_class_loader  类加载器</li><li>_vtable  虚拟方法表</li><li>_itable  接口方法表</li></ul><p>如图所示是jdk1.8以后的版本，方法区用元空间实现的，其中java_mirror中保存了Person.class的地址，Person.class中保存了instanceKlass的地址</p><p>当Person对象要调用成员变量或者方法的时候，会在对象头部找到Person.class的地址，再在Person.class中找到InstanceKlass的地址，最后访问方法区中的InstanceKlass得到相关信息。</p><p><img src="/2022/02/09/JVM/image-20220118200043460.png" alt="image-20220118200043460"></p><p><img src="/2022/02/09/JVM/image-20220118194722163.png" alt="image-20220118194722163"></p><h3 id="4-4-2-连接"><a href="#4-4-2-连接" class="headerlink" title="4.4.2 连接"></a>4.4.2 连接</h3><h4 id="1、-验证"><a href="#1、-验证" class="headerlink" title="1、 验证"></a>1、 验证</h4><p>验证.class文件是否符合JVM规范，安全性检查，主要检查以下，目的是保证输入的字节流能正确地解析并储存于方法区之内，只有通过了这个阶段的验证后，字节流才会进入内存的方法区中进行存储，后面的阶段全部是基于方法区的存储结构进行的，不会再直接操作字节流</p><ul><li>是否以魔数0xCAFEBABE开头</li><li>主次版本号是否在当前虚拟机处理范围之内</li><li>常量池中的常量中是否有不被支持的常量类型（检查常量tag标志）</li><li>指向常量的各种索引值中是否有指向不存在的常量或者不符合类型的常量</li><li>class文件中各个部分及文件本身是否有被删除的或者附加的其他信息</li><li>……</li></ul><h4 id="2、-准备"><a href="#2、-准备" class="headerlink" title="2、 准备"></a>2、 准备</h4><p>为类变量（static修饰的变量）分配空间并设置初始值的阶段</p><ul><li>static变量在JDK7之前储存于instanceKlass末尾（方法区），之后在类对象末尾（堆中）</li><li>static变量——准备阶段分配空间，初始化阶段赋值</li><li>static final基本类型变量——准备阶段分配空间+赋值</li><li>static final引用类型变量——准备阶段分配空间，初始化阶段赋值</li></ul><p><img src="/2022/02/09/JVM/image-20220118201412153.png" alt="image-20220118201412153"></p><h4 id="3、-解析"><a href="#3、-解析" class="headerlink" title="3、 解析"></a>3、 解析</h4><p>将常量池内的符号引用替换为直接引用的过程</p><h3 id="4-4-3-初始化"><a href="#4-4-3-初始化" class="headerlink" title="4.4.3 初始化"></a>4.4.3 初始化</h3><p>类的初始化是【懒惰的】，触发类初始化的时机有：</p><ul><li>main 方法所在的类，总会被首先初始化</li><li>首次访问这个类的静态变量或静态方法时</li><li>子类初始化，如果父类还没初始化，会引发</li><li>子类访问父类的静态变量，只会触发父类的初始化</li><li>Class.forName</li><li>new 会导致初始化</li></ul><p>不会导致类初始化有：</p><ul><li>访问类的 static final 静态常量（基本类型和字符串）不会触发初始化</li><li>类对象.class 不会触发初始化</li><li>创建该类的数组不会触发初始化</li><li>类加载器的 loadClass 方法</li><li>Class.forName 的参数 2 为 false 时</li></ul><h3 id="x3D-x3D-4-4-4-面试题——懒汉式-x3D-x3D"><a href="#x3D-x3D-4-4-4-面试题——懒汉式-x3D-x3D" class="headerlink" title="&#x3D;&#x3D;4.4.4 面试题——懒汉式&#x3D;&#x3D;"></a>&#x3D;&#x3D;4.4.4 面试题——懒汉式&#x3D;&#x3D;</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TestSingTon</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        Sington.test();<br>        Sington.getInstance();<br>    &#125;<br>&#125;<br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 懒汉式，即只有触发初始化的操作的时候，才能初始化一个类，否则这个类是不会初始化的</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Sington</span>&#123;<br>    <span class="hljs-comment">//private修饰的构造方法，让外部访问不到</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-title function_">Sington</span><span class="hljs-params">()</span>&#123;&#125;;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 定义一个静态内部类</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">LasyHolder</span>&#123;<br>        <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">Sington</span> <span class="hljs-variable">SINGTON</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Sington</span>();<br>        <span class="hljs-keyword">static</span>&#123;<br>            System.out.println(<span class="hljs-string">&quot;lasyHolder init&quot;</span>);<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">//定义一个测试方法，直接用类名调用</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test</span><span class="hljs-params">()</span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;test&quot;</span>);<br>    &#125;<br>    <span class="hljs-comment">//定义一个懒汉测试方法，调用的时候会触发懒汉类的初始化</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Sington <span class="hljs-title function_">getInstance</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-keyword">return</span> LasyHolder.SINGTON;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="x3D-x3D-4-5-类加载器-x3D-x3D"><a href="#x3D-x3D-4-5-类加载器-x3D-x3D" class="headerlink" title="&#x3D;&#x3D;4.5 类加载器&#x3D;&#x3D;"></a>&#x3D;&#x3D;4.5 类加载器&#x3D;&#x3D;</h2><table><thead><tr><th>名称</th><th>加载类的路径</th><th>说明</th></tr></thead><tbody><tr><td>Bootstrap ClassLoader启动类加载器</td><td>JAVA_HOME&#x2F;jre&#x2F;lib</td><td>无法直接访问</td></tr><tr><td>Extension ClassLoader扩展类加载器</td><td>JAVA_HOME&#x2F;jre&#x2F;lib&#x2F;ext</td><td>上级为Bootstrap，显示为null，因为无法直接访问Bootstrap ClassLoader</td></tr><tr><td>Application ClassLoader应用类加载器</td><td>classpath</td><td>上级为Extension</td></tr><tr><td>自定义类加载器</td><td>自定义</td><td>上级为Application</td></tr></tbody></table> <figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-comment">//得到类对象，此时会进行类的加载、连接和初始化</span><br>Class&lt;?&gt; aClass = <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Class</span>.</span></span><span class="hljs-keyword">for</span><span class="hljs-constructor">Name(<span class="hljs-string">&quot;类路径&quot;</span>)</span>;<br><span class="hljs-comment">//调用类加载方法</span><br>.<span class="hljs-keyword">class</span>.get<span class="hljs-constructor">ClassLoader()</span>.load<span class="hljs-constructor">Class(<span class="hljs-string">&quot;类路径&quot;</span>)</span>;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//自定义类加载器</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyClassLoader</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">ClassLoader</span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">protected</span> Class&lt;?&gt; findClass(String name) <span class="hljs-keyword">throws</span> ClassNotFoundException &#123;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">path</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;&quot;</span>;   <span class="hljs-comment">//class文件所在的路径</span><br>        <span class="hljs-type">ByteArrayOutputStream</span> <span class="hljs-variable">os</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ByteArrayOutputStream</span>();<br>        <span class="hljs-keyword">try</span> &#123;<br>            Files.copy(Paths.get(path), os);<br>            <span class="hljs-type">byte</span>[] bytes = os.toByteArray();<br>            <span class="hljs-keyword">return</span> defineClass(name, bytes, <span class="hljs-number">0</span>, bytes.length);<br>        &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>            e.printStackTrace();<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ClassNotFoundException</span>(<span class="hljs-string">&quot;类文件未找到&quot;</span>,e);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="4-5-1-双亲委派模型"><a href="#4-5-1-双亲委派模型" class="headerlink" title="4.5.1 双亲委派模型"></a>4.5.1 双亲委派模型</h3><p>调用类加载器**loadClass()**方法的时候查找类的规则</p><p>源码如下：先在当前查找已加载的类对象中是否有，如果没有，去上级类加载器中找是否有此类【这里一般是在AppClassLoader，所以parent是ExtClassLoader】，ExtClassLoader查找当前已加载的类对象是否有，如果没有，此时其parent为null，调用findBootstrapClassOrNull在启动类加载器中查找，如果也找不到，则检查一遍ExtClassLoader，如果找不到会抛出异常，这个异常被AppClassLoader接收，此时c还是没有，AppClassLoader查找当前路径下是否有，如果有则返回。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">protected</span> Class&lt;?&gt; loadClass(String name, <span class="hljs-type">boolean</span> resolve)<br>        <span class="hljs-keyword">throws</span> ClassNotFoundException<br>    &#123;<br>        <span class="hljs-keyword">synchronized</span> (getClassLoadingLock(name)) &#123;<br>            <span class="hljs-comment">// First, check if the class has already been loaded</span><br>            Class&lt;?&gt; c = findLoadedClass(name);<br>            <span class="hljs-keyword">if</span> (c == <span class="hljs-literal">null</span>) &#123;<br>                <span class="hljs-type">long</span> <span class="hljs-variable">t0</span> <span class="hljs-operator">=</span> System.nanoTime();<br>                <span class="hljs-keyword">try</span> &#123;<br>                    <span class="hljs-keyword">if</span> (parent != <span class="hljs-literal">null</span>) &#123;<br>                        <span class="hljs-comment">//如果有上级，则委派上级loadClass</span><br>                        c = parent.loadClass(name, <span class="hljs-literal">false</span>);<br>                    &#125; <span class="hljs-keyword">else</span> &#123;<br>                        <span class="hljs-comment">//如果没有上级，则委派BootstrapClassLoader</span><br>                        c = findBootstrapClassOrNull(name);<br>                    &#125;<br>                &#125; <span class="hljs-keyword">catch</span> (ClassNotFoundException e) &#123;<br>                    <span class="hljs-comment">// ClassNotFoundException thrown if class not found</span><br>                    <span class="hljs-comment">// from the non-null parent class loader</span><br>                &#125;<br><br>                <span class="hljs-keyword">if</span> (c == <span class="hljs-literal">null</span>) &#123;<br>                    <span class="hljs-comment">// If still not found, then invoke findClass in order</span><br>                    <span class="hljs-comment">// to find the class.</span><br>                    <span class="hljs-type">long</span> <span class="hljs-variable">t1</span> <span class="hljs-operator">=</span> System.nanoTime();<br>                    <span class="hljs-comment">//在自己的类加载器路径下查找</span><br>                    c = findClass(name);<br><br>                    <span class="hljs-comment">// this is the defining class loader; record the stats</span><br>                    sun.misc.PerfCounter.getParentDelegationTime().addTime(t1 - t0);<br>                    sun.misc.PerfCounter.getFindClassTime().addElapsedTimeFrom(t1);<br>                    sun.misc.PerfCounter.getFindClasses().increment();<br>                &#125;<br>            &#125;<br>            <span class="hljs-keyword">if</span> (resolve) &#123;<br>                resolveClass(c);<br>            &#125;<br>            <span class="hljs-keyword">return</span> c;<br>        &#125;<br>    &#125;<br></code></pre></td></tr></table></figure><h3 id="4-5-2-线程上下文类加载器——破坏双亲委派模型"><a href="#4-5-2-线程上下文类加载器——破坏双亲委派模型" class="headerlink" title="4.5.2 线程上下文类加载器——破坏双亲委派模型"></a>4.5.2 线程上下文类加载器——破坏双亲委派模型</h3><p>以jdbc.Driver举例</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">DriverManager</span> &#123;<br><span class="hljs-comment">/* Prevent the DriverManager class from being instantiated. */</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-title function_">DriverManager</span><span class="hljs-params">()</span>&#123;&#125;<br><br>    <span class="hljs-keyword">static</span> &#123;<br>        loadInitialDrivers();<br>        println(<span class="hljs-string">&quot;JDBC DriverManager initialized&quot;</span>);<br>    &#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">loadInitialDrivers</span><span class="hljs-params">()</span> &#123;<br>        String drivers;<br>        <span class="hljs-keyword">try</span> &#123;<br>            drivers = AccessController.doPrivileged(<span class="hljs-keyword">new</span> <span class="hljs-title class_">PrivilegedAction</span>&lt;String&gt;() &#123;<br>                <span class="hljs-keyword">public</span> String <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>                    <span class="hljs-keyword">return</span> System.getProperty(<span class="hljs-string">&quot;jdbc.drivers&quot;</span>);<br>                &#125;<br>            &#125;);<br>        &#125; <span class="hljs-keyword">catch</span> (Exception ex) &#123;<br>            drivers = <span class="hljs-literal">null</span>;<br>        &#125;<br><br>    <span class="hljs-comment">//1.使用ServiceLoader机制加载驱动，SPI(Service Provider Interface)</span><br>        AccessController.doPrivileged(<span class="hljs-keyword">new</span> <span class="hljs-title class_">PrivilegedAction</span>&lt;Void&gt;() &#123;<br>            <span class="hljs-keyword">public</span> Void <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br><br>                ServiceLoader&lt;Driver&gt; loadedDrivers = ServiceLoader.load(Driver.class);<br>                Iterator&lt;Driver&gt; driversIterator = loadedDrivers.iterator();<br>               <br>                <span class="hljs-keyword">try</span>&#123;<br>                    <span class="hljs-keyword">while</span>(driversIterator.hasNext()) &#123;<br>                        driversIterator.next();<br>                    &#125;<br>                &#125; <span class="hljs-keyword">catch</span>(Throwable t) &#123;<br>                <span class="hljs-comment">// Do nothing</span><br>                &#125;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>            &#125;<br>        &#125;);<br><br>        println(<span class="hljs-string">&quot;DriverManager.initialize: jdbc.drivers = &quot;</span> + drivers);<br><br>    <span class="hljs-comment">//2.使用jdbc.Drivers定义的驱动名加载驱动</span><br>        <span class="hljs-keyword">if</span> (drivers == <span class="hljs-literal">null</span> || drivers.equals(<span class="hljs-string">&quot;&quot;</span>)) &#123;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        String[] driversList = drivers.split(<span class="hljs-string">&quot;:&quot;</span>);<br>        println(<span class="hljs-string">&quot;number of Drivers:&quot;</span> + driversList.length);<br>        <span class="hljs-keyword">for</span> (String aDriver : driversList) &#123;<br>            <span class="hljs-keyword">try</span> &#123;<br>                println(<span class="hljs-string">&quot;DriverManager.Initialize: loading &quot;</span> + aDriver);<br>                <span class="hljs-comment">//getSystemClassLoader()就是应用程序类加载器</span><br>                Class.forName(aDriver, <span class="hljs-literal">true</span>,<br>                        ClassLoader.getSystemClassLoader());<br>            &#125; <span class="hljs-keyword">catch</span> (Exception ex) &#123;<br>                println(<span class="hljs-string">&quot;DriverManager.Initialize: load failed: &quot;</span> + ex);<br>            &#125;<br>        &#125;<br>    &#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> &lt;S&gt; ServiceLoader&lt;S&gt; <span class="hljs-title function_">load</span><span class="hljs-params">(Class&lt;S&gt; service)</span> &#123;<br>    <span class="hljs-comment">//获取线程上下文类加载器，默认就是应用程序类加载器</span><br>    <span class="hljs-type">ClassLoader</span> <span class="hljs-variable">cl</span> <span class="hljs-operator">=</span> Thread.currentThread().getContextClassLoader();<br>    <span class="hljs-keyword">return</span> ServiceLoader.load(service, cl);<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> &lt;S&gt; ServiceLoader&lt;S&gt; <span class="hljs-title function_">load</span><span class="hljs-params">(Class&lt;S&gt; service,ClassLoader loader)</span><br>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ServiceLoader</span>&lt;&gt;(service, loader);<br>&#125;<br><span class="hljs-comment">//在ServiceLoader类中的内部类LazyIterator中的nextService()方法使用class.forName方法从应用类加载器开始加载</span><br></code></pre></td></tr></table></figure><p>&#x3D;&#x3D;SPI详细&#x3D;&#x3D;：在 jar 包的 META-INF&#x2F;services 包下，以接口全限定名名为文件，文件内容是实现类名称</p><img src="/2022/02/09/JVM/image-20220118233933846.png" alt="image-20220118233933846 " style="zoom:67%;"><p>只要做了这样的配置，就可以使用这种写法加载接口的实现类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java">ServiceLoader&lt;接口类型&gt; allImpls = ServiceLoader.load(接口类型.class);<br>Iterator&lt;接口类型&gt; iter = allImpls.iterator();<br><span class="hljs-keyword">while</span>(iter.hasNext()) &#123;<br>iter.next();<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="4-6-运行期优化"><a href="#4-6-运行期优化" class="headerlink" title="4.6 运行期优化"></a>4.6 运行期优化</h2>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
