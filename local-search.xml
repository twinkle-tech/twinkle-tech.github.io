<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>Spring笔记</title>
    <link href="/2022/02/12/Spring/"/>
    <url>/2022/02/12/Spring/</url>
    
    <content type="html"><![CDATA[<h1 id="第一章-绪论"><a href="#第一章-绪论" class="headerlink" title="第一章   绪论"></a>第一章   绪论</h1><p>Spring：解耦合，核心技术为Ioc和Aop</p><p>junit：单元测试——添加了junit依赖之后，src&#x2F;test目录会变成绿色，在src&#x2F;test目录下创建测试类。</p><p>​            可以再测试类中写很多测试方法，这些方法可以独自运行，也可以同时运行(运行整个类)。</p><p>​            测试方法需满足要求：</p><p>​        (1)public</p><p>​        (2)void</p><p>​        (3)方法没有参数</p><p>​        (4)方法上写@Test，进行注解</p><p>放入容器中的对象：</p><p>​    dao类、service类、controller类、工具类</p><p>不放入容器的对象：</p><p>​    1.实体类对象（由数据库产生的）</p><p>​    2.servlet、listener、filter等（由Tomcat产生）</p><h2 id="1-Ioc：Inversion-of-Control-控制反转"><a href="#1-Ioc：Inversion-of-Control-控制反转" class="headerlink" title="1.Ioc：Inversion of Control  控制反转"></a>1.Ioc：Inversion of Control  控制反转</h2><p>​     控制：创建对象，对象的属性赋值、对象之间的关系管理</p><p>​     反转：由容器代替开发人员创建对象、给对象赋值</p><p>​     正转：开发人员主动new对象并管理对象</p><p>优点：减少对代码的改动来完成更多的功能，实现解耦合（不写死对象）            </p><p>注意：实现业务对象之间的解耦合（例如service和dao接口之间，在容器中创建对象，且确定service和dao之间的关系……）                    &#x3D;&#x3D;但是这和直接在代码中绑定service和dao有什么区别？&#x3D;&#x3D;</p><p>Ioc的实现，使用了DI，而最底层使用了反射机制</p><p>DI：Dependency Injection  依赖注入</p><p>​        在程序中提供对象名称，而对象的创建、属性赋值、查找都在容器中实现</p><img src="/2022/02/12/Spring/image-20210806210413681.png" alt="image-20210806210413681 " style="zoom:80%;"><h1 id="第二章-IOC-控制反转"><a href="#第二章-IOC-控制反转" class="headerlink" title="第二章  IOC 控制反转"></a>第二章  IOC 控制反转</h1><h2 id="一、bean标签创建对象的项目"><a href="#一、bean标签创建对象的项目" class="headerlink" title="一、bean标签创建对象的项目"></a>一、bean标签创建对象的项目</h2><p>1.创建maven</p><p>2.加入maven依赖<depedency></depedency></p><p>3.resources文件夹中创建beans.xml文件，一个bean语句就是创建一个对象</p><figure class="highlight java"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><pre><code class="hljs java">&lt;bean id=<span class="hljs-string">&quot;student&quot;</span> class=<span class="hljs-string">&quot;tt.twinklex.domain.Student&quot;</span>&gt;<br></code></pre></td></tr></table></figure><p>4.得到spring容器对象，通过这个对象得到想要创建的对象</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-type">String</span> config = <span class="hljs-string">&quot;beans.xml&quot;</span>;<br><span class="hljs-comment">//创建表示spring容器的对象ApplicationContext，传入参数：从类路径（target/classes）中加载spring的配置文件</span><br><span class="hljs-comment">//读取beans.xml文件</span><br>ApplicationContext ac = <span class="hljs-keyword">new</span> <span class="hljs-built_in">ClassPathXmlApplicationContext</span>(config);<br></code></pre></td></tr></table></figure><h2 id="二、DI（对象创建、赋值、查找）依赖注入"><a href="#二、DI（对象创建、赋值、查找）依赖注入" class="headerlink" title="二、DI（对象创建、赋值、查找）依赖注入"></a>二、DI（对象创建、赋值、查找）依赖注入</h2><h3 id="1-基于xml的DI"><a href="#1-基于xml的DI" class="headerlink" title="1.基于xml的DI"></a>1.基于xml的DI</h3><h4 id="1-set注入（设值注入），无参构造"><a href="#1-set注入（设值注入），无参构造" class="headerlink" title="(1)set注入（设值注入），无参构造"></a>(1)set注入（设值注入），无参构造</h4><p>调用无参构造，&#x3D;&#x3D;注入指传参&#x3D;&#x3D;</p><p>在beans.xml方法中加入<property>，在对象类中写上对应属性的set方法</property></p><p>&#x3D;&#x3D;<property>只认set方法，和属性存不存在没有关系&#x3D;&#x3D;</property></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java">&lt;bean id=<span class="hljs-string">&quot;student&quot;</span> class=<span class="hljs-string">&quot;tt.twinklex.domain.Student&quot;</span>&gt;<br>    &lt;property name=<span class="hljs-string">&quot;name&quot;</span> value=<span class="hljs-string">&quot;twinkle&quot;</span>/&gt;&lt;!--执行SetName()方法--&gt;<br>    &lt;property name=<span class="hljs-string">&quot;age&quot;</span> value=<span class="hljs-string">&quot;20&quot;</span>/&gt;&lt;!--执行SetAge()方法--&gt;<br>&lt;/bean&gt;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java">&lt;!--如果传入的参数是一个引用对象，则使用ref传入，而不是value--&gt;<br>&lt;bean id=<span class="hljs-string">&quot;student1&quot;</span> class=<span class="hljs-string">&quot;tt.twinklex.domain.Student&quot;</span>&gt;<br>    &lt;property name=<span class="hljs-string">&quot;name&quot;</span> value=<span class="hljs-string">&quot;张三&quot;</span>/&gt;<br>    &lt;property name=<span class="hljs-string">&quot;age&quot;</span> value=<span class="hljs-string">&quot;20&quot;</span>/&gt;<br>    &lt;property name=<span class="hljs-string">&quot;school&quot;</span> ref=<span class="hljs-string">&quot;school&quot;</span>/&gt;<br>&lt;/bean&gt;<br><br>&lt;bean id=<span class="hljs-string">&quot;school&quot;</span> class=<span class="hljs-string">&quot;tt.twinklex.domain.School&quot;</span>&gt;<br>    &lt;property name=<span class="hljs-string">&quot;name&quot;</span> value=<span class="hljs-string">&quot;潜山中学&quot;</span>/&gt;<br>&lt;/bean&gt;<br></code></pre></td></tr></table></figure><h4 id="2-构造注入，调用有参构造"><a href="#2-构造注入，调用有参构造" class="headerlink" title="(2)构造注入，调用有参构造"></a>(2)构造注入，调用有参构造</h4><p>&#x3D;&#x3D;<constructor-arg>只和有参构造中的参数有关&#x3D;&#x3D;</constructor-arg></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java">&lt;bean id=<span class="hljs-string">&quot;student-gouzao&quot;</span> class=<span class="hljs-string">&quot;tt.twinklex.domain.Student&quot;</span>&gt;<br>    &lt;constructor-arg name=<span class="hljs-string">&quot;age&quot;</span> value=<span class="hljs-string">&quot;20&quot;</span>/&gt;<br>    &lt;constructor-arg name=<span class="hljs-string">&quot;name&quot;</span> value=<span class="hljs-string">&quot;李四&quot;</span>/&gt;<br>    &lt;constructor-arg name=<span class="hljs-string">&quot;school&quot;</span> ref=<span class="hljs-string">&quot;school&quot;</span>/&gt;<br>&lt;/bean&gt;<br>&lt;bean id=<span class="hljs-string">&quot;school&quot;</span> class=<span class="hljs-string">&quot;tt.twinklex.domain.School&quot;</span>&gt;<br>    &lt;property name=<span class="hljs-string">&quot;name&quot;</span> value=<span class="hljs-string">&quot;潜山中学&quot;</span>/&gt;<br>&lt;/bean&gt;<br></code></pre></td></tr></table></figure><h4 id="3-引用类型的自动注入"><a href="#3-引用类型的自动注入" class="headerlink" title="(3)引用类型的自动注入"></a>(3)引用类型的自动注入</h4><p>spring自动给引用类型赋值</p><h5 id="1-autowire-x3D-”byName”"><a href="#1-autowire-x3D-”byName”" class="headerlink" title="1.autowire&#x3D;”byName”"></a>1.autowire&#x3D;”byName”</h5><p>在配置文件中查找和属性名相同的<bean></bean></p><p>如下代码中，Student的School属性名字为school，则找到了id为school的<bean></bean></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java">&lt;bean id=<span class="hljs-string">&quot;student&quot;</span> class=<span class="hljs-string">&quot;tt.twinklex.domain1.Student&quot;</span> autowire=<span class="hljs-string">&quot;byName&quot;</span>&gt;<br>    &lt;property name=<span class="hljs-string">&quot;age&quot;</span> value=<span class="hljs-string">&quot;20&quot;</span>/&gt;<br>    &lt;property name=<span class="hljs-string">&quot;name&quot;</span> value=<span class="hljs-string">&quot;张三&quot;</span>/&gt;<br>&lt;/bean&gt;<br><br>&lt;bean id=<span class="hljs-string">&quot;school&quot;</span> class=<span class="hljs-string">&quot;tt.twinklex.domain1.School&quot;</span>&gt;<br>    &lt;property name=<span class="hljs-string">&quot;name&quot;</span> value=<span class="hljs-string">&quot;上海大学&quot;</span>/&gt;<br>&lt;/bean&gt;<br></code></pre></td></tr></table></figure><h5 id="2-autowire-x3D-”byType”"><a href="#2-autowire-x3D-”byType”" class="headerlink" title="2.autowire&#x3D;”byType”"></a>2.autowire&#x3D;”byType”</h5><p> 找Student中的引用类型的数据类型，在配置文件中找<bean>的class同源关系的，这个bean就被赋值给该引用类型。但是只能有一个同缘关系，不然就会报错！！！</bean></p><p>同源：</p><p>a.Java类中引用类型的数据类型和bean的class是一样的</p><p>b.Java类中引用类型的数据类型和bean的class和父子关系（不能反！）</p><p>c.Java类中引用类型的数据类型和bean的class是接口和实现的关系</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java">&lt;bean id=<span class="hljs-string">&quot;myschool&quot;</span> class=<span class="hljs-string">&quot;tt.twinklex.domain1.School&quot;</span>&gt;<br>    &lt;property name=<span class="hljs-string">&quot;name&quot;</span> value=<span class="hljs-string">&quot;上海大学&quot;</span>/&gt;<br>&lt;/bean&gt;<br><br>&lt;bean id=<span class="hljs-string">&quot;student_bytype&quot;</span> class=<span class="hljs-string">&quot;tt.twinklex.domain1.Student&quot;</span> autowire=<span class="hljs-string">&quot;byType&quot;</span>&gt;<br>    &lt;property name=<span class="hljs-string">&quot;name&quot;</span> value=<span class="hljs-string">&quot;李四&quot;</span>/&gt;<br>    &lt;property name=<span class="hljs-string">&quot;age&quot;</span> value=<span class="hljs-string">&quot;25&quot;</span>/&gt;<br>&lt;/bean&gt;<br></code></pre></td></tr></table></figure><h3 id="x3D-x3D-x3D-x3D-x3D-x3D-2-基于注解的DI-x3D-x3D"><a href="#x3D-x3D-x3D-x3D-x3D-x3D-2-基于注解的DI-x3D-x3D" class="headerlink" title="&#x3D;&#x3D;*&#x3D;&#x3D;&#x3D;&#x3D;2.基于注解的DI&#x3D;&#x3D;"></a>&#x3D;&#x3D;*&#x3D;&#x3D;&#x3D;&#x3D;2.基于注解的DI&#x3D;&#x3D;</h3><h4 id="1-创建对象"><a href="#1-创建对象" class="headerlink" title="(1)创建对象"></a>(1)创建对象</h4><p>@component</p><p>操作步骤：</p><p>i.在类的上方声明@component</p><p>ii.在配置文件中加入组件扫描器(component-scan)</p><p>解释：spring会扫描遍历base-packet指定的包，扫描包中和子包中的所有类，找到类的注解，按照注解功能创建对象或给属性赋值，无参构造创建对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@Component</span>,等同于&lt;bean&gt;的功能</span><br><span class="hljs-comment"> * &lt;bean id=&quot;mystudent&quot; class=&quot;tt.twinklex.function.Student&quot; /&gt;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">@Component(&quot;mystudent&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Student</span> &#123;&#125;<br><br><span class="hljs-comment">//配置文件，Student在function包中</span><br>&lt;context:component-scan base-<span class="hljs-keyword">package</span>=<span class="hljs-string">&quot;tt.twinklex.function&quot;</span>/&gt;<br></code></pre></td></tr></table></figure><p>加入多个组件扫描器：</p><p>i.写多条</p><p>ii.分隔符：,或者;</p><table><thead><tr><th>注解</th><th>对应类上方</th><th>功能</th></tr></thead><tbody><tr><td>@Repository</td><td>dao实现类</td><td>创建dao对象，该对象能访问数据库</td></tr><tr><td>@Service</td><td>service实现类</td><td>service对象，有事务等功能</td></tr><tr><td>@Controller</td><td>控制器（处理类）</td><td>控制器对象，接受用户提交的参数，显示请求的处理结果</td></tr><tr><td>@Component</td><td>其他</td><td>无</td></tr><tr><td>@value</td><td></td><td>给对象属性（简单类型）赋值</td></tr><tr><td>@Autowired</td><td></td><td>给对象属性（引用类型）赋值，自动byType</td></tr><tr><td>@Qualifier+@Autowired</td><td></td><td>给对象属性（引用类型）赋值，自动byName</td></tr><tr><td>@Resource</td><td></td><td>给对象属性（引用类型）赋值，byType和byName都可</td></tr></tbody></table><h4 id="2-对象属性注入（属性赋值）"><a href="#2-对象属性注入（属性赋值）" class="headerlink" title="(2)对象属性注入（属性赋值）"></a>(2)对象属性注入（属性赋值）</h4><h5 id="1-简单类型注入-value-“”"><a href="#1-简单类型注入-value-“”" class="headerlink" title="1.简单类型注入@value(“”)"></a>1.简单类型注入@value(“”)</h5><p>可以写在属性上方（类中不需要setter），也可写在setter上</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Component(&quot;mystudent&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Student</span> &#123;<br>    <span class="hljs-meta">@Value(&quot;tt&quot;)</span><br>    <span class="hljs-keyword">private</span> String name;<br>    <span class="hljs-meta">@Value(&quot;22&quot;)</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> age;<br></code></pre></td></tr></table></figure><h5 id="2-引用类型注入"><a href="#2-引用类型注入" class="headerlink" title="2.引用类型注入"></a>2.引用类型注入</h5><h5 id="Autowired（对应byType）"><a href="#Autowired（对应byType）" class="headerlink" title="@Autowired（对应byType）"></a>@Autowired（对应byType）</h5><p>写在属性上方（类中不需要setter），也可写在setter上</p><p>&#x3D;&#x3D;注意&#x3D;&#x3D;：引用类型的对象要先创建好（@Component或手动<bean>）</bean></p><h5 id="Qualifier（对应byName）"><a href="#Qualifier（对应byName）" class="headerlink" title="@Qualifier（对应byName）"></a>@Qualifier（对应byName）</h5><h5 id="Resource-对应byType和byName两者"><a href="#Resource-对应byType和byName两者" class="headerlink" title="@Resource(对应byType和byName两者)"></a>@Resource(对应byType和byName两者)</h5><p>如果没有任何参数，则先是byName，找不到名字则是byType</p><p>注意：在这里byName先找首字母小写的类对象，例如School类会先找叫school的对象</p><p>如果有参数value&#x3D;”name”，则是byName，用名字来查找</p><h1 id="第三章-AOP-Aspect-Orient-Programming-面向切面编程"><a href="#第三章-AOP-Aspect-Orient-Programming-面向切面编程" class="headerlink" title="第三章 AOP  (Aspect Orient Programming)面向切面编程"></a>第三章 AOP  (Aspect Orient Programming)面向切面编程</h1><h2 id="一、动态代理"><a href="#一、动态代理" class="headerlink" title="一、动态代理"></a>一、动态代理</h2><p>（顾名思义就是代理，只是这个代理是个辅助，在实现原来功能的基础上，有可以增加其余功能的能力）</p><p>作用：</p><p>1.在不改变业务程序的基础上，为代码段增加新的功能</p><p>2.减少代码的重复</p><p>3.专注业务逻辑代码</p><p>4.解耦合</p><p>操作：提供代理对象，为原程序提供代理方法，在代理方法中写入新增的功能</p><h3 id="1-JDK动态代理-Ch04-aop1，贴代码有点多…"><a href="#1-JDK动态代理-Ch04-aop1，贴代码有点多…" class="headerlink" title="1.JDK动态代理(Ch04-aop1，贴代码有点多…)"></a>1.JDK动态代理(Ch04-aop1，贴代码有点多…)</h3><p>&#x3D;&#x3D;要求目标类必须实现接口&#x3D;&#x3D;</p><p>JDK Proxy，得到的代理对象命名一般是：.$ProxyN，其可以看成继承了目标接口（&#x3D;&#x3D;所以其只可以是接口类型，不能是实现类的类型&#x3D;&#x3D;）</p><p>生成动态代理对象：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">newProxyInstance(ClassLoader loader, Class&lt;?&gt;[] interfaces, InvocationHandler h)<br></code></pre></td></tr></table></figure><p>第一个参数：类的字节码文件</p><p>第二个参数：类的实现接口</p><p>第三个参数：InvocationHandler本身（在这个类中重写invoke()方法，代理对象执行），</p><p>最后得到的继承关系，相关操作在invoke()方法中完成</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">$ProxyN</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Interface</span>&#123;    <br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">foo</span><span class="hljs-params">()</span>&#123;       <br>        *<span class="hljs-comment">//do something...*   </span><br>    &#125; <br>&#125;<br></code></pre></td></tr></table></figure><p>步骤：</p><p>(1)创建目标接口、目标接口实现类，写目标方法</p><p>(2)创建InvocationHandler接口实现类，重写invoke()方法，给目标方法增加功能</p><p>​        其中，invoke()方法就是对应着某个类的某个方法（具体看传参）</p><p>(3)使用jdk中类Proxy，创建代理对象，调用目标类的方法，就会实现功能增强。</p><h3 id="2-cglib动态代理"><a href="#2-cglib动态代理" class="headerlink" title="2.cglib动态代理"></a>2.cglib动态代理</h3><p>&#x3D;&#x3D;要求目标类不能是final的，方法也不能是final的&#x3D;&#x3D;</p><p>使用第三方工具类，实现代理对象的创建</p><h2 id="二、AOP：动态代理的规范化"><a href="#二、AOP：动态代理的规范化" class="headerlink" title="二、AOP：动态代理的规范化"></a>二、AOP：动态代理的规范化</h2><p><strong>含义</strong>：动态代理的规范化。面向切面编程，从动态的角度考虑程序的运行过程</p><p>实现框架：Spring实现aop(不太用)</p><p>​                    aspectj框架</p><p><strong>怎么理解</strong>：</p><p>1.需要在分析项目功能时，找出切面</p><p>2.合理地安排切面的执行时间（在目标方法前还是后）（对应注解）</p><p>3.合理地安排切面的执行位置，哪个类、哪个方法需要加入切面（切入点表达式中）</p><p><strong>术语</strong></p><p>Aspect：切面，表示增强的功能（例如日志、事务、统计信息、参数检查、权限验证）</p><p>JoinPoint：连接点，连接业务方法和切面的位置</p><p>Pointcut：切入点，一个或多个JoinPoint的集合，表示切面功能执行的位置</p><p>Advice：通知，表示切面功能的执行时间 </p><h3 id="aspectj使用步骤"><a href="#aspectj使用步骤" class="headerlink" title="aspectj使用步骤"></a>aspectj使用步骤</h3><p>1.创建目标接口(SomeService)、目标接口实现类，写目标方法</p><p>2.在切面类上方加@Aspect注解</p><p>3.在切面类方法上加通知注解：</p><table><thead><tr><th>注解</th><th>功能</th></tr></thead><tbody><tr><td>@Before(value &#x3D; “execution()”)</td><td>前置通知</td></tr><tr><td>@AfterReturning(value &#x3D; “execution()”, returning &#x3D; “”)</td><td>后置通知，可得到目标方法的返回值，在此值基础上加功能，returning中的str命名需和方法中的形参一致</td></tr><tr><td>@Around</td><td>环绕通知，在目标方法前和后都能增强功能，控制目标方法的访问，修改返回值</td></tr><tr><td>@AfterThrowing</td><td>异常通知，目标方法抛出异常后执行的通知</td></tr><tr><td>@After</td><td>最终通知，总是会被执行的代码</td></tr><tr><td>@Pointcut</td><td>定义和管理切入点的辅助注解</td></tr><tr><td></td><td></td></tr></tbody></table><p>切入点表达式：</p><p>execution((访问权限  方法返回值  包名.类名.方法名称(方法的参数)  异常类型)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Before(value = &quot;execution(public void tt.twinkle.service.impl.SomeServiceImpl.dosome())&quot;)</span><br><br><span class="hljs-meta">@Before(value = &quot;execution(* *..SomeServiceImpl.dosome(String))&quot;)</span><br></code></pre></td></tr></table></figure><p>4.如果在切面方法中需要得到实参的值，在切面方法中加入JoinPoint</p><h1 id="第四章-Spring和Mybatis结合"><a href="#第四章-Spring和Mybatis结合" class="headerlink" title="第四章 Spring和Mybatis结合"></a>第四章 Spring和Mybatis结合</h1><p>Mybatis需要创建SqlSession对象，调用getMapper()方法进行动态代理</p><p>Spring则是在Ioc基础上，辅助完成一些功能：</p><p>1.独立的连接池对象，使用阿里的druid连接池</p><p>2.创建SqlSessionFactory对象</p><p>3.创建dao对象</p><h2 id="步骤（代码一定不能直接拷贝！！！，特别是有路径的地方，要重新写）"><a href="#步骤（代码一定不能直接拷贝！！！，特别是有路径的地方，要重新写）" class="headerlink" title="步骤（代码一定不能直接拷贝！！！，特别是有路径的地方，要重新写）"></a>步骤（代码一定不能直接拷贝！！！，特别是有路径的地方，要重新写）</h2><img src="/2022/02/12/Spring/未命名文件-1629896573338.png" alt="未命名文件 " style="zoom:100%;"><p>1.pom.xml中添加依赖（测试依赖、spring依赖、spring事务、mybatis依赖、mybatis和spring的共同依赖、mysql依赖、druid依赖）</p><p>2.创建实体类</p><p>3.创建Dao包（Dao接口和mapper文件（写sql语句的））</p><p>4.mybatis的配置文件</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java">&lt;?xml version=<span class="hljs-string">&quot;1.0&quot;</span> encoding=<span class="hljs-string">&quot;UTF-8&quot;</span> ?&gt;<br>&lt;!DOCTYPE configuration<br>        PUBLIC <span class="hljs-string">&quot;-//mybatis.org//DTD Config 3.0//EN&quot;</span><br>        <span class="hljs-string">&quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;</span>&gt;<br>&lt;configuration&gt;<br>&lt;!--    设置mybatis输出日志--&gt;<br>    &lt;settings&gt;<br>        &lt;setting name=<span class="hljs-string">&quot;logImpl&quot;</span> value=<span class="hljs-string">&quot;STDOUT_LOGGING&quot;</span>/&gt;<br>    &lt;/settings&gt;<br><br>    &lt;typeAliases&gt;<br>        &lt;!--        &lt;typeAlias type=<span class="hljs-string">&quot;twinkle.domain.Student&quot;</span> alias=<span class="hljs-string">&quot;student&quot;</span>/&gt;--&gt;<br>        &lt;<span class="hljs-keyword">package</span> name=<span class="hljs-string">&quot;tt.twinkle.entity&quot;</span>/&gt;<br>    &lt;/typeAliases&gt;<br><br>&lt;!--    sql mapper文件的位置--&gt;<br>    &lt;mappers&gt;<br>        &lt;<span class="hljs-keyword">package</span> name=<span class="hljs-string">&quot;tt.twinkle.dao&quot;</span>/&gt;<br>    &lt;/mappers&gt;<br>&lt;/configuration&gt;<br></code></pre></td></tr></table></figure><p>5.service包（service接口和实现方法），在实现方法中定义属性StudentDao，&#x3D;&#x3D;并给set方法&#x3D;&#x3D;</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> tt.twinkle.service.impl;<br><br><span class="hljs-keyword">import</span> tt.twinkle.dao.StudentDao;<br><span class="hljs-keyword">import</span> tt.twinkle.entity.Student;<br><span class="hljs-keyword">import</span> tt.twinkle.service.Service;<br><br><span class="hljs-keyword">import</span> java.util.List;<br><br><span class="hljs-comment">//相当于做了个封装</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ServiceImpl</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Service</span> &#123;<br><br>    <span class="hljs-comment">//定义StudentDao接口</span><br>    <span class="hljs-keyword">private</span> StudentDao studentDao;<br>    <span class="hljs-comment">//设值注入</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setStudentDao</span><span class="hljs-params">(StudentDao studentDao)</span> &#123;<br>        <span class="hljs-built_in">this</span>.studentDao = studentDao;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">addStudent</span><span class="hljs-params">(Student student)</span> &#123;<br>        <span class="hljs-keyword">return</span> studentDao.insertStudent(student);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> List&lt;Student&gt; <span class="hljs-title function_">findAllStudent</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> studentDao.selectStudent();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>6.spring的主配置文件ApplicationContext.xml</p><!--在这里得到的myStudentService是一个动态代理对象，这是为什么？？？--><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs java">&lt;?xml version=<span class="hljs-string">&quot;1.0&quot;</span> encoding=<span class="hljs-string">&quot;UTF-8&quot;</span>?&gt;<br>&lt;beans xmlns=<span class="hljs-string">&quot;http://www.springframework.org/schema/beans&quot;</span><br>       xmlns:xsi=<span class="hljs-string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span><br>       xmlns:context=<span class="hljs-string">&quot;http://www.springframework.org/schema/context&quot;</span><br>       xsi:schemaLocation=<span class="hljs-string">&quot;http://www.springframework.org/schema/beans</span><br><span class="hljs-string">       http://www.springframework.org/schema/beans/spring-beans.xsd</span><br><span class="hljs-string">       http://www.springframework.org/schema/context</span><br><span class="hljs-string">       https://www.springframework.org/schema/context/spring-context.xsd&quot;</span>&gt;<br><br><br>&lt;!--    Druid数据源的配置--&gt;<br>    &lt;context:property-placeholder location=<span class="hljs-string">&quot;classpath:jdbc.properties&quot;</span>/&gt;<br><br>    &lt;bean id=<span class="hljs-string">&quot;dataSource&quot;</span> class=<span class="hljs-string">&quot;com.alibaba.druid.pool.DruidDataSource&quot;</span> init-method=<span class="hljs-string">&quot;init&quot;</span> destroy-method=<span class="hljs-string">&quot;close&quot;</span>&gt;<br>        &lt;property name=<span class="hljs-string">&quot;url&quot;</span> value=<span class="hljs-string">&quot;$&#123;jdbc.url&#125;&quot;</span>/&gt;<br>        &lt;property name=<span class="hljs-string">&quot;username&quot;</span> value=<span class="hljs-string">&quot;$&#123;jdbc.username&#125;&quot;</span>/&gt;<br>        &lt;property name=<span class="hljs-string">&quot;password&quot;</span> value=<span class="hljs-string">&quot;$&#123;jdbc.password&#125;&quot;</span>/&gt;<br>    &lt;/bean&gt;<br><br>&lt;!--最终创建出来的是SqlSessionFactory,需要包含mybatix.xml配置文件的信息和数据库信息--&gt;<br>    &lt;bean id=<span class="hljs-string">&quot;sqlSessionFactory&quot;</span> class=<span class="hljs-string">&quot;org.mybatis.spring.SqlSessionFactoryBean&quot;</span>&gt;<br>        &lt;property name=<span class="hljs-string">&quot;dataSource&quot;</span> ref=<span class="hljs-string">&quot;dataSource&quot;</span>/&gt;<br>        &lt;property name=<span class="hljs-string">&quot;configLocation&quot;</span> value=<span class="hljs-string">&quot;classpath:mybatis.xml&quot;</span>/&gt;<br>    &lt;/bean&gt;<br><br><br>&lt;!--    自动生成mapper代理对象,注册mapper扫描配置器，需要sqlSession和StudentDao.class--&gt;<br>&lt;!--    <span class="hljs-type">StudentDao</span> <span class="hljs-variable">mapper</span> <span class="hljs-operator">=</span> sqlSession.getMapper(StudentDao.class);--&gt;<br>    &lt;bean class=<span class="hljs-string">&quot;org.mybatis.spring.mapper.MapperScannerConfigurer&quot;</span>&gt;<br>        &lt;property name=<span class="hljs-string">&quot;sqlSessionFactoryBeanName&quot;</span> value=<span class="hljs-string">&quot;sqlSessionFactory&quot;</span>/&gt;<br>&lt;!-- 包中每个接口都执行一次getMapper()方法，得到动态代理对象，命名是接口名的首字母小写--&gt;<br>        &lt;property name=<span class="hljs-string">&quot;basePackage&quot;</span> value=<span class="hljs-string">&quot;tt.twinkle.dao&quot;</span>/&gt;<br>    &lt;/bean&gt;<br><br>&lt;!-- 自动生成ServiceImpl对象，注入StudentDao值（mapper扫描配置器创建的），<br>        这里studentDao名称是StudentDao首字母小写--&gt;<br>    &lt;bean id=<span class="hljs-string">&quot;myStudentService&quot;</span> class=<span class="hljs-string">&quot;tt.twinkle.service.impl.ServiceImpl&quot;</span>&gt;<br>        &lt;property name=<span class="hljs-string">&quot;studentDao&quot;</span> ref=<span class="hljs-string">&quot;studentDao&quot;</span>/&gt;<br>    &lt;/bean&gt;<br><br>&lt;/beans&gt;<br></code></pre></td></tr></table></figure><p>7.测试代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">String</span> <span class="hljs-variable">config</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;ApplicationContext.xml&quot;</span>;<br><span class="hljs-type">ApplicationContext</span> <span class="hljs-variable">ac</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ClassPathXmlApplicationContext</span>(config);<br><span class="hljs-comment">//得到的是 ServiceImpl对象，向上转型，这个对象调用方法，内部是使用StudentDao来调用方法</span><br><span class="hljs-type">Service</span> <span class="hljs-variable">service</span> <span class="hljs-operator">=</span> (Service) ac.getBean(<span class="hljs-string">&quot;myStudentService&quot;</span>);<br><br><span class="hljs-comment">//等同于StudentDao.insertStudent(student)</span><br>service.addStudent(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Student</span>(<span class="hljs-string">&quot;Jeffery&quot;</span>, <span class="hljs-number">1010</span>, <span class="hljs-string">&quot;twinkelx@126.com&quot;</span>, <span class="hljs-number">30</span>));<br><br>List&lt;Student&gt; students = service.findAllStudent();<br><span class="hljs-keyword">for</span>(Student student:students)&#123;<br>    System.out.println(student);<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="五、事务"><a href="#五、事务" class="headerlink" title="五、事务"></a>五、事务</h1><h2 id="1-概念"><a href="#1-概念" class="headerlink" title="1.概念"></a>1.概念</h2><p>事务是指一组sql语句的集合，多条sql语句可能是insert、update、select、delect，这些sql语句的执行是一致的（作为一个整体执行）。 </p><p>1.管理事务的是：事务管理器PlatformTransactionManager接口对象和其实现类</p><p>2.Spring事务的默认回滚方式是：</p><p>​    ➢ 发生&#x3D;&#x3D;运行时异常和error时回滚&#x3D;&#x3D;；</p><p>​    ➢ 发生&#x3D;&#x3D;编译（受查异常）异常提交&#x3D;&#x3D;。</p><p>3.spring事务有统一的模型</p><p>​        1）指定事务管理器的实现类，<bean></bean></p><p>​            ➢ &#x3D;&#x3D;DataSourceTransactionManager&#x3D;&#x3D;：使用 JDBC 或 MyBatis 进行数据库操作时使用。<br>​            ➢ HibernateTransactionManager：使用 Hibernate 进行持久化数据时使用。</p><p>​        2）指定哪些类、哪些方法需要加入事务的功能</p><p>​        3）指定方法需要的隔离级别、传播行为、超时时间</p><h2 id="2-演示（以超市销售为例）"><a href="#2-演示（以超市销售为例）" class="headerlink" title="2.演示（以超市销售为例）"></a>2.演示（以超市销售为例）</h2><p>前提代码：数据库有两张表goods和sale，goods表示库存，sale表示销售记录</p><p>需要修改的部分：当卖出的商品不在goods内，或者超过goods的库存值，则goods无法update，但是此时sale表格已经有数据更新（虽然这个逻辑不通，但是为了演示）。</p><p>使用事务：将goods表和sale表更新放在同一个事务中，只要有哪个表的操作出现异常，则返回上一步正常状态。</p><p>spring事务处理方案：</p><h3 id="1-注解（适合中小项目）-Transactional（针对方法而言的）"><a href="#1-注解（适合中小项目）-Transactional（针对方法而言的）" class="headerlink" title="(1)注解（适合中小项目）@Transactional（针对方法而言的）"></a>(1)注解（适合中小项目）@Transactional（针对方法而言的）</h3><p>使用Spring框架提供的@Transactional注解增加事务，放在&#x3D;&#x3D;public&#x3D;&#x3D;&#x3D;&#x3D;方法&#x3D;&#x3D;上，表示当前方法具有事务（表需要同步操作）</p><p>ApplicationContext.xml中加入：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java">&lt;!--    声明事务管理器对象--&gt;<br>&lt;bean id=<span class="hljs-string">&quot;transactionManager&quot;</span>  class=<span class="hljs-string">&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;</span>&gt;<br>&lt;property name=<span class="hljs-string">&quot;dataSource&quot;</span> ref=<span class="hljs-string">&quot;dataSource&quot;</span>/&gt;<br>&lt;/bean&gt;<br><br>&lt;!--    开启事务注解驱动，告诉spring使用注解管理事务，创建代理对象--&gt;<br>&lt;tx:annotation-driven transaction-manager=<span class="hljs-string">&quot;transactionManager&quot;</span>/&gt;<br></code></pre></td></tr></table></figure><p>@Transactional注解的相关属性赋值（默认赋值，或者可以直接写@Transactional）</p><!--在@Around的基础上实现的--><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//rollbackFor：表示发生指定的异常一定回滚（如果这个默认值里有编译时异常，也会回滚的），值为XXX.class</span><br><span class="hljs-meta">@Transactional(</span><br><span class="hljs-meta">        propagation = Propagation.REQUIRED,</span><br><span class="hljs-meta">        isolation = Isolation.DEFAULT,</span><br><span class="hljs-meta">        readOnly = false,</span><br><span class="hljs-meta">        rollbackFor = &#123;</span><br><span class="hljs-meta">                NullPointerException.class, NotEnoughException.class</span><br><span class="hljs-meta">        &#125;</span><br><span class="hljs-meta">)</span><br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//测试文件</span><br><span class="hljs-type">String</span> <span class="hljs-variable">config</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;ApplicationContext.xml&quot;</span>;<br><span class="hljs-type">ApplicationContext</span> <span class="hljs-variable">ac</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ClassPathXmlApplicationContext</span>(config);<br><span class="hljs-type">BuyGoodService</span> <span class="hljs-variable">buyGoodService</span> <span class="hljs-operator">=</span> (BuyGoodService) ac.getBean(<span class="hljs-string">&quot;buyService&quot;</span>);<br>buyGoodService.buy(<span class="hljs-number">1001</span>,<span class="hljs-number">2</span>);<br></code></pre></td></tr></table></figure><h3 id="2-AspectJ-（大项目，规范化）"><a href="#2-AspectJ-（大项目，规范化）" class="headerlink" title="(2)AspectJ （大项目，规范化）"></a>(2)AspectJ （大项目，规范化）</h3><p>使用xml文件来指定需要用到事务的方法，以及配置相关属性</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//声明事务管理器对象</span><br>&lt;bean id=<span class="hljs-string">&quot;transactionManager&quot;</span> class=<span class="hljs-string">&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;</span>&gt;<br>    &lt;property name=<span class="hljs-string">&quot;dataSource&quot;</span> ref=<span class="hljs-string">&quot;dataSource&quot;</span>/&gt;<br>&lt;/bean&gt;<br>    <br><span class="hljs-comment">//在属性里定义需要用到事务的方法，以及事务的传播行为propagation、隔离方式isolation、超时时间timeout、rollback-for回滚</span><br>    <br>&lt;tx:advice id=<span class="hljs-string">&quot;myAdvice&quot;</span> transaction-manager=<span class="hljs-string">&quot;transactionManager&quot;</span>&gt;<br>    &lt;tx:attributes&gt;<br>        <span class="hljs-comment">//name：方法名称（不带包和类名）或者通配符*</span><br>        <span class="hljs-comment">//rollback-for：全限定类型</span><br>        &lt;tx:method name=<span class="hljs-string">&quot;buy&quot;</span> propagation=<span class="hljs-string">&quot;REQUIRED&quot;</span> isolation=<span class="hljs-string">&quot;DEFAULT&quot;</span> read-              only=<span class="hljs-string">&quot;false&quot;</span> rollback-                                            <span class="hljs-keyword">for</span>=<span class="hljs-string">&quot;java.lang.NullPointerException,tt.twinkle.NotEnoughException&quot;</span>/&gt;<br>    &lt;/tx:attributes&gt;<br>&lt;/tx:advice&gt;<br>    <br>&lt;!--    声明哪些类需要应用事务，并关联方法和类，如果两个关联上了，则生成动态代理对象--&gt;<br>&lt;aop:config&gt;<br>&lt;!--        这边举例，任意包中service包及子包下的所有方法--&gt;<br>    &lt;aop:pointcut id=<span class="hljs-string">&quot;servicePt&quot;</span> expression=<span class="hljs-string">&quot;execution(* *..service..*.*(..))&quot;</span>/&gt;<br>&lt;!--        配置增强器，关联myAdvice和servicePt--&gt;<br>    &lt;aop:advisor advice-ref=<span class="hljs-string">&quot;myAdvice&quot;</span> pointcut-ref=<span class="hljs-string">&quot;servicePt&quot;</span>/&gt;<br>&lt;/aop:config&gt;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Spring全家桶</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>SpringBoot笔记</title>
    <link href="/2022/02/12/SpringBoot/"/>
    <url>/2022/02/12/SpringBoot/</url>
    
    <content type="html"><![CDATA[<h1 id="一、SpringBoot入门"><a href="#一、SpringBoot入门" class="headerlink" title="一、SpringBoot入门"></a>一、SpringBoot入门</h1><p>&#x3D;&#x3D;写在前面的概念&#x3D;&#x3D;</p><p><strong>组件</strong>和<strong>类</strong>的关系:符合某种规范的类的组合构成组件</p><p><a href="https://docs.spring.io/spring-boot/docs/2.3.12.RELEASE/reference/html/">SpringBoot官方文档</a></p><h2 id="1-Spring-Boot简介"><a href="#1-Spring-Boot简介" class="headerlink" title="1.Spring Boot简介"></a>1.Spring Boot简介</h2><p>简化Spring应用开发的一个框架</p><p>整个Spring技术栈的大整合</p><p>J2EE开发的一站式解决方案 </p><h2 id="2-微服务"><a href="#2-微服务" class="headerlink" title="2. 微服务"></a>2. 微服务</h2><h2 id="3-Spring-Boot-HelloWorld"><a href="#3-Spring-Boot-HelloWorld" class="headerlink" title="3.Spring Boot HelloWorld!"></a>3.Spring Boot HelloWorld!</h2><h3 id="1-创建一个maven工程"><a href="#1-创建一个maven工程" class="headerlink" title="1.创建一个maven工程"></a>1.创建一个maven工程</h3><h3 id="2-导入Spring-Boot相关的依赖"><a href="#2-导入Spring-Boot相关的依赖" class="headerlink" title="2.导入Spring Boot相关的依赖"></a>2.导入Spring Boot相关的依赖</h3><figure class="highlight xml"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></div></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">parent</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-parent<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.5.9.RELEASE<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">parent</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">dependencies</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependencies</span>&gt;</span><br></code></pre></td></tr></table></figure><h3 id="3-编写主程序，启动Spring-Boot应用"><a href="#3-编写主程序，启动Spring-Boot应用" class="headerlink" title="3.编写主程序，启动Spring Boot应用"></a>3.编写主程序，启动Spring Boot应用</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@SpringBootApplication</span>来标注一个主程序</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">@SpringBootApplication</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">HelloWorldMainApplication</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-comment">//应用启动起来</span><br>        SpringApplication.run(HelloWorldMainApplication.class,args);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="4-编写相关的Controller、Service"><a href="#4-编写相关的Controller、Service" class="headerlink" title="4.编写相关的Controller、Service"></a>4.编写相关的Controller、Service</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Controller</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">HelloController</span> &#123;<br>    <span class="hljs-meta">@ResponseBody</span><br>    <span class="hljs-meta">@RequestMapping(&quot;/hello&quot;)</span><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">hello</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Hello World!&quot;</span>;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//将@Controller和@ResponseBody合起来</span><br><span class="hljs-meta">@RestController</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">HelloController</span> &#123;<br>    <span class="hljs-meta">@RequestMapping(&quot;/hello&quot;)</span><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">hello</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Hello World!&quot;</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="5-运行主测试程序"><a href="#5-运行主测试程序" class="headerlink" title="5.运行主测试程序"></a>5.运行主测试程序</h3><h3 id="6-简化部署（运行jar包）"><a href="#6-简化部署（运行jar包）" class="headerlink" title="6.简化部署（运行jar包）"></a>6.简化部署（运行jar包）</h3><p>（1）导入maven插件</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs xml"> <span class="hljs-comment">&lt;!--将应用打包成一个可执行的jar包--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">build</span>&gt;</span> <br>    <span class="hljs-tag">&lt;<span class="hljs-name">plugins</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">plugin</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-maven-plugin<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">plugin</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">plugins</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">build</span>&gt;</span><br></code></pre></td></tr></table></figure><p>将应用打成jar包，双击package，生成的jar包一般在target目录下</p><img src="/2022/02/12/SpringBoot/image-20210929162913533.png" alt="image-20210929162913533" style="zoom:67%;"><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-regexp">//</span>执行jar包<br>java -jar xxx.jar<br></code></pre></td></tr></table></figure><h2 id="4-HelloWorld探究"><a href="#4-HelloWorld探究" class="headerlink" title="4.HelloWorld探究"></a>4.HelloWorld探究</h2><h3 id="1-POM文件"><a href="#1-POM文件" class="headerlink" title="1.POM文件"></a>1.POM文件</h3><h4 id="1-父项目"><a href="#1-父项目" class="headerlink" title="1.父项目"></a>1.父项目</h4><p>Spring Boot的&#x3D;&#x3D;版本仲裁中心&#x3D;&#x3D;，</p><p>以后导入依赖默认是不需要写版本的（没有在dependencies里面管理的依赖需要申明版本号）</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs xml">//需要手动加入的依赖<br><span class="hljs-tag">&lt;<span class="hljs-name">parent</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-parent<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.5.9.RELEASE<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">parent</span>&gt;</span><br><br>//它的父项目是<br><span class="hljs-tag">&lt;<span class="hljs-name">parent</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-dependencies<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.5.9.RELEASE<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">relativePath</span>&gt;</span>../../spring-boot-dependencies<span class="hljs-tag">&lt;/<span class="hljs-name">relativePath</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">parent</span>&gt;</span><br>//在spring-boot-dependencies中有很多<span class="hljs-tag">&lt;<span class="hljs-name">properties</span>&gt;</span><br></code></pre></td></tr></table></figure><h4 id="2-启动器"><a href="#2-启动器" class="headerlink" title="2.启动器"></a>2.启动器</h4><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><p>spring-boot-starter-web:</p><p>​        spring-boot-starter：&#x3D;&#x3D;spring-boot&#x3D;&#x3D;&#x3D;&#x3D;场景启动器&#x3D;&#x3D;，帮助导入了web模块正常运行所依赖的组件；</p><p>Spring Boot将所有的功能场景都抽取出来，做成一个个的starters（启动器），只需要在项目中引入这些starter，相关的场景的所有依赖都会导入进来，依赖的版本由版本仲裁中心自动控制</p><h3 id="2-主程序类，主入口类"><a href="#2-主程序类，主入口类" class="headerlink" title="2.主程序类，主入口类"></a>2.主程序类，主入口类</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@SpringBootApplication</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">HelloWorldMainApplication</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        SpringApplication.run(HelloWorldMainApplication.class,args);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="SpringBootApplication"><a href="#SpringBootApplication" class="headerlink" title="@SpringBootApplication"></a>@SpringBootApplication</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//如果引用了某个工具module，但是不想启动mybatis的功能，就可以这样操作：</span><br><span class="hljs-meta">@SpringBootApplication(exclude = &#123;DataSourceAutoConfiguration.class&#125;)</span><br></code></pre></td></tr></table></figure><p>Spring Boot应用标注在某个类上，说明这个类是SpringBoot的主配置类，SpringBoot就应该运行这个类的main方法来启动SpringBoot</p><p>​    该注解中有以下组合注解：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Target(&#123;ElementType.TYPE&#125;)</span><br><span class="hljs-meta">@Retention(RetentionPolicy.RUNTIME)</span><br><span class="hljs-meta">@Documented</span><br><span class="hljs-meta">@Inherited</span><br><span class="hljs-meta">@SpringBootConfiguration</span><br><span class="hljs-meta">@EnableAutoConfiguration</span><br><span class="hljs-meta">@ComponentScan(excludeFilters =</span><br><span class="hljs-meta">    &#123;@Filter(type = FilterType.CUSTOM,classes = &#123;TypeExcludeFilter.class&#125;),</span><br><span class="hljs-meta">     @Filter(type = FilterType.CUSTOM,classes = &#123;AutoConfigurationExcludeFilter.class&#125;</span><br><span class="hljs-meta">)&#125;</span><br><span class="hljs-meta">)</span><br><span class="hljs-keyword">public</span> <span class="hljs-meta">@interface</span> SpringBootApplication &#123;<br></code></pre></td></tr></table></figure><h5 id="SpringBootConfiguration"><a href="#SpringBootConfiguration" class="headerlink" title="@SpringBootConfiguration"></a>@SpringBootConfiguration</h5><p>Spring Boot的配置类：</p><p>​        表示这是一个Spring Boot的配置类</p><p>​        @Configuration：配置类上标注这个注解</p><p>​                    配置类 ——-  配置文件；配置类也是容器中的一个组件；@Component</p><h5 id="x3D-x3D-EnableAutoConfiguration-x3D-x3D"><a href="#x3D-x3D-EnableAutoConfiguration-x3D-x3D" class="headerlink" title="&#x3D;&#x3D;@EnableAutoConfiguration&#x3D;&#x3D;"></a>&#x3D;&#x3D;<strong>@EnableAutoConfiguration</strong>&#x3D;&#x3D;</h5><p>开启自动配置功能，</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@AutoConfigurationPackage</span><br><span class="hljs-meta">@Import(&#123;EnableAutoConfigurationImportSelector.class&#125;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-meta">@interface</span> EnableAutoConfiguration &#123;<br></code></pre></td></tr></table></figure><h6 id="AutoConfigurationPackage"><a href="#AutoConfigurationPackage" class="headerlink" title="@AutoConfigurationPackage"></a>@AutoConfigurationPackage</h6><p>​        自动配置包；@<strong>Import({Registrar.class})</strong>  Spring的底层注解，给容器中导入一个组件，导入的组件由Registrar.class指定</p><p>​        &#x3D;&#x3D;将主配置类(@SpringBootApplication标注的类)的所在包及下面所有子包里面的所有组件扫描到Spring容器中；&#x3D;&#x3D;</p><img src="/2022/02/12/SpringBoot/image-20210929200232498.png" alt="image-20210929200232498" style="zoom:67%;"><h6 id="x3D-x3D-Import-AutoConfigurationImportSelector-class-x3D-x3D"><a href="#x3D-x3D-Import-AutoConfigurationImportSelector-class-x3D-x3D" class="headerlink" title="&#x3D;&#x3D;@Import({AutoConfigurationImportSelector.class})&#x3D;&#x3D;"></a>&#x3D;&#x3D;@Import({AutoConfigurationImportSelector.class})&#x3D;&#x3D;</h6><p>​                    导入组件的选择器</p><p>​                AutoConfigurationImportSelector类中有一个selectImports()方法</p><p>​                    所有需要导入的组件以全类名的方式返回，这些组件就会被添加到容器汇总</p><p>​                    会给容器导入非常多的自动配置类(XXAutoConfiguration)</p><img src="/2022/02/12/SpringBoot/image-20210929201811994.png" alt="image-20210929201811994" style="zoom:80%;"><p>​    这些个自动配置类，是从类路径下的META-INF&#x2F;spring.factories中获取的</p><img src="/2022/02/12/SpringBoot/image-20210929202523657.png" alt="image-20210929202523657" style="zoom:80%;"><img src="/2022/02/12/SpringBoot/image-20210929202608764.png" alt="image-20210929202608764 " style="zoom:80%;"><img src="/2022/02/12/SpringBoot/image-20210929203031651.png" alt="image-20210929203031651" style="zoom:80%;"><img src="/2022/02/12/SpringBoot/image-20211007163725903.png" alt="image-20211007163725903 " style="zoom:67%;"><p>&#x3D;&#x3D;Spring Boot在启动的时候，从类路径下的META-INF&#x2F;spring.factories中获取EnableAutoConfiguration指定的值，将这些值作为自动配置类导入到容器中，自动配置类就生效了，帮助进行自动配置工作&#x3D;&#x3D;</p><h3 id="x3D-x3D-3-自动配置精讲-x3D-x3D"><a href="#x3D-x3D-3-自动配置精讲-x3D-x3D" class="headerlink" title="&#x3D;&#x3D;3.自动配置精讲&#x3D;&#x3D;"></a>&#x3D;&#x3D;3.自动配置精讲&#x3D;&#x3D;</h3><h3 id="（1）自动配置类"><a href="#（1）自动配置类" class="headerlink" title="（1）自动配置类"></a>（1）自动配置类</h3><p>每一个自动配置类都能够进行自动配置，以<strong>HttpEncodingAutoConfiguration</strong>为例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//表示这是一个配置类，和bean.xml配置文件一样，可以给容器中添加组件</span><br><span class="hljs-meta">@Configuration(proxyBeanMethods = false)</span><br><span class="hljs-comment">//启动指定类的ConfigurationProperties功能</span><br><span class="hljs-meta">@EnableConfigurationProperties(&#123;ServerProperties.class&#125;)</span><br><span class="hljs-comment">//Spring底层@Conditional注解，如果满足指定条件，则整个配置类里面的配置就会生效（此时是判断当前应用是否是web应用，如果是，则当前配置类生效）</span><br><span class="hljs-meta">@ConditionalOnWebApplication(type = Type.SERVLET)</span><br><span class="hljs-comment">//判断当前项目有没有CharacterEncodingFilter类</span><br><span class="hljs-meta">@ConditionalOnClass(&#123;CharacterEncodingFilter.class&#125;)</span><br><span class="hljs-comment">//判断配置文件中是否存在server.servlet.encoding配置，matchIfMissing = true表示如果没有配置server.servlet.encoding，配置文件也是生效的</span><br><span class="hljs-meta">@ConditionalOnProperty(</span><br><span class="hljs-meta">    prefix = &quot;server.servlet.encoding&quot;,</span><br><span class="hljs-meta">    value = &#123;&quot;enabled&quot;&#125;,</span><br><span class="hljs-meta">    matchIfMissing = true</span><br><span class="hljs-meta">)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">HttpEncodingAutoConfiguration</span> &#123;<br>    <span class="hljs-comment">//该属性是ServerProperties（见下面有参构造），已经和SpringBoot的配置文件映射了</span><br>    <span class="hljs-comment">//【上方的@EnableConfigurationProperties】</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Encoding properties;<br><br>    <span class="hljs-comment">//只有一个有参构造，参数的值会直接从容器中拿</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">HttpEncodingAutoConfiguration</span><span class="hljs-params">(ServerProperties properties)</span> &#123;<br>        <span class="hljs-built_in">this</span>.properties = properties.getServlet().getEncoding();<br>    &#125;<br><br>    <span class="hljs-comment">//@Bean 给容器添加一个组件，且这个组件的某些值需要从Properties中获取，这个Properties可以直接从容器中拿</span><br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-meta">@ConditionalOnMissingBean</span><br>    <span class="hljs-keyword">public</span> CharacterEncodingFilter <span class="hljs-title function_">characterEncodingFilter</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-type">CharacterEncodingFilter</span> <span class="hljs-variable">filter</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">OrderedCharacterEncodingFilter</span>();<br>        filter.setEncoding(<span class="hljs-built_in">this</span>.properties.getCharset().name());<br>        filter.setForceRequestEncoding(<br>          <span class="hljs-built_in">this</span>.properties.shouldForce(org.springframework.boot.web.servlet.server.Encoding.Type.REQUEST));<br>        filter.setForceResponseEncoding(<br>           <span class="hljs-built_in">this</span>.properties.shouldForce(org.springframework.boot.web.servlet.server.Encoding.Type.RESPONSE));<br>        <span class="hljs-keyword">return</span> filter;<br>    &#125;<br></code></pre></td></tr></table></figure><p>根据当前不同的条件【@Conditional】判断，决定这个配置类是否生效</p><p>一旦这个配置类生效，这个配置类就会给容器添加各种组件，这些组件的属性都是从对应的properties类中获取的，这些类里面的每个属性都是和配置文件绑定的。</p><p>所有在配置文件能配置的属性，都在&#x3D;&#x3D;xxxxProperties&#x3D;&#x3D;类中封装着，配置文件能配置什么就可以参照某个功能对应的这个属性类</p><p>（ServerProperties就表示可以在配置文件中写server.xxx来配置相关的属性）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@ConfigurationProperties(</span><br><span class="hljs-meta">    prefix = &quot;server&quot;,</span><br><span class="hljs-meta">    ignoreUnknownFields = true</span><br><span class="hljs-meta">)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ServerProperties</span> &#123;<br></code></pre></td></tr></table></figure><h3 id="（2）自动配置总结（SpringBoot精髓）："><a href="#（2）自动配置总结（SpringBoot精髓）：" class="headerlink" title="（2）自动配置总结（SpringBoot精髓）："></a>（2）<strong>自动配置总结（SpringBoot精髓）：</strong></h3><p>1.Spring Boot启动会加载大量的自动配置类</p><p>2.看需要的功能有没有Spring Boot默认写好的自动配置类</p><p>3.看自动配置类中到底配置类哪些组件（带有@Bean标签的）</p><p>4.给容器自动配置类添加组件的时候，会从properties类中获取某些属性，我们就可以在配置文件中指定这些属性值</p><h3 id="（3）细节"><a href="#（3）细节" class="headerlink" title="（3）细节"></a>（3）细节</h3><p>1.@Conditional派生注解</p><p>作用：必须是@Conditional指定的条件成立，才给容器中添加组件</p><table><thead><tr><th>@Conditional扩展注解</th><th>作用（判断是否满足当前指定条件）</th></tr></thead><tbody><tr><td>@ConditionalOnjava</td><td>系统java版本是否符合要求</td></tr><tr><td>@ConditionalOnBean</td><td>容器中是否存在指定的bean</td></tr><tr><td>@ConditionalOnMissingBean</td><td>容器中是否没有指定的bean</td></tr><tr><td>@ConditionalOnExpresion</td><td>满足SpEL表达式</td></tr><tr><td>@ConditionalOnClass</td><td>系统中有指定的类</td></tr><tr><td>@ConditionalOnMissingClass</td><td>系统中没有指定的类</td></tr><tr><td>@ConditionalOnSingleCandidate</td><td>容器中只有一个指定的bean，或者这个bean是首选bean</td></tr><tr><td>@ConditionalOnProperty</td><td>系统中指定的属性是否有指定的值</td></tr><tr><td>@ConditionalOnResource</td><td>类路径下是否存在指定资源文件</td></tr><tr><td>@ConditionalOnWebApplication</td><td>当前是web环境</td></tr><tr><td>@ConditionalOnNotWebApplication</td><td>当前不是web环境</td></tr><tr><td>@ConditionalOnJndi</td><td>JNDI存在指定项</td></tr></tbody></table><p>知道哪些自动配置类生效：debug&#x3D;true（配置文件）</p><h2 id="5-使用Spring-Initializer快速创建Spring-Boot项目"><a href="#5-使用Spring-Initializer快速创建Spring-Boot项目" class="headerlink" title="5.使用Spring Initializer快速创建Spring Boot项目"></a>5.使用Spring Initializer快速创建Spring Boot项目</h2><p>IDEA支持使用Spring的项目创建向导快速创建一个Spring Boot项目</p><p>选择需要的模块，向导会联网创建Spring Boot项目</p><ul><li><p>默认生成的Spring Boot项目的主程序已经写好</p></li><li><p>resources文件夹中的目录结构：</p><ul><li><p>static：保存所有的静态资源，js  css  images；</p></li><li><p>templates：保存所有的模板页面（Spring Boot默认jar包使用嵌入式的Tomcat，默认不支持JSP页面），可以使用模板引擎（freemarker  thymeleaf）</p></li><li><p>application.properties：Spring Boot应用的配置文件</p></li></ul></li></ul><h1 id="二、配置文件"><a href="#二、配置文件" class="headerlink" title="二、配置文件"></a>二、配置文件</h1><h2 id="1-配置文件"><a href="#1-配置文件" class="headerlink" title="1.配置文件"></a>1.配置文件</h2><p>SpringBoot使用一个全局的配置文件，配置文件名是固定的</p><ul><li><p>application.properties</p></li><li><p>application.yml</p><p>yml是YAML(YAML Ain’t Markup Language)语言的文件，以数据为中心</p></li></ul><p>配置文件的作用：修改Spring Boot自动配置的默认值</p><p>YAML：配置例子</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">server:</span><br><span class="hljs-attr">port:</span> <span class="hljs-number">8081</span><br></code></pre></td></tr></table></figure><p>XML：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">server</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">port</span>&gt;</span>8081<span class="hljs-tag">&lt;/<span class="hljs-name">port</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">server</span>&gt;</span><br></code></pre></td></tr></table></figure><h2 id="2-YAML语法"><a href="#2-YAML语法" class="headerlink" title="2.YAML语法"></a>2.YAML语法</h2><h3 id="1-基本语法"><a href="#1-基本语法" class="headerlink" title="1.基本语法"></a>1.基本语法</h3><p>k:(space)v：表示一对键值对，以空格的缩进来控制层级关系，只要是左对齐的一列数据，都是同一个层级的</p><p>​    属性和值也是大小写敏感</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs yml"><span class="hljs-attr">server:</span><br><span class="hljs-string">port:(空格)8081</span><br><span class="hljs-string">path:(空格)/hello</span><br></code></pre></td></tr></table></figure><h3 id="2-值的写法"><a href="#2-值的写法" class="headerlink" title="2.值的写法"></a>2.值的写法</h3><h4 id="1-字面量：普通的值（数字、字符串、布尔类型等）"><a href="#1-字面量：普通的值（数字、字符串、布尔类型等）" class="headerlink" title="1.字面量：普通的值（数字、字符串、布尔类型等）"></a>1.字面量：普通的值（数字、字符串、布尔类型等）</h4><p>k: v: 值——键值对的写法</p><p>注意：</p><ul><li><p>字符串默认不需要加上单引号或双引号</p></li><li><p>“”：加上双引号，则变成转义字符</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">name:</span> <span class="hljs-string">&quot;zhangsan \n lisi&quot;</span><br><span class="hljs-string">//输出：zhangsan</span> <span class="hljs-string">换行</span> <span class="hljs-string">lisi</span><br></code></pre></td></tr></table></figure></li><li><p>‘’：加上单引号，则还是普通字符</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">name:</span> <span class="hljs-string">&#x27;zhangsan \n lisi&#x27;</span><br><span class="hljs-string">//输出：</span> <span class="hljs-string">zhangsan</span> <span class="hljs-string">\n</span> <span class="hljs-string">lisi</span> <br></code></pre></td></tr></table></figure></li></ul><h4 id="2-对象、Map（属性和值）（键值对）"><a href="#2-对象、Map（属性和值）（键值对）" class="headerlink" title="2.对象、Map（属性和值）（键值对）"></a>2.对象、Map（属性和值）（键值对）</h4><p>k: v: 值，在下一行写对象的属性和值</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">friends:</span><br><span class="hljs-string">lastName:(空格)zhangsan</span><br><span class="hljs-string">age:(空格)20</span><br></code></pre></td></tr></table></figure><p>一行内写法</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">friends:</span> &#123;<span class="hljs-string">lastName:(空格)zhangsan</span>,<span class="hljs-string">age:(空格)20</span>&#125;<br></code></pre></td></tr></table></figure><h4 id="3-数组（List、Set）"><a href="#3-数组（List、Set）" class="headerlink" title="3.数组（List、Set）"></a>3.数组（List、Set）</h4><p>用-(空格)值来表示数组中的一个元素</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">pets:</span><br><span class="hljs-string">(空格)-(空格)cat</span><br><span class="hljs-string">(空格)-(空格)dog</span><br><span class="hljs-string">(空格)-(空格)pig</span><br></code></pre></td></tr></table></figure><p>一行内写法</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-string">pets:(空格)[cat,dog,pig]</span><br></code></pre></td></tr></table></figure><h2 id="3-配置文件注入-x3D-x3D-ConfigurationProperties-x3D-x3D"><a href="#3-配置文件注入-x3D-x3D-ConfigurationProperties-x3D-x3D" class="headerlink" title="3.配置文件注入&#x3D;&#x3D;@ConfigurationProperties&#x3D;&#x3D;"></a>3.配置文件注入&#x3D;&#x3D;@ConfigurationProperties&#x3D;&#x3D;</h2><p>注：</p><ul><li><p>@ConfigurationProperties：配置文件中获取的指定的值和bean（姑且理解为实体类）的属性绑定起来</p></li><li><p>一般和@Configuration注解联合使用</p></li><li><p>@ConfigurationProperties可以用在类的上方或者方法上方</p></li><li><p>如果在方法的上方使用@ConfigurationProperties，则一般方法上搭配@Bean，并整个类上写@Configuration</p></li><li><p>如果在类的上方使用@ConfigurationProperties，则类的上方搭配@Component</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//@Configuration指明当前类是一个配置类，代替Spring配置文件</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">DruidConfig</span> &#123;<br><br>    <span class="hljs-comment">//方法的上方</span><br>    <span class="hljs-meta">@ConfigurationProperties( prefix = &quot;spring.datasource&quot; )</span><br>    <span class="hljs-comment">//配置文件中获取的指定的值和bean（姑且理解为实体类）的属性绑定起来</span><br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-comment">//@Bean作用将方法的返回值添加到容器中，容器中这个组件默认的id就是方法名，一个@Bean就相当于xml文件中一个&lt;bean&gt;</span><br>    <span class="hljs-keyword">public</span> DataSource <span class="hljs-title function_">druidDataConfig</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">DruidDataSource</span>();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//@Component是在容器中创建实例</span><br><span class="hljs-meta">@Component</span><br><span class="hljs-comment">//类的上方</span><br><span class="hljs-meta">@ConfigurationProperties(prefix = &quot;person&quot;)</span><br><span class="hljs-comment">//@Validated</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span> &#123;<br></code></pre></td></tr></table></figure></li></ul><h3 id="方法一-（yaml文件注入）"><a href="#方法一-（yaml文件注入）" class="headerlink" title="方法一 （yaml文件注入）"></a>方法一 （yaml文件注入）</h3><p>1.application.yaml文件的配置（创建了一个人的对象，并注入了参数）</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">person:</span><br>  <span class="hljs-attr">name:</span> <span class="hljs-string">zhangsan</span><br>  <span class="hljs-attr">age:</span> <span class="hljs-number">18</span><br>  <span class="hljs-attr">boss:</span> <span class="hljs-literal">true</span><br>  <span class="hljs-attr">birth:</span> <span class="hljs-number">1999</span><span class="hljs-string">/4/4</span><br>  <span class="hljs-attr">maps:</span> &#123;<span class="hljs-attr">k1:</span> <span class="hljs-string">v1</span>,<span class="hljs-attr">k2:</span> <span class="hljs-string">v2</span>,<span class="hljs-attr">k3:</span> <span class="hljs-string">v3</span>&#125;<br>  <span class="hljs-attr">objectList:</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-string">lisi</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-string">wangwu</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-number">1111</span><br>  <span class="hljs-attr">dog:</span><br>    <span class="hljs-attr">name:</span> <span class="hljs-string">triky</span><br>    <span class="hljs-attr">age:</span> <span class="hljs-number">2</span><br></code></pre></td></tr></table></figure><p>2.在javaBean文件（实体类）的上方加上@Component和@ConfigurationProperties(prefix&#x3D;”person”)两个注解</p><p>即可以将配置文件的值和实体类的属性绑定起来</p><p>@ConfigurationProperties注解默认从全局配置文件中得到数值</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@ConfigurationProperties</span>告诉SpringBoot将本类中所有的属性和配置文件中相关的配置进行绑定</span><br><span class="hljs-comment"> * (prefix = &quot;person&quot;)。配置文件中哪个(person)下面的属性需要进行映射</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * 只有这个组件是容器中的组件，才能使用容器提供的<span class="hljs-doctag">@ConfigurationProperties</span>功能</span><br><span class="hljs-comment"> * 所以需要在上面加上<span class="hljs-doctag">@Component</span></span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">@Component</span><br><span class="hljs-meta">@ConfigurationProperties(prefix = &quot;person&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span> &#123;<br>    <span class="hljs-keyword">private</span> String name;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> age;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">boolean</span> boss;<br>    <span class="hljs-keyword">private</span> Date birth;<br><br>    <span class="hljs-keyword">private</span> List&lt;Object&gt; objectList;<br>    <span class="hljs-keyword">private</span> Map&lt;String, Object&gt; maps;<br>    <span class="hljs-keyword">private</span> Dog dog;<br></code></pre></td></tr></table></figure><p>3.pom.xml文件中导入配置文件处理器，以后编写配置就会有提示</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-configuration-processor<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">optional</span>&gt;</span>true<span class="hljs-tag">&lt;/<span class="hljs-name">optional</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><img src="/2022/02/12/SpringBoot/image-20211003154145339.png" alt="image-20211003154145339 " style="zoom:80%;"><h3 id="方法二（properties文件注入）"><a href="#方法二（properties文件注入）" class="headerlink" title="方法二（properties文件注入）"></a>方法二（properties文件注入）</h3><p>1.application.properties的配置</p><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs nix">person.<span class="hljs-attr">name=张三</span><br>person.<span class="hljs-attr">age=20</span><br>person.<span class="hljs-attr">birth=1999/04/04</span><br>person.<span class="hljs-attr">boss=false</span><br><span class="hljs-comment">#这个地方如果是object呢？</span><br>person.<span class="hljs-attr">object-list=a,b,c</span><br><br>//Map和对象都需要分属性赋值<br>person.maps.<span class="hljs-attr">k1=v1</span><br>person.maps.<span class="hljs-attr">k2=14</span><br><br>person.dog.<span class="hljs-attr">name=jacky</span><br>person.dog.<span class="hljs-attr">age=2</span><br><br><br></code></pre></td></tr></table></figure><p>2.实体类的配置和上面相同</p><p>3.@Value和@ConfigurationProperties的对比</p><table><thead><tr><th></th><th>@Value</th><th>@ConfigurationProperties</th></tr></thead><tbody><tr><td>功能</td><td>一个个绑定</td><td>批量注入配置文件中的属性</td></tr><tr><td>得到Map和对象的值</td><td>不支持</td><td>支持</td></tr><tr><td>Relaxed binding(松散绑定)</td><td>不支持</td><td>支持</td></tr><tr><td>SpEL</td><td>支持</td><td>不支持</td></tr><tr><td>JSR303数据校验</td><td>不支持</td><td>支持</td></tr></tbody></table><p>松散绑定：lastName和last-name和last_name，结果都是一样的</p><p>使用@value：只需要读从配置文件中读一个数，可以使用</p><p>使用@ConfigurationProperties：专门写了一个javaBean（实体类），进行批量注入</p><h3 id="配置文件注入值数据校验"><a href="#配置文件注入值数据校验" class="headerlink" title="配置文件注入值数据校验"></a>配置文件注入值数据校验</h3><p>一定是使用@ConfigurationProperties注解，采用JSR303数据校验</p><p>@Validated + @Email等</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Component</span><br><span class="hljs-meta">@ConfigurationProperties(prefix = &quot;person&quot;)</span><br><span class="hljs-meta">@Validated</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span> &#123;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * &lt;bean class=&quot;Person&quot;&gt;</span><br><span class="hljs-comment">     *     &lt;property name=&quot;name&quot; value=&quot;字面量/$&#123;key&#125;从环境变量、配置文件中获得的值&quot;/#&#123;SpEL&#125;&gt;&lt;/property&gt;</span><br><span class="hljs-comment">     * &lt;/bean&gt;</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-comment">//name必须是邮箱的格式</span><br>    <span class="hljs-meta">@Email</span><br>    <span class="hljs-keyword">private</span> String name;<br></code></pre></td></tr></table></figure><h3 id="PropertySource和-ImportSource"><a href="#PropertySource和-ImportSource" class="headerlink" title="@PropertySource和@ImportSource"></a>@PropertySource和@ImportSource</h3><p><strong>1.@PropertySource</strong>：加载指定的配置文件</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@ConfigurationProperties</span>告诉SpringBoot将本类中所有的属性和全局配置文件中相关的配置进行绑定</span><br><span class="hljs-comment"> * (prefix = &quot;person&quot;)。配置文件中哪个(person)下面的属性需要进行映射</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * 只有这个组件是容器中的组件，才能使用容器提供的<span class="hljs-doctag">@ConfigurationProperties</span>功能</span><br><span class="hljs-comment"> * 所以需要在上面加上<span class="hljs-doctag">@Component</span></span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@PropertySource</span>(value = &#123;&quot;classpath:person.properties&quot;&#125;)可以读取其他的.properties文件</span><br><span class="hljs-comment"> */</span><br><br><span class="hljs-meta">@PropertySource(value = &#123;&quot;classpath:person.properties&quot;&#125;)</span><br><span class="hljs-meta">@Component</span><br><span class="hljs-meta">@ConfigurationProperties(prefix = &quot;person&quot;)</span><br><span class="hljs-meta">@Validated</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span> &#123;<br></code></pre></td></tr></table></figure><p><strong>2.@ImportSource</strong>：导入Spring的配置文件beans.xml，让配置文件里的内容生效</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//在主程序上加@ImportSource注解</span><br><span class="hljs-meta">@ImportResource(locations = &#123;&quot;classpath:beans.xml&quot;&#125;)</span><br></code></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">beans</span> <span class="hljs-attr">xmlns</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/beans&quot;</span></span><br><span class="hljs-tag">       <span class="hljs-attr">xmlns:xsi</span>=<span class="hljs-string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span><br><span class="hljs-tag">       <span class="hljs-attr">xsi:schemaLocation</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;helloservice&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;tt.twinkle.service.HelloService&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">beans</span>&gt;</span><br></code></pre></td></tr></table></figure><p>但是@ImportSource方法，@Autowired方法得不到beans.xml文件中的<bean></bean></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs xml">//测试文件<br>@Autowired<br>ApplicationContext applicationContext;<br></code></pre></td></tr></table></figure><p>SpringBoot推荐给容器中添加组件的方法：使用全注解的方法</p><p>&#x3D;&#x3D;配置类  &lt;&#x3D;&#x3D;&#x3D;&#x3D;&gt; Spring配置文件&#x3D;&#x3D;</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@Configuration</span>：指明当前类是一个配置类，代替Spring配置文件</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">@Configuration</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyAppConfig</span> &#123;<br>    <span class="hljs-comment">//将方法的返回值添加到容器中，容器中这个组件默认的id就是方法名</span><br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-keyword">public</span> HelloService <span class="hljs-title function_">helloService</span><span class="hljs-params">()</span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;配置类@Bean给容器添加了组件...&quot;</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">HelloService</span>();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="4-配置文件占位符"><a href="#4-配置文件占位符" class="headerlink" title="4.配置文件占位符"></a>4.配置文件占位符</h2><h3 id="1-随机数占位-random-int-等"><a href="#1-随机数占位-random-int-等" class="headerlink" title="1.随机数占位${random.int}等"></a>1.随机数占位${random.int}等</h3><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs properties"><span class="hljs-attr">person.name</span>=<span class="hljs-string">twinklex@126.com$&#123;random.value&#125;</span><br><span class="hljs-attr">person.age</span>=<span class="hljs-string">20</span><br><span class="hljs-attr">person.birth</span>=<span class="hljs-string">1999/04/04</span><br><span class="hljs-attr">person.boss</span>=<span class="hljs-string">false</span><br></code></pre></td></tr></table></figure><h3 id="2-属性配置占位符"><a href="#2-属性配置占位符" class="headerlink" title="2.属性配置占位符"></a>2.属性配置占位符</h3><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs properties"><span class="hljs-attr">person.name</span>=<span class="hljs-string">twinklex@126.com$&#123;random.value&#125;</span><br><span class="hljs-attr">person.dog.name</span>=<span class="hljs-string">$&#123;person.name&#125;jacky</span><br></code></pre></td></tr></table></figure><ul><li>在配置文件中引用前面配置过的属性（优先级，前面配置过的这里都能用）</li><li>&#x3D;&#x3D;${app.name:默认值}来指定找不到属性时的默认值&#x3D;&#x3D;</li></ul><h2 id="5-Profile"><a href="#5-Profile" class="headerlink" title="5.Profile"></a>5.Profile</h2><h2 id="6-配置文件加载位置"><a href="#6-配置文件加载位置" class="headerlink" title="6.配置文件加载位置"></a>6.配置文件加载位置</h2><p>Spring Boot会扫描以下位置的application.properties文件或application.yml文件作为Spring Boot的默认配置文件，以上优先级从高到低，且&#x3D;&#x3D;高优先级配置内容会覆盖低优先级配置内容&#x3D;&#x3D;，且<strong>互补配置</strong></p><img src="/2022/02/12/SpringBoot/image-20211005164203423.png" alt="image-20211005164203423 " style="zoom:70%;"><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs gradle"><span class="hljs-comment">//当前项目的根路径（即项目所在的路径，和src同级）</span><br>- <span class="hljs-keyword">file</span>:./config<br>- <span class="hljs-keyword">file</span>:./<br><span class="hljs-comment">//当前项目的类路径（即target/class路径下）</span><br>- <span class="hljs-keyword">classpath</span>:/config<br>- <span class="hljs-keyword">classpath</span>:/<br></code></pre></td></tr></table></figure><p>同时也可以通过配置spring.config.location来加载项目外的配置文件，改变默认的配置（运维比较有用）</p><p>步骤：打包成jar包，运行jar包时，命令行中写</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">java</span> -jar Ch02-config-<span class="hljs-number">0</span>.<span class="hljs-number">0</span>.<span class="hljs-number">1</span>-SNAPSHOT.jar --spring.config.location=D:/LanguageLearning/SpringBoot/application.properties<br></code></pre></td></tr></table></figure><h2 id="7-外部配置加载顺序"><a href="#7-外部配置加载顺序" class="headerlink" title="7.外部配置加载顺序"></a>7.外部配置加载顺序</h2><h2 id="8-自动配置原理（见一、3自动配置精讲）"><a href="#8-自动配置原理（见一、3自动配置精讲）" class="headerlink" title="8. 自动配置原理（见一、3自动配置精讲）"></a>8. 自动配置原理（见一、3自动配置精讲）</h2><h1 id="三、日志（尚硅谷P21-P27）"><a href="#三、日志（尚硅谷P21-P27）" class="headerlink" title="三、日志（尚硅谷P21-P27）"></a>三、日志（尚硅谷P21-P27）</h1><h2 id="1-市面上的日志框架"><a href="#1-市面上的日志框架" class="headerlink" title="1.市面上的日志框架"></a>1.市面上的日志框架</h2><table><thead><tr><th>日志门面（日志的抽象层）</th><th>日志实现</th></tr></thead><tbody><tr><td>JCL(Jakarta Commons Logging)、<br>&#x3D;&#x3D;SLF4j&#x3D;&#x3D;(Simlpe Logging Facade for Java)、jboss-logging</td><td>Log4j、JUL(java.util.logging)、Log4j2、&#x3D;&#x3D;Logback&#x3D;&#x3D;</td></tr></tbody></table><p>Spring框架默认选用JCL</p><p>SpringBoot框架默认选用SLF4j和Logback</p><h2 id="2-使用"><a href="#2-使用" class="headerlink" title="2. 使用"></a>2. 使用</h2><img src="/2022/02/12/SpringBoot/concrete-bindings.png" alt="img " style="zoom:75%;"><p>每一个日志的实现框架都有自己的配置文件，虽然使用了SLF4j的日志门面，但是<strong>配置文件还是日志实现框架本身的配置文件</strong></p><p>统一日志记录：即使是别的框架，也最后统一成slf4j进行输出：</p><p>先将jcl和jul转成slf4j，再slf4j-api.jar————适配层的包slf4j-log412.jar————log4j.jar</p><img src="/2022/02/12/SpringBoot/legacy.png" alt="legacy " style="zoom:60%;"><p><strong>如何让系统中所有的日志都统一到slf4j</strong></p><p>1.将系统中其他日志框架先排除</p><p>2.用中间包来替换原有的日志框架</p><p>3.导入slf4j其他的实现</p><h2 id="3-一些配置"><a href="#3-一些配置" class="headerlink" title="3.一些配置"></a>3.一些配置</h2><p><a href="https://docs.spring.io/spring-boot/docs/2.3.12.RELEASE/reference/html/spring-boot-features.html#boot-features-logging">参照官方文档或者博客</a></p><h3 id="1-默认配置"><a href="#1-默认配置" class="headerlink" title="1.默认配置"></a>1.默认配置</h3><p>等级从低到高为：trace&lt;debug&lt;info&lt;warn&lt;error，默认配置为info及以上可以在控制台打印出来</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs properties"><span class="hljs-comment">#指定输出日志等级为trace，即trace及以上的日志都可以输出</span><br><span class="hljs-attr">logging.level.tt</span>=<span class="hljs-string">trace</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">#可以指定完整的log的输出路径</span><br><span class="hljs-attr">logging.file.name</span>=<span class="hljs-string">log/logger.log</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">#在当前磁盘的根路径下创建spring文件夹和里面的log文件，使用spring.log作为默认文件</span><br><span class="hljs-comment">#logging.file.path=/spring/log</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">#在控制台输出的日志的格式</span><br><span class="hljs-comment">#日志输出格式</span><br><span class="hljs-comment">#%d表示日期时间</span><br><span class="hljs-comment">#%thread表示线程名</span><br><span class="hljs-comment">#%-5level表示级别从左显示5个字符宽度</span><br><span class="hljs-comment">#%logger&#123;50&#125;表示logger名字最长50个字符，否则按照句点分割</span><br><span class="hljs-comment">#%msg：日志消息</span><br><span class="hljs-comment">#%n:换行符</span><br><span class="hljs-attr">logging.pattern.console</span>=<span class="hljs-string">%d&#123;yyyy-MM-dd&#125; [%thread] %-5level %logger&#123;50&#125; - %msg%n</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">#指定文件中日志输出的格式</span><br><span class="hljs-attr">logging.pattern.file</span>=<span class="hljs-string">%d&#123;yyyy-MM-dd&#125;======[%thread] ===  %-5level %logger&#123;50&#125;====== - %msg%n</span><br></code></pre></td></tr></table></figure><p>（.yml配置文件中，logging.pattern.console后面的需要加上单引号）</p><h3 id="2-指定配置"><a href="#2-指定配置" class="headerlink" title="2.指定配置"></a>2.指定配置</h3><p>如果自己写了一个框架实现，那么可以参照以下命名规则</p><table><thead><tr><th align="left">Logging System</th><th align="left">Customization</th></tr></thead><tbody><tr><td align="left">Logback</td><td align="left"><code>logback-spring.xml</code>, <code>logback-spring.groovy</code>, <code>logback.xml</code>, or <code>logback.groovy</code></td></tr><tr><td align="left">Log4j2</td><td align="left"><code>log4j2-spring.xml</code> or <code>log4j2.xml</code></td></tr><tr><td align="left">JDK (Java Util Logging)</td><td align="left"><code>logging.properties</code></td></tr></tbody></table><p>其中，logback.xml直接被日志框架识别</p><p>​            **&#x3D;&#x3D;logback-spring.xml&#x3D;&#x3D;**由SpringBoot解析日志配置，所以有更多的高级功能，例如Profile功能</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml">#可以指定某段配置只在某个环境下生效<br><span class="hljs-comment">&lt;!-- configuration to be enabled when the &quot;dev&quot; profile is active --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">springProfile</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;dev&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">pattern</span>&gt;</span>%d&#123;yyyy-MM-dd&#125; [%thread] %-5level %logger&#123;50&#125; - %msg%n<span class="hljs-tag">&lt;/<span class="hljs-name">pattern</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">springProfile</span>&gt;</span><br></code></pre></td></tr></table></figure><h1 id="四、Web开发"><a href="#四、Web开发" class="headerlink" title="四、Web开发"></a>四、Web开发</h1><h2 id="1-简介"><a href="#1-简介" class="headerlink" title="1.简介"></a>1.简介</h2><h2 id="2-Spring-Boot对静态资源的映射规则"><a href="#2-Spring-Boot对静态资源的映射规则" class="headerlink" title="2.Spring Boot对静态资源的映射规则"></a>2.Spring Boot对静态资源的映射规则</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//可以在配置文件中设置和静态资源有关的参数</span><br><span class="hljs-meta">@Deprecated</span><br><span class="hljs-meta">@ConfigurationProperties(</span><br><span class="hljs-meta">    prefix = &quot;spring.resources&quot;,</span><br><span class="hljs-meta">    ignoreUnknownFields = false</span><br><span class="hljs-meta">)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ResourceProperties</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Resources</span> &#123;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//WebMvcAutoConfiguration</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">addResourceHandlers</span><span class="hljs-params">(ResourceHandlerRegistry registry)</span> &#123;<br>    <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">this</span>.resourceProperties.isAddMappings()) &#123;<br>        logger.debug(<span class="hljs-string">&quot;Default resource handling disabled&quot;</span>);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-built_in">this</span>.addResourceHandler(registry, <span class="hljs-string">&quot;/webjars/**&quot;</span>, <span class="hljs-string">&quot;classpath:/META-INF/resources/webjars/&quot;</span>);<br>        <span class="hljs-built_in">this</span>.addResourceHandler(registry, <span class="hljs-built_in">this</span>.mvcProperties.getStaticPathPattern(), (registration) -&gt; &#123;<br>            registration.addResourceLocations(<span class="hljs-built_in">this</span>.resourceProperties.getStaticLocations());<br>            <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.servletContext != <span class="hljs-literal">null</span>) &#123;<br>                <span class="hljs-type">ServletContextResource</span> <span class="hljs-variable">resource</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ServletContextResource</span>(<span class="hljs-built_in">this</span>.servletContext, <span class="hljs-string">&quot;/&quot;</span>);<br>                registration.addResourceLocations(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Resource</span>[]&#123;resource&#125;);<br>            &#125;<br><br>        &#125;);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>（1）所有&#x2F;webjars&#x2F;**，都去&#x2F;META-INF&#x2F;resources&#x2F;webjars&#x2F;找资源</p><p>​                webjars：以jar包的方式引入静态资源（<a href="https://www.webjars.org/">对应网站有maven依赖的方式</a>，直接导入<dependency>就可）</dependency></p><img src="/2022/02/12/SpringBoot/image-20211008223446235.png" alt="image-20211008223446235 " style="zoom:80%;"><p><a href="http://localhost:8080/webjars/jquery/3.6.0/jquery.js%E5%8F%AF%E4%BB%A5%E7%94%A8%E8%BF%99%E4%B8%AA%E8%B7%AF%E5%BE%84%E8%AE%BF%E9%97%AE">http://localhost:8080/webjars/jquery/3.6.0/jquery.js可以用这个路径访问</a></p><p>（2）引入自己的</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//访问当前项目的任何资源</span><br><span class="hljs-built_in">this</span>.staticPathPattern = <span class="hljs-string">&quot;/**&quot;</span>;<br><br><span class="hljs-comment">//可以存放静态资源的文件夹：</span><br><span class="hljs-string">&quot;classpath:/META-INF/resources/&quot;</span>, <br><span class="hljs-string">&quot;classpath:/resources/&quot;</span>, <br><span class="hljs-string">&quot;classpath:/static/&quot;</span>, <br><span class="hljs-string">&quot;classpath:/public/&quot;</span><br></code></pre></td></tr></table></figure><p>直接访问：</p><p>localhost:8080&#x2F;…</p><p>（3）欢迎页</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">加载静态资源文件夹下的所有index.html页面，被<span class="hljs-string">&quot;/**&quot;</span>映射<br><span class="hljs-meta">@Bean</span><br><span class="hljs-keyword">public</span> WelcomePageHandlerMapping <span class="hljs-title function_">welcomePageHandlerMapping</span><span class="hljs-params">(ApplicationContext applicationContext, FormattingConversionService mvcConversionService, ResourceUrlProvider mvcResourceUrlProvider)</span> &#123;<br></code></pre></td></tr></table></figure><p>localhost:8080&#x2F;   直接找资源文件夹下的index.html</p><p>（4）所有的**&#x2F;favicon.ico都是在静态资源文件夹下找</p><h2 id="3-模板引擎"><a href="#3-模板引擎" class="headerlink" title="3.模板引擎"></a>3.模板引擎</h2><h3 id="（1）引入thymeleaf"><a href="#（1）引入thymeleaf" class="headerlink" title="（1）引入thymeleaf"></a>（1）引入thymeleaf</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-thymeleaf<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><h3 id="（2）Thymeleaf使用-amp-语法"><a href="#（2）Thymeleaf使用-amp-语法" class="headerlink" title="（2）Thymeleaf使用&amp;语法"></a>（2）Thymeleaf使用&amp;语法</h3><p>只要我们**把html页面放在classpath:&#x2F;templates&#x2F;**，thymeleaf就能自动渲染该文件夹下的xxx.html文件</p><p>&#x3D;&#x3D;此时Controller里不能写@Responsebody注解，才能调出classpath:&#x2F;templates&#x2F;success.html页面&#x3D;&#x3D;</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@ConfigurationProperties(</span><br><span class="hljs-meta">    prefix = &quot;spring.thymeleaf&quot;</span><br><span class="hljs-meta">)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ThymeleafProperties</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Charset DEFAULT_ENCODING;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">DEFAULT_PREFIX</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;classpath:/templates/&quot;</span>;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">DEFAULT_SUFFIX</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;.html&quot;</span>;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">boolean</span> <span class="hljs-variable">checkTemplate</span> <span class="hljs-operator">=</span> <span class="hljs-literal">true</span>;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">boolean</span> <span class="hljs-variable">checkTemplateLocation</span> <span class="hljs-operator">=</span> <span class="hljs-literal">true</span>;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">String</span> <span class="hljs-variable">prefix</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;classpath:/templates/&quot;</span>;<br>    <br>    <br><br><span class="hljs-meta">@Controller</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">HelloController</span> &#123;<br>    <span class="hljs-meta">@RequestMapping(&quot;/success&quot;)</span><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">success</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;success&quot;</span>;<br>    &#125;<br></code></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;en&quot;</span> <span class="hljs-attr">xmlns:th</span>=<span class="hljs-string">&quot;http://www.thymeleaf.org&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;UTF-8&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>Title<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>成功!!<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">th:text</span>=<span class="hljs-string">&quot;$&#123;hello&#125;&quot;</span>&gt;</span>这是显示欢迎信息<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br></code></pre></td></tr></table></figure><h3 id="（3）语法规则"><a href="#（3）语法规则" class="headerlink" title="（3）语法规则"></a>（3）语法规则</h3><p>1） th:text——改变当前元素里面的文本内容</p><p>​    th：任意html属性来替换原生属性的值</p><img src="/2022/02/12/SpringBoot/1.png" alt="image-20211008223446235 " style="zoom:67%;"><p>2） 表达式</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs properties"><span class="hljs-attr">Simple</span> <span class="hljs-string">expressions:</span><br>    <span class="hljs-attr">Variable</span> <span class="hljs-string">Expressions: $&#123;...&#125;：获取变量值（见usingthymeleaf.pdf  4.2 Variables）</span><br>    <span class="hljs-attr">Selection</span> <span class="hljs-string">Variable Expressions: *&#123;...&#125;：变量选择表达式（见usingthymeleaf.pdf  4.3 Expessions on selection）</span><br>    <span class="hljs-attr">Message</span> <span class="hljs-string">Expressions: #&#123;...&#125;：获取国际化内容（见usingthymeleaf.pdf  4.1 Messages）</span><br>    <span class="hljs-attr">Link</span> <span class="hljs-string">URL Expressions: @&#123;...&#125;：定义URL链接（见usingthymeleaf.pdf  4.4 Link URLs）</span><br>    <span class="hljs-attr">Fragment</span> <span class="hljs-string">Expressions: ~&#123;...&#125;：片段引用表达式（见usingthymeleaf.pdf  4.5 Fragments）</span><br><span class="hljs-attr">Literals（字面量）</span><br>    <span class="hljs-attr">Text</span> <span class="hljs-string">literals: &#x27;one text&#x27; , &#x27;Another one!&#x27; ,…</span><br>    <span class="hljs-attr">Number</span> <span class="hljs-string">literals: 0 , 34 , 3.0 , 12.3 ,…</span><br>    <span class="hljs-attr">Boolean</span> <span class="hljs-string">literals: true , false</span><br>    <span class="hljs-attr">Null</span> <span class="hljs-string">literal: null</span><br>    <span class="hljs-attr">Literal</span> <span class="hljs-string">tokens: one , sometext , main ,…</span><br><span class="hljs-attr">Text</span> <span class="hljs-string">operations（文本操作）</span><br>    <span class="hljs-attr">String</span> <span class="hljs-string">concatenation: +</span><br>    <span class="hljs-attr">Literal</span> <span class="hljs-string">substitutions: |The name is $&#123;name&#125;|</span><br><span class="hljs-attr">Arithmetic</span> <span class="hljs-string">operations（数学运算）</span><br>    <span class="hljs-attr">Binary</span> <span class="hljs-string">operators: + , - , * , / , %</span><br>    <span class="hljs-attr">Minus</span> <span class="hljs-string">sign (unary operator): -</span><br><span class="hljs-attr">Boolean</span> <span class="hljs-string">operations（布尔运算）</span><br>    <span class="hljs-attr">Binary</span> <span class="hljs-string">operators: and , or</span><br>    <span class="hljs-attr">Boolean</span> <span class="hljs-string">negation (unary operator): ! , not</span><br><span class="hljs-attr">Comparisons</span> <span class="hljs-string">and equality（比较运算）</span><br>    <span class="hljs-attr">Comparators</span>: <span class="hljs-string">&gt; , &lt; , &gt;= , &lt;= ( gt , lt , ge , le )</span><br>    <span class="hljs-attr">Equality</span> <span class="hljs-string">operators: == , != ( eq , ne )</span><br><span class="hljs-attr">Conditional</span> <span class="hljs-string">operators（条件运算）</span><br>    <span class="hljs-attr">If-then</span>: <span class="hljs-string">(if) ? (then)</span><br>    <span class="hljs-attr">If-then-else</span>: <span class="hljs-string">(if) ? (then) : (else)</span><br>    <span class="hljs-attr">Default</span>: <span class="hljs-string">(value) ?: (defaultvalue)</span><br><span class="hljs-attr">Special</span> <span class="hljs-string">tokens:</span><br><span class="hljs-attr">No-Operation</span>:<span class="hljs-string">_</span><br></code></pre></td></tr></table></figure><p><a href="https://docs.spring.io/spring-boot/docs/2.3.12.RELEASE/reference/htmlsingle/#boot-features-developing-web-applications">https://docs.spring.io/spring-boot/docs/2.3.12.RELEASE/reference/htmlsingle/#boot-features-developing-web-applications</a></p><h2 id="4-SpringMVC自动配置原理"><a href="#4-SpringMVC自动配置原理" class="headerlink" title="4.SpringMVC自动配置原理"></a>4.SpringMVC自动配置原理</h2><ul><li>Inclusion of <code>ContentNegotiatingViewResolver</code> and <code>BeanNameViewResolver</code> beans.<ul><li>自动配置了ViewResolver（视图解析器：根据方法的返回值得到试图对象（View），视图对象决定如何渲染（转发、重定向等））</li><li>ContentNegotiatingViewResolver：组合所有的视图解析器</li></ul></li><li>Support for serving static resources, including support for WebJars (covered <a href="https://docs.spring.io/spring-boot/docs/2.3.12.RELEASE/reference/htmlsingle/#boot-features-spring-mvc-static-content">later in this document</a>)).</li><li>Automatic registration of <code>Converter</code>, <code>GenericConverter</code>, and <code>Formatter</code> beans.</li><li>Support for <code>HttpMessageConverters</code> (covered <a href="https://docs.spring.io/spring-boot/docs/2.3.12.RELEASE/reference/htmlsingle/#boot-features-spring-mvc-message-converters">later in this document</a>).</li><li>Automatic registration of <code>MessageCodesResolver</code> (covered <a href="https://docs.spring.io/spring-boot/docs/2.3.12.RELEASE/reference/htmlsingle/#boot-features-spring-message-codes">later in this document</a>).</li><li>Static <code>index.html</code> support.</li><li>Custom <code>Favicon</code> support (covered <a href="https://docs.spring.io/spring-boot/docs/2.3.12.RELEASE/reference/htmlsingle/#boot-features-spring-mvc-favicon">later in this document</a>).</li><li>Automatic use of a <code>ConfigurableWebBindingInitializer</code> bean (covered <a href="https://docs.spring.io/spring-boot/docs/2.3.12.RELEASE/reference/htmlsingle/#boot-features-spring-mvc-web-binding-initializer">later in this document</a>).</li></ul><h1 id="六、Spring-Boot与数据访问"><a href="#六、Spring-Boot与数据访问" class="headerlink" title="六、Spring Boot与数据访问"></a>六、Spring Boot与数据访问</h1><h2 id="1-JDBC"><a href="#1-JDBC" class="headerlink" title="1.JDBC"></a>1.JDBC</h2><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-jdbc<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>mysql<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>mysql-connector-java<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">scope</span>&gt;</span>runtime<span class="hljs-tag">&lt;/<span class="hljs-name">scope</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs stylus">oracle<span class="hljs-selector-class">.ucp</span><span class="hljs-selector-class">.jdbc</span><span class="hljs-selector-class">.PoolDataSource</span><br>org<span class="hljs-selector-class">.apache</span><span class="hljs-selector-class">.commons</span><span class="hljs-selector-class">.dbcp2</span><span class="hljs-selector-class">.BasicDataSource</span><br>com<span class="hljs-selector-class">.zaxxer</span><span class="hljs-selector-class">.hikari</span><span class="hljs-selector-class">.HikariDataSource</span><br>org<span class="hljs-selector-class">.apache</span><span class="hljs-selector-class">.tomcat</span><span class="hljs-selector-class">.jdbc</span><span class="hljs-selector-class">.pool</span>.DataSource<br></code></pre></td></tr></table></figure><p>运行建表语句——将schema.sql文件放在根路径下（resources资源文件夹下）</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs properties"><span class="hljs-attr">//application.properties</span><br><span class="hljs-attr">spring.sql.init.mode</span>=<span class="hljs-string">always</span><br></code></pre></td></tr></table></figure><p>运行修改表语句</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Controller</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">HelloController</span> &#123;<br>    <span class="hljs-meta">@Autowired</span><br>    JdbcTemplate jdbcTemplate;<br>    <br>    <span class="hljs-meta">@ResponseBody</span><br>    <span class="hljs-meta">@GetMapping(&quot;/query&quot;)</span><br>    <span class="hljs-keyword">public</span> Map&lt;String, Object&gt; <span class="hljs-title function_">map</span><span class="hljs-params">()</span>&#123;<br>        List&lt;Map&lt;String, Object&gt;&gt; maps = jdbcTemplate.queryForList(<span class="hljs-string">&quot;select * FROM department&quot;</span>);<br>        <span class="hljs-keyword">return</span> maps.get(<span class="hljs-number">0</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="2-整合Druid数据源"><a href="#2-整合Druid数据源" class="headerlink" title="2.整合Druid数据源"></a>2.整合Druid数据源</h2><p>1.导入Druid数据源spring.datasource.type&#x3D;com.alibaba.druid.pool.DruidDataSource</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs yml"><span class="hljs-attr">spring:</span><br>  <span class="hljs-attr">datasource:</span><br>    <span class="hljs-attr">username:</span> <span class="hljs-string">root</span><br>    <span class="hljs-attr">password:</span> <span class="hljs-number">333</span><br>    <span class="hljs-attr">url:</span> <span class="hljs-string">jdbc:mysql://localhost:1234/jdbc</span><br>    <span class="hljs-attr">type:</span> <span class="hljs-string">com.alibaba.druid.pool.DruidDataSource</span><br><br><span class="hljs-comment">#这些都是spring.datasource对应properties类中没有的，需要自己写一个config类（见下面）</span><br>    <span class="hljs-attr">initialSize:</span> <span class="hljs-number">5</span><br>    <span class="hljs-attr">minIdle:</span> <span class="hljs-number">5</span><br>    <span class="hljs-attr">maxActivity:</span> <span class="hljs-number">20</span><br>    <span class="hljs-attr">maxWait:</span> <span class="hljs-number">60000</span><br>    <span class="hljs-attr">timeBetweenEvictionRunsMillis:</span> <span class="hljs-number">60000</span><br>    <span class="hljs-attr">minEvictableIdleTimeMillis:</span> <span class="hljs-number">300000</span><br>    <span class="hljs-attr">validationQuery:</span> <span class="hljs-string">SELECT</span> <span class="hljs-number">1</span> <span class="hljs-string">FROM</span> <span class="hljs-string">DUAL</span><br>    <span class="hljs-attr">testWhileIdle:</span> <span class="hljs-literal">true</span><br>    <span class="hljs-attr">testOnBorrow:</span> <span class="hljs-literal">false</span><br>    <span class="hljs-attr">testOnReturn:</span> <span class="hljs-literal">false</span><br>    <span class="hljs-attr">poolPreparedStatements:</span> <span class="hljs-literal">true</span><br><span class="hljs-comment">#    配置监控统计拦截的filters，去掉后监控界面sql无法统计，&#x27;wall&#x27;用于防火墙</span><br>    <span class="hljs-attr">filters:</span> <span class="hljs-string">stat,wall</span><br>    <span class="hljs-attr">maxPoolPreparedStatementPerConnectionSize:</span> <span class="hljs-number">20</span><br>    <span class="hljs-attr">useGlobalDataSourceStat:</span> <span class="hljs-literal">true</span><br>    <span class="hljs-attr">connectionProperties:</span> <span class="hljs-string">druid.stat.mergeSql=true;druid.stat.slowSqlMillis=500</span><br>  <span class="hljs-attr">sql:</span><br>    <span class="hljs-attr">init:</span><br>      <span class="hljs-attr">mode:</span> <span class="hljs-string">always</span><br></code></pre></td></tr></table></figure><p>2.配置Druid监控和监控的filter</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/*@Configuration表明该类对应一个Spring配置文件*/</span><br><span class="hljs-meta">@Configuration</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">DruidConfig</span> &#123;<br><br>    <span class="hljs-meta">@ConfigurationProperties( prefix = &quot;spring.datasource&quot; )</span><br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-keyword">public</span> DataSource <span class="hljs-title function_">druidDataConfig</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">DruidDataSource</span>();<br>    &#125;<br><br><span class="hljs-comment">//    配置Druid监控</span><br><span class="hljs-comment">//    1.配置一个管理后台的Servlet，这里现在完全看不懂在干嘛...要看MVC...</span><br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-keyword">public</span> ServletRegistrationBean <span class="hljs-title function_">statViewServlet</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-type">ServletRegistrationBean</span> <span class="hljs-variable">bean</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ServletRegistrationBean</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">StatViewServlet</span>(),<span class="hljs-string">&quot;/druid/*&quot;</span>);<br>        Map&lt;String, String&gt; initParams = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br><br>        initParams.put(<span class="hljs-string">&quot;loginUsername&quot;</span>,<span class="hljs-string">&quot;admin&quot;</span>);<br>        initParams.put(<span class="hljs-string">&quot;loginPassword&quot;</span>,<span class="hljs-string">&quot;123456&quot;</span>);<br>        initParams.put(<span class="hljs-string">&quot;allow&quot;</span>,<span class="hljs-string">&quot;&quot;</span>);<span class="hljs-comment">//默认允许所有访问</span><br>        initParams.put(<span class="hljs-string">&quot;deny&quot;</span>,<span class="hljs-string">&quot;&quot;</span>);<span class="hljs-comment">//</span><br>        bean.setInitParameters(initParams);<br>        <span class="hljs-keyword">return</span> bean;<br><br>    &#125;<br><span class="hljs-comment">//    2.配置一个监控的filter</span><br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-keyword">public</span> FilterRegistrationBean <span class="hljs-title function_">webStatFilter</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-type">FilterRegistrationBean</span> <span class="hljs-variable">bean</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FilterRegistrationBean</span>();<br>        bean.setFilter(<span class="hljs-keyword">new</span> <span class="hljs-title class_">WebStatFilter</span>());<br>        Map&lt;String, String&gt; initParams = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>        <span class="hljs-comment">//拦截请求时，哪些不拦截</span><br>        initParams.put(<span class="hljs-string">&quot;exclusions&quot;</span>,<span class="hljs-string">&quot;*.js,*.css,/druid/*&quot;</span>);<br><br>        bean.setInitParameters(initParams);<br>        bean.setUrlPatterns(Arrays.asList(<span class="hljs-string">&quot;/*&quot;</span>));<br>        <span class="hljs-keyword">return</span> bean;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="3-MyBatis"><a href="#3-MyBatis" class="headerlink" title="3. MyBatis"></a>3. MyBatis</h2><p>步骤：</p><p>（1） 配置数据源相关属性（整合了JDBC和Druid）</p><p>（2） 给数据库建表</p><p>（3） 写相应的bean文件（实体类）</p><h3 id="1-注解版使用，更轻便简单"><a href="#1-注解版使用，更轻便简单" class="headerlink" title="1.注解版使用，更轻便简单"></a><strong>1.注解版使用</strong>，更轻便简单</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//指定这是一个操作数据库的mapper，可以直接在函数中写sql语句，不需要xml的mapper文件</span><br><span class="hljs-meta">@Mapper</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">DepartmentMapper</span> &#123;<br><br>    <span class="hljs-meta">@Select(&quot;select * from department where id = #&#123;id&#125;&quot;)</span><br>    <span class="hljs-keyword">public</span> Department <span class="hljs-title function_">getDeptById</span><span class="hljs-params">(Integer id)</span>;<br><br>    <span class="hljs-meta">@Delete(&quot;delect from department where id=#&#123;id&#125;&quot;)</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">deleteDeptById</span><span class="hljs-params">(Integer id)</span>;<br><br>    <span class="hljs-comment">//如果不加@Options()，由于id是自增主键，不需要传入，则返回的department的id属性为null</span><br>    <span class="hljs-comment">//加上@Options(),其中useGeneratedKeys表示使用了主键，keyProperty表示数据库中哪个列为主键</span><br>    <span class="hljs-comment">//主键会重新封装进department中，返回值中就会看见主键了</span><br>    <span class="hljs-meta">@Options(useGeneratedKeys = true, keyProperty = &quot;id&quot;)</span><br>    <span class="hljs-meta">@Insert(&quot;insert into department(name) values(#&#123;depName&#125;) &quot;)</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">insertDept</span><span class="hljs-params">(Department dept)</span>;<br><br>    <span class="hljs-meta">@Update(&quot;update department set depName=#&#123;depName&#125; where id=#&#123;id&#125;&quot;)</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">updateDept</span><span class="hljs-params">(Department department)</span>;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//Controller类</span><br><span class="hljs-meta">@RestController</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">DeptController</span> &#123;<br><br>    <span class="hljs-meta">@Autowired</span><br>    DepartmentMapper departmentMapper;<br><br>    <span class="hljs-meta">@GetMapping(&quot;/dept/&#123;id&#125;&quot;)</span><br>    <span class="hljs-keyword">public</span> Department <span class="hljs-title function_">getDept</span><span class="hljs-params">(<span class="hljs-meta">@PathVariable(&quot;id&quot;)</span> Integer id)</span>&#123;<br>        <span class="hljs-keyword">return</span> departmentMapper.getDeptById(id);<br>    &#125;<br><br>    <span class="hljs-meta">@GetMapping(&quot;/dept&quot;)</span><br>    <span class="hljs-keyword">public</span> Department <span class="hljs-title function_">insertDept</span><span class="hljs-params">(Department department)</span>&#123;<br>        departmentMapper.insertDept(department);<br>        <span class="hljs-keyword">return</span> department;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>在浏览器中测试：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-regexp">//</span>测试insertDept，?表示传参<br>http:<span class="hljs-regexp">//</span>localhost:<span class="hljs-number">8080</span>/dept?depName=BB<br></code></pre></td></tr></table></figure><img src="/2022/02/12/SpringBoot/image-20211013154309115.png" alt="image-20211013154309115 " style="zoom:70%;"><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//自定义mybatis的配置规则，给容器中添加一个ConfigurationCustomizer</span><br><span class="hljs-meta">@org</span>.springframework.context.annotation.Configuration<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MybatisConfig</span> &#123;<br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-keyword">public</span> ConfigurationCustomizer <span class="hljs-title function_">configurationCustomizer</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ConfigurationCustomizer</span>() &#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">customize</span><span class="hljs-params">(Configuration configuration)</span> &#123;<br>                configuration.setMapUnderscoreToCamelCase(<span class="hljs-literal">true</span>);<br>            &#125;<br>        &#125;;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>当mapper文件太多，一个一个配置@Mapper太费时间，那么在启动类上访加上：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//使用@MapperScan批量扫描所有的Mapper接口</span><br><span class="hljs-meta">@MapperScan(value = &quot;com.tt.ch06mybatis.mapper&quot;)</span><br><span class="hljs-meta">@SpringBootApplication</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Ch06MybatisApplication</span> &#123;<br></code></pre></td></tr></table></figure><h3 id="2-配置文件版（非注解版）"><a href="#2-配置文件版（非注解版）" class="headerlink" title="2.配置文件版（非注解版）"></a>2.配置文件版（非注解版）</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--mybatis-config.xml文件，mybatis的一些配置（例如驼峰等），相当于mybatis中的主配置文件--&gt;</span><br><span class="hljs-meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;</span><br><br><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">configuration</span></span><br><span class="hljs-meta">        <span class="hljs-keyword">PUBLIC</span> <span class="hljs-string">&quot;-//mybatis.org//DTD Config 3.0//EN&quot;</span></span><br><span class="hljs-meta">        <span class="hljs-string">&quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">configuration</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">settings</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">setting</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;mapUnderscoreToCamelCase&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;true&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">settings</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">configuration</span>&gt;</span><br></code></pre></td></tr></table></figure><p>写dao接口和mapper文件</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//只写两个方法声明，sql语句在xml文件中写</span><br><span class="hljs-meta">@Component</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">EmployeeMapper</span> &#123;<br>    <span class="hljs-keyword">public</span> Employee <span class="hljs-title function_">getEmpById</span><span class="hljs-params">(Integer id)</span>;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">insertEmp</span><span class="hljs-params">(Employee employee)</span>;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--EmployeeMapper.xml--&gt;</span><br><span class="hljs-comment">&lt;!--写sql语句，注意namespace和id--&gt;</span><br><span class="hljs-meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;</span><br><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">mapper</span></span><br><span class="hljs-meta">        <span class="hljs-keyword">PUBLIC</span> <span class="hljs-string">&quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;</span></span><br><span class="hljs-meta">        <span class="hljs-string">&quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">mapper</span> <span class="hljs-attr">namespace</span>=<span class="hljs-string">&quot;com.tt.ch06mybatis.mapper.EmployeeMapper&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;getEmpById&quot;</span> <span class="hljs-attr">resultType</span>=<span class="hljs-string">&quot;com.tt.ch06mybatis.bean.Employee&quot;</span>&gt;</span><br>        select * from employee where id=#&#123;id&#125;<br>    <span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">insert</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;insertEmp&quot;</span>&gt;</span><br>        insert into employee(lastName,email,gender,dId) values(#&#123;lastName&#125;,#&#123;email&#125;,#&#123;gender&#125;,#&#123;dId&#125;)<br>    <span class="hljs-tag">&lt;/<span class="hljs-name">insert</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">mapper</span>&gt;</span><br></code></pre></td></tr></table></figure><p><strong>在springboot的配置文件中加上mybatis的配置——全局配置文件和mapper映射文件位置</strong></p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">mybatis:</span><br>  <span class="hljs-attr">config-location:</span> <span class="hljs-string">classpath:mybatis/mybatis-config.xml</span><br>  <span class="hljs-attr">mapper-locations:</span> <span class="hljs-string">classpath:mybatis/mapper/*.xml</span><br></code></pre></td></tr></table></figure><p>@Controller类进行测试</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@GetMapping(&quot;/emp/&#123;id&#125;&quot;)</span><br><span class="hljs-keyword">public</span> Employee <span class="hljs-title function_">getEmployee</span><span class="hljs-params">(<span class="hljs-meta">@PathVariable(&quot;id&quot;)</span> Integer id)</span>&#123;<br>    <span class="hljs-keyword">return</span> employeeMapper.getEmpById(id);<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="七、一些注解"><a href="#七、一些注解" class="headerlink" title="七、一些注解"></a>七、一些注解</h1><h2 id="一-control类"><a href="#一-control类" class="headerlink" title="(一) control类"></a>(一) control类</h2><p><strong>@ResponseBody</strong></p><p>让controller返回数据能够在页面上显示，实现回显效果。返回json串，传给前端</p><p>该方法（类）的返回结果直接写入HTTP response body中</p><p><strong>@Controller</strong></p><p>用于定义控制器类，在spring 项目中由控制器负责将用户发来的URL请求转发到对应的服务接口(service层)</p><p><strong>@RestController</strong></p><p>用于标注控制层组件(如struts中的action)，**@ResponseBody<strong>和</strong>@Controller**的合集。</p><p><strong>@RequestMapping</strong></p><p>提供路由信息，负责URL到Controller中的具体函数的映射。</p><h2 id="二-config类"><a href="#二-config类" class="headerlink" title="(二) config类"></a>(二) config类</h2><p><strong>@Configuration</strong></p><p>相当于传统的xml配置文件，如果有些第三方库需要用到xml文件，建议仍然通过@Configuration类作为项目的配置主类——可以使用@ImportResource注解加载xml配置文件。</p>]]></content>
    
    
    <categories>
      
      <category>Spring全家桶</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Redis笔记</title>
    <link href="/2022/02/12/Redis/"/>
    <url>/2022/02/12/Redis/</url>
    
    <content type="html"><![CDATA[<p><a href="http://www.redisfans.com/">redis教程</a></p><h1 id="一、-NoSQL数据库简介"><a href="#一、-NoSQL数据库简介" class="headerlink" title="一、 NoSQL数据库简介"></a>一、 NoSQL数据库简介</h1><img src="/2022/02/12/Redis/image-20211024203354717.png" alt="image-20211024203354717 " style="zoom:60%;"><p><a href="https://www.cnblogs.com/xrq730/p/11039384.html">SQL和NoSQL之间的比较</a></p><p>NoSQL的好处：</p><ul><li><p>减少CPU的压力：用多台服务器，会导致session的共享问题（被一台服务器绑定，而其他服务器没有session不能登录）</p><p>–&gt;方法：1.信息存储到客户端cookie中（安全性难做保障）</p><p>​                2.session复制（服务器浪费）</p><p>​                3.将session用户信息保存在<strong>NoSQL数据库</strong>中，其他服务器需要登录时提取出来</p></li><li><p>减少IO压力：</p><ul><li>使用NoSQL缓存存储，针对那些读远多于写的数据，引入一层缓存，每次读从缓存中读取，缓存中读取不到，再去数据库中取，取完之后再写入到缓存，对数据做好失效机制通常就没有大问题了。</li><li>列式存储(HBase)、文档存储（MongoDB）</li></ul><img src="/2022/02/12/Redis/image-20211024205916927.png" alt="image-20211024205916927 " style="zoom:70%;"><p>使用Nginx动态分配服务器，负载均衡，当业务多时，可使用主从数据库（库<strong>水平切分</strong>、表<strong>垂直切分</strong>），<strong>读写分离</strong></p></li></ul><img src="/2022/02/12/Redis/image-20211024210210378.png" alt="image-20211024210210378 " style="zoom:67%;"><h2 id="1、NoSQL-Not-Only-SQL-非关系型数据库"><a href="#1、NoSQL-Not-Only-SQL-非关系型数据库" class="headerlink" title="1、NoSQL(Not Only SQL)  非关系型数据库"></a>1、NoSQL(Not Only SQL)  非关系型数据库</h2><ul><li>不遵循SQL标准</li><li>&#x3D;&#x3D;不支持ACID（事务四大特性：<strong>原子性、一致性、隔离性、持久性</strong>）&#x3D;&#x3D;</li><li>远超SQL性能</li></ul><h2 id="2、-NoSQL适用场景"><a href="#2、-NoSQL适用场景" class="headerlink" title="2、 NoSQL适用场景"></a>2、 NoSQL适用场景</h2><ul><li>数据高并发的读写</li><li>海量数据的读写</li><li>数据高扩展性</li></ul><h2 id="3、一些NoSQL"><a href="#3、一些NoSQL" class="headerlink" title="3、一些NoSQL"></a>3、一些NoSQL</h2><img src="/2022/02/12/Redis/image-20211024211754446.png" alt="image-20211024211754446 " style="zoom:67%;"><h3 id="1-Memcache"><a href="#1-Memcache" class="headerlink" title="(1) Memcache"></a>(1) Memcache</h3><p>早期NoSQL，数据在内存中，且一般不持久化（不落盘），支持简单的key-value模式，支持类型单一，作为缓存数据库辅助持久化的数据库</p><h3 id="2-Redis"><a href="#2-Redis" class="headerlink" title="(2) Redis"></a>(2) Redis</h3><p>覆盖了Memcache的大部分功能</p><p>数据都在内存中，<strong>支持持久化</strong>，主要备份恢复</p><p>除了支持<strong>key-value</strong>模式，还支持多种数据结构的存储，比如<strong>string（字符串）、list（链表）、set（集合）、hash（哈希类型）、zset（sorted set有序集合）</strong>等</p><p>实现<strong>主从同步</strong>（master-slave）</p><p>一般是作为缓存数据库辅助持久化的数据库（和关系型数据库一起使用）</p><h3 id="3-MongoDB"><a href="#3-MongoDB" class="headerlink" title="(3) MongoDB"></a>(3) MongoDB</h3><p><strong>文档型数据库</strong></p><p>key-value模式，尤其对value（特别是json）提供了丰富的查询功能</p><p>支持二进制数据及大型对象</p><h2 id="4、-安装（ubuntu）"><a href="#4、-安装（ubuntu）" class="headerlink" title="4、 安装（ubuntu）"></a>4、 安装（ubuntu）</h2><h3 id="1-步骤"><a href="#1-步骤" class="headerlink" title="(1) 步骤"></a>(1) 步骤</h3><p>安装gcc：sudo apt install gcc</p><p>解压文件：tar xzf redis-6.2.6.tar.gz</p><p>sudo mv redis-6.2.6 &#x2F;usr&#x2F;local&#x2F;redis</p><p>cd &#x2F;usr&#x2F;local&#x2F;redis&#x2F;</p><p>sudo make</p><p>sudo make test</p><p>sudo make install</p><p>将redis.conf文件放进&#x2F;etc&#x2F;文件夹中，并修改redis.conf文件：deamonize yes</p><p>启动redis:</p><p>cd &#x2F;usr&#x2F;local&#x2F;bin</p><p>redis-server &#x2F;etc&#x2F;redis.conf</p><p>redis-cli</p><p>查看进程：</p><p>ps -ef | grep  redis</p><p>手动杀死进程：</p><p>kill -9 XXX（redis-server进程号）</p><p>创建redis-log.log文件，并给权限</p><figure class="highlight 1c"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><pre><code class="hljs 1c"><span class="hljs-meta"># 创建存放redis日志的文件</span><br>touch redis-<span class="hljs-built_in">log</span>.<span class="hljs-built_in">log</span><br><span class="hljs-meta"># 给所有人可读可写的权限</span><br>chmod <span class="hljs-number">666</span> redis-<span class="hljs-built_in">log</span>.<span class="hljs-built_in">log</span><br><span class="hljs-meta"># 在redis.conf文件中修改logfile的位置</span><br></code></pre></td></tr></table></figure><h3 id="2-端口：6379（Merz）"><a href="#2-端口：6379（Merz）" class="headerlink" title="(2)端口：6379（Merz）"></a>(2)端口：6379（Merz）</h3><p>有16个数据库，默认使用0号数据库</p><p>select <dbid>切换数据库</dbid></p><p>所有数据库的密码是相同的</p><h3 id="3-单线程-多路IO复用"><a href="#3-单线程-多路IO复用" class="headerlink" title="(3) 单线程+多路IO复用"></a>(3) 单线程+多路IO复用</h3><p>当没有数据读写的时候，cpu一直在做其他的事情</p><h1 id="二、数据类型"><a href="#二、数据类型" class="headerlink" title="二、数据类型"></a>二、数据类型</h1><h2 id="一-五大常用数据类型"><a href="#一-五大常用数据类型" class="headerlink" title="(一) 五大常用数据类型"></a>(一) 五大常用数据类型</h2><p>关于key的几个命令</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs linux">//设置key和value<br>set key value<br>//判断某个key是否存在<br>exists key<br>//查看key的类型<br>type key<br>//删除指定的key<br>del key<br>//根据value选择非阻塞删除<br>unlink key<br>//为给定的key设置过期时间(10为秒数)<br>expire key 10<br>//查看还有多少秒过期，-1表示永不过期，-2表示已经过期<br>ttl key<br>//查看所有的key<br>keys *<br><br>//切换数据库<br>select index<br>//查看当前数据库的key的数量<br>dbsize<br>//清空当前库<br>flushdb<br>//通杀全部库<br>flushall<br></code></pre></td></tr></table></figure><h2 id="1-String"><a href="#1-String" class="headerlink" title="1.String"></a>1.String</h2><p>二进制安全</p><p>value字符串最多512M</p><h3 id="1-常用命令"><a href="#1-常用命令" class="headerlink" title="(1) 常用命令"></a>(1) 常用命令</h3><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs vim"><span class="hljs-keyword">set</span> <span class="hljs-symbol">&lt;key&gt;</span> <span class="hljs-symbol">&lt;value&gt;</span>   key相同时，value覆盖<br>setnx <span class="hljs-symbol">&lt;key&gt;</span> <span class="hljs-symbol">&lt;value&gt;</span> 只有在key不存在的时候设置key的value，即value不覆盖<br><span class="hljs-built_in">get</span> <span class="hljs-symbol">&lt;key&gt;</span><br><span class="hljs-keyword">append</span> <span class="hljs-symbol">&lt;key&gt;</span> <span class="hljs-symbol">&lt;value&gt;</span>，将给定的value值追加到原值的末尾<br><span class="hljs-built_in">strlen</span> <span class="hljs-symbol">&lt;key&gt;</span> 获得value的长度<br><br>incr/decr <span class="hljs-symbol">&lt;key&gt;</span>如果value是数值型，则加/减<span class="hljs-number">1</span><br>incrby/decrby <span class="hljs-symbol">&lt;key&gt;</span> &lt;步长&gt;<br><br>mset <span class="hljs-symbol">&lt;key1&gt;</span> <span class="hljs-symbol">&lt;value1&gt;</span> <span class="hljs-symbol">&lt;key2&gt;</span> <span class="hljs-symbol">&lt;value2&gt;</span> <span class="hljs-symbol">&lt;key3&gt;</span> <span class="hljs-symbol">&lt;value3&gt;</span>...  设置多个<br>mget <span class="hljs-symbol">&lt;key1&gt;</span> <span class="hljs-symbol">&lt;key2&gt;</span> <span class="hljs-symbol">&lt;key3&gt;</span>...得到多个<br>msetnx <span class="hljs-symbol">&lt;key1&gt;</span> <span class="hljs-symbol">&lt;value1&gt;</span> <span class="hljs-symbol">&lt;key2&gt;</span> <span class="hljs-symbol">&lt;value2&gt;</span> <span class="hljs-symbol">&lt;key3&gt;</span> <span class="hljs-symbol">&lt;value3&gt;</span>...当都不存在时，才会赋值成功<br><br>getrange <span class="hljs-symbol">&lt;key&gt;</span> <span class="hljs-symbol">&lt;start_index&gt;</span> <span class="hljs-symbol">&lt;end_index&gt;</span>类似java的substring，前包后包<br>setrange <span class="hljs-symbol">&lt;key&gt;</span> <span class="hljs-symbol">&lt;start_index&gt;</span>从start_index开始覆盖value<br><br>setex <span class="hljs-symbol">&lt;key&gt;</span> &lt;过期时间&gt; <span class="hljs-symbol">&lt;value&gt;</span>设置键值的的同时，设置过期时间<br>getset <span class="hljs-symbol">&lt;key&gt;</span> <span class="hljs-symbol">&lt;value&gt;</span>返回旧值，赋上新值<br></code></pre></td></tr></table></figure><h3 id="2-数据结构"><a href="#2-数据结构" class="headerlink" title="(2) 数据结构"></a>(2) 数据结构</h3><p>底层为简单动态字符串(Simple Dynamic String, SDS)，对应java的ArrayList，采用<strong>预分配冗余空间</strong>的方式来减少内存的频繁分配</p><p>内存为当前字符串分配空间capacity，当字符串长度小于1M，扩容时加倍扩容；如果大于1M，则扩容时只会多扩1M的空间。</p><p>注意<strong>字符串的最大长度为512M</strong>！！！</p><h2 id="2-List"><a href="#2-List" class="headerlink" title="2.List"></a>2.List</h2><h3 id="1-常用命令-1"><a href="#1-常用命令-1" class="headerlink" title="(1) 常用命令"></a>(1) 常用命令</h3><figure class="highlight tcl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs tcl">//从左/右放值<br>lpush/rpush &lt;key&gt; &lt;value1&gt; &lt;value2&gt; &lt;value3&gt;<br>//从左/右吐出一个值，值在键在，值光键亡<br>lpop/rpop &lt;key&gt;<br>//从key1列表右边取出一个值，插到key2列表的左边<br>rpoplpush &lt;key1&gt; &lt;key2&gt;<br>//<span class="hljs-keyword">lrange</span> &lt;key&gt; <span class="hljs-number">0</span> <span class="hljs-number">-1</span>  ，从左到右取值，其中<span class="hljs-number">0</span>表示左边第一个，<span class="hljs-number">-1</span>表示右边第一个，<span class="hljs-number">0</span>  <span class="hljs-number">-1</span> 表示获取所有<br><span class="hljs-keyword">lrange</span> &lt;key&gt; &lt;start&gt; &lt;stop&gt;<br>//按照索引下标获得元素（从左到右，从<span class="hljs-number">0</span>开始）<br><span class="hljs-keyword">lindex</span> &lt;key&gt; &lt;index&gt;<br>//获取列表长度<br>llen &lt;key&gt;<br><br><br>//在value的前/后加上newvalue<br><span class="hljs-keyword">linsert</span> &lt;key&gt; before/<span class="hljs-keyword">after</span> &lt;value&gt; &lt;newvalue&gt;<br>//从左边开始删除count个value<br>lrem &lt;key&gt; &lt;count&gt; &lt;value&gt;<br>//将列表key下标为index的值替换成value<br><span class="hljs-keyword">lset</span> &lt;key&gt; &lt;index&gt; &lt;value&gt;<br></code></pre></td></tr></table></figure><h3 id="2-数据结构-1"><a href="#2-数据结构-1" class="headerlink" title="(2) 数据结构"></a>(2) 数据结构</h3><p>快速链表（quicklist）</p><h2 id="3-Set"><a href="#3-Set" class="headerlink" title="3.Set"></a>3.Set</h2><p>对外提供的功能和list类型，是一个列表的功能。string 类型的<strong>无序集合</strong>，底层是一个value为null的hash表，添加、删除、查找的复杂度都为O(1)</p><p>可以<strong>自动排重</strong>，<strong>无序</strong></p><h3 id="1-常用命令-2"><a href="#1-常用命令-2" class="headerlink" title="(1)常用命令"></a>(1)常用命令</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs xml">//加值<br>sadd <span class="hljs-tag">&lt;<span class="hljs-name">key</span>&gt;</span> <span class="hljs-tag">&lt;<span class="hljs-name">value1</span>&gt;</span> <span class="hljs-tag">&lt;<span class="hljs-name">value2</span>&gt;</span> <span class="hljs-tag">&lt;<span class="hljs-name">value3</span>&gt;</span>...<br>//取出key中的所有值<br>smembers <span class="hljs-tag">&lt;<span class="hljs-name">key</span>&gt;</span><br>//判断集合key是否含有value，有为1，没有为0<br>sismember <span class="hljs-tag">&lt;<span class="hljs-name">key</span>&gt;</span> <span class="hljs-tag">&lt;<span class="hljs-name">value</span>&gt;</span><br>//返回key集合中元素的个数<br>scard <span class="hljs-tag">&lt;<span class="hljs-name">key</span>&gt;</span><br>//删除集合key中的元素<br>srem <span class="hljs-tag">&lt;<span class="hljs-name">key</span>&gt;</span> <span class="hljs-tag">&lt;<span class="hljs-name">value1</span>&gt;</span> <span class="hljs-tag">&lt;<span class="hljs-name">value2</span>&gt;</span>...<br>//随机从该集合中吐出一个数<br>spop <span class="hljs-tag">&lt;<span class="hljs-name">key</span>&gt;</span><br>//随机从集合key中取出n个值，但是不会从集合中删除<br>srandmember <span class="hljs-tag">&lt;<span class="hljs-name">key</span>&gt;</span> <span class="hljs-tag">&lt;<span class="hljs-name">n</span>&gt;</span><br>//把集合中的value值从一个集合移动到另一个集合<br>smove <span class="hljs-tag">&lt;<span class="hljs-name">source</span>&gt;</span> <span class="hljs-tag">&lt;<span class="hljs-name">destination</span>&gt;</span> value<br>//返回两个集合的交集元素<br>sinter <span class="hljs-tag">&lt;<span class="hljs-name">key1</span>&gt;</span> <span class="hljs-tag">&lt;<span class="hljs-name">key2</span>&gt;</span><br>//返回两个集合的并集元素<br>sunion <span class="hljs-tag">&lt;<span class="hljs-name">key1</span>&gt;</span> <span class="hljs-tag">&lt;<span class="hljs-name">key2</span>&gt;</span><br>//返回两个集合的差集元素(key1中的，不包含key2的)<br>sdiff <span class="hljs-tag">&lt;<span class="hljs-name">key1</span>&gt;</span> <span class="hljs-tag">&lt;<span class="hljs-name">key2</span>&gt;</span><br></code></pre></td></tr></table></figure><h3 id="2-数据结构-2"><a href="#2-数据结构-2" class="headerlink" title="(2)数据结构"></a>(2)数据结构</h3><p>底层是字典dict，</p><h2 id="4-Hash"><a href="#4-Hash" class="headerlink" title="4.Hash"></a>4.Hash</h2><p>Redis hash是一个string类型的field和value的映射表，类似于java里的Map&lt;Object, Object&gt;</p><img src="/2022/02/12/Redis/image-20211028224853649.png" alt="image-20211028224853649" style="zoom:100%;"><h3 id="1-常用命令-3"><a href="#1-常用命令-3" class="headerlink" title="(1)常用命令"></a>(1)常用命令</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs xml">//给<span class="hljs-tag">&lt;<span class="hljs-name">key</span>&gt;</span>集合中的<span class="hljs-tag">&lt;<span class="hljs-name">field</span>&gt;</span>键赋值<span class="hljs-tag">&lt;<span class="hljs-name">value</span>&gt;</span><br>hset <span class="hljs-tag">&lt;<span class="hljs-name">key</span>&gt;</span> <span class="hljs-tag">&lt;<span class="hljs-name">field</span>&gt;</span> <span class="hljs-tag">&lt;<span class="hljs-name">value</span>&gt;</span><br>//从<span class="hljs-tag">&lt;<span class="hljs-name">key1</span>&gt;</span>集合<span class="hljs-tag">&lt;<span class="hljs-name">field</span>&gt;</span>取出 value <br>hget <span class="hljs-tag">&lt;<span class="hljs-name">key1</span>&gt;</span> <span class="hljs-tag">&lt;<span class="hljs-name">field</span>&gt;</span><br>//批量设置hash的值<br>hmset <span class="hljs-tag">&lt;<span class="hljs-name">key1</span>&gt;</span> <span class="hljs-tag">&lt;<span class="hljs-name">field1</span>&gt;</span> <span class="hljs-tag">&lt;<span class="hljs-name">value1</span>&gt;</span> <span class="hljs-tag">&lt;<span class="hljs-name">field2</span>&gt;</span> <span class="hljs-tag">&lt;<span class="hljs-name">value2</span>&gt;</span>... <br>//查看哈希表 key 中，给定域 field 是否存在。 <br>hexists <span class="hljs-tag">&lt;<span class="hljs-name">key1</span>&gt;</span> <span class="hljs-tag">&lt;<span class="hljs-name">field</span>&gt;</span><br>//列出该hash集合的所有field<br>hkeys <span class="hljs-tag">&lt;<span class="hljs-name">key</span>&gt;</span><br>//列出该hash集合的所有value<br>hvals <span class="hljs-tag">&lt;<span class="hljs-name">key</span>&gt;</span><br>//为哈希表 key 中的域 field 的值加上增量<br>hincrby <span class="hljs-tag">&lt;<span class="hljs-name">key</span>&gt;</span> <span class="hljs-tag">&lt;<span class="hljs-name">field</span>&gt;</span> <span class="hljs-tag">&lt;<span class="hljs-name">increment</span>&gt;</span><br>//将哈希表 key 中的域 field 的值设置为 value ，当且仅当域 field 不存在 .<br>hsetnx <span class="hljs-tag">&lt;<span class="hljs-name">key</span>&gt;</span> <span class="hljs-tag">&lt;<span class="hljs-name">field</span>&gt;</span> <span class="hljs-tag">&lt;<span class="hljs-name">value</span>&gt;</span><br></code></pre></td></tr></table></figure><h3 id="2-数据结构-3"><a href="#2-数据结构-3" class="headerlink" title="(2)数据结构"></a>(2)数据结构</h3><p>当field-value长度较短且个数较少时，使用ziplist</p><p>否则使用hashtable</p><h2 id="5-ZSet（sorted-set有序集合）"><a href="#5-ZSet（sorted-set有序集合）" class="headerlink" title="5.ZSet（sorted set有序集合）"></a>5.ZSet（sorted set有序集合）</h2><p><strong>没有重复元素</strong>的字符串集合</p><p>有序集合的每个成员都关联了一个<strong>评分(score）</strong>,这个评分被用来按照从最低分到最高分的方式排序集合中的成员。<strong>集合的成员是唯一的</strong>，但是评分可以是重复了 。</p><h3 id="1-常用命令-4"><a href="#1-常用命令-4" class="headerlink" title="(1)常用命令"></a>(1)常用命令</h3><figure class="highlight pf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs pf">//将一个或多个 value 元素及其 score 值加入到有序集 key 当中。<br>zadd  <span class="hljs-variable">&lt;key&gt;</span> <span class="hljs-variable">&lt;score1&gt;</span> <span class="hljs-variable">&lt;value1&gt;</span> <span class="hljs-variable">&lt;score2&gt;</span> <span class="hljs-variable">&lt;value2&gt;</span>…<br>//返回有序集 key 中，下标在<span class="hljs-variable">&lt;start&gt;</span><span class="hljs-variable">&lt;stop&gt;</span>之间的元素<br>//带WITHSCORES，可以让分数一起和值返回到结果集。  <br>zrange <span class="hljs-variable">&lt;key&gt;</span> <span class="hljs-variable">&lt;start&gt;</span> <span class="hljs-variable">&lt;stop&gt;</span>  [WITHSCORES]   <br><br>//返回有序集 key 中，所有 score 值介于 <span class="hljs-keyword">min</span> 和 <span class="hljs-keyword">max</span> 之间(包括等于 <span class="hljs-keyword">min</span> 或 <span class="hljs-keyword">max</span> )的成员。有序集成员按 score 值递增(从小到大)次序排列。 <br>zrangebyscore key <span class="hljs-keyword">min</span> <span class="hljs-keyword">max</span> [withscores] [<span class="hljs-keyword">limit</span> offset count]<br>//同上，改为从大到小排列。 <br>zrevrangebyscore key <span class="hljs-keyword">max</span> <span class="hljs-keyword">min</span> [withscores] [<span class="hljs-keyword">limit</span> offset count]               <br><br>//为元素的score加上增量<br>zincrby <span class="hljs-variable">&lt;key&gt;</span> <span class="hljs-variable">&lt;increment&gt;</span> <span class="hljs-variable">&lt;value&gt;</span>      <br>//删除该集合下，指定值的元素 <br>zrem  <span class="hljs-variable">&lt;key&gt;</span> <span class="hljs-variable">&lt;value&gt;</span><br>//统计该集合，分数区间内的元素个数 <br>zcount <span class="hljs-variable">&lt;key&gt;</span> <span class="hljs-variable">&lt;min&gt;</span> <span class="hljs-variable">&lt;max&gt;</span><br>//返回该值在集合中的排名，从<span class="hljs-number">0</span>开始。<br>zrank <span class="hljs-variable">&lt;key&gt;</span> <span class="hljs-variable">&lt;value&gt;</span><br></code></pre></td></tr></table></figure><h3 id="2-数据结构-4"><a href="#2-数据结构-4" class="headerlink" title="(2)数据结构"></a>(2)数据结构</h3><p>hash和<strong>跳跃表</strong></p><h2 id="二-新数据类型"><a href="#二-新数据类型" class="headerlink" title="(二) 新数据类型"></a>(二) 新数据类型</h2><h2 id="1-Bitmaps"><a href="#1-Bitmaps" class="headerlink" title="1.Bitmaps"></a>1.Bitmaps</h2><ul><li><p>Bitmaps本身不是一种数据类型， 实际上它就是字符串（key-value） ， 但是它可以对字符串的<strong>位</strong>进行操作。</p></li><li><p>可以把Bitmaps想象成一个以位为单位的数组， 数组的每个单元只能存储0和1， 数组的下标在Bitmaps中叫做<strong>偏移量</strong>。</p></li></ul><img src="/2022/02/12/Redis/image-20211030193337884.png" alt="image-20211030193337884" style="zoom:100%;"><h3 id="1-常用命令-5"><a href="#1-常用命令-5" class="headerlink" title="(1)常用命令"></a>(1)常用命令</h3><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-regexp">//</span>设置Bitmaps中某个偏移量的值（<span class="hljs-number">0</span>或<span class="hljs-number">1</span>），偏移量以bit！！！！为单位<br>setbit &lt;key&gt; &lt;offset&gt; &lt;value&gt;<br><span class="hljs-regexp">//</span>获取Bitmaps中某个偏移量的值<br>getbit &lt;key&gt; &lt;offset&gt;<br><span class="hljs-regexp">//</span>统计字符串从start字节到end字节比特值为<span class="hljs-number">1</span>的数量，注意start和end为字节！！！！，且都包含<br>bitcount &lt;key&gt; [start end] <br><span class="hljs-regexp">//</span>多个Bitmaps的and（交集） 、 or（并集） 、 not（非） 、 xor（异或） 操作并将结果保存在&lt;destkey&gt;中<br>bitop and(or<span class="hljs-regexp">/not/</span>xor) &lt;destkey&gt; [key…]<br></code></pre></td></tr></table></figure><h2 id="2-HyperLogLog"><a href="#2-HyperLogLog" class="headerlink" title="2.HyperLogLog"></a>2.HyperLogLog</h2><p>每个HyperLogLog键只需要花费12kB内存，就可以计算接近2^64个不同元素的<strong>基数（即不重复元素的个数）</strong></p><p>只会储存根据输入元素计算出来的基数，而不会储存输入元素本身，所以 HyperLogLog 不能像集合那样，返回输入的<strong>各个</strong>元素。</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-regexp">//</span>添加指定元素到 HyperLogLog 中<br>pfadd &lt;key&gt; &lt;element&gt;...<br><span class="hljs-regexp">//</span>计算一个HLL（或多个HLL）的近似基数（计算有多少个数）<br>pfcount &lt;key&gt; [key ...] <br><span class="hljs-regexp">//</span>将一个或多个HLL合并后的结果存储在另一个HLL中<br>pfmerge &lt;destkey&gt; &lt;sourcekey&gt; [sourcekey ...]  <br></code></pre></td></tr></table></figure><h2 id="3-Geospatial"><a href="#3-Geospatial" class="headerlink" title="3.Geospatial"></a>3.Geospatial</h2><p>GEO，Geographic，地理信息的缩写。该类型，就是元素的2维坐标，在地图上就是经纬度。redis基于该类型，提供了经纬度设置，查询，范围查询，距离查询，经纬度Hash等常见操作。</p><figure class="highlight gherkin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs gherkin">//添加地理位置（经度，纬度，名称）<br>//有效的经度从 -180 度到 180 度。有效的纬度从 -85.05112878 度到 85.05112878 度。<br>//当坐标位置超出指定范围时，该命令将会返回一个错误。已经添加的数据，是无法再次往里面添加的。<br>geoadd<span class="hljs-variable">&lt;key&gt;</span><span class="hljs-variable">&lt;longitude&gt;</span><span class="hljs-variable">&lt;latitude&gt;</span><span class="hljs-variable">&lt;member&gt;</span> [longitude latitude member...]   <br><br>//获得指定地区的坐标值<br>geopos  <span class="hljs-variable">&lt;key&gt;</span> <span class="hljs-variable">&lt;member&gt;</span> [member...]<br><br>//获取两个位置之间的直线距离<br>geodist <span class="hljs-variable">&lt;key&gt;</span> <span class="hljs-variable">&lt;member1&gt;</span> <span class="hljs-variable">&lt;member2&gt;</span>  [m|<span class="hljs-string">km</span>|<span class="hljs-string">ft</span>|<span class="hljs-string">mi ]  </span><br><span class="hljs-string"></span><br><span class="hljs-string">//以给定的经纬度为中心，找出某一半径内的元素</span><br><span class="hljs-string">georadius &lt;key&gt; &lt;longitude&gt; &lt;latitude&gt; radius  m</span>|<span class="hljs-string">km</span>|<span class="hljs-string">ft</span>|<span class="hljs-string">mi   </span><br></code></pre></td></tr></table></figure><h1 id="三、Redis6-配置文件"><a href="#三、Redis6-配置文件" class="headerlink" title="三、Redis6 配置文件"></a>三、Redis6 配置文件</h1><p>见课件</p><h1 id="四、Redis6的发布和订阅"><a href="#四、Redis6的发布和订阅" class="headerlink" title="四、Redis6的发布和订阅"></a>四、Redis6的发布和订阅</h1><h2 id="1-定义"><a href="#1-定义" class="headerlink" title="1. 定义"></a>1. 定义</h2><p>Redis发布订阅(pub&#x2F;sub)是一种消息通信模式，pub(publish)发送者发送消息，sub(subscribe)订阅者接收消息</p><p>Redis 客户端可以订阅任意数量的频道。</p><img src="/2022/02/12/Redis/image-20211030115309171.png" alt="image-20211030115309171" style="zoom:100%;"><p>当给这个频道发布消息后，消息就会发送给订阅的客户端</p><img src="/2022/02/12/Redis/image-20211030115324742.png" alt="image-20211030115324742" style="zoom:100%;"><h2 id="2-实现"><a href="#2-实现" class="headerlink" title="2.实现"></a>2.实现</h2><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm"><span class="hljs-comment">#在一个客户端订阅channel1</span><br><span class="hljs-keyword">subscribe </span>channel1<br><span class="hljs-comment">#在另一个客户端向channel1发布消息hello</span><br>publish channel hello<br></code></pre></td></tr></table></figure><img src="/2022/02/12/Redis/image-20211030120039489.png" alt="image-20211030120039489" style="zoom:67%;"><h1 id="五、Jedis操作Redis6"><a href="#五、Jedis操作Redis6" class="headerlink" title="五、Jedis操作Redis6"></a>五、Jedis操作Redis6</h1><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-section">&lt;dependency&gt;</span><br>    <span class="hljs-section">&lt;groupId&gt;</span><span class="hljs-attribute">redis</span>.clients&lt;/groupId&gt;<br>    <span class="hljs-section">&lt;artifactId&gt;</span><span class="hljs-attribute">jedis</span>&lt;/artifactId&gt;<br>    <span class="hljs-section">&lt;version&gt;</span><span class="hljs-attribute">3</span>.<span class="hljs-number">2</span>.<span class="hljs-number">0</span>&lt;/version&gt;<br><span class="hljs-section">&lt;/dependency&gt;</span><br><br><span class="hljs-attribute">Jedis</span> jedis = new Jedis(<span class="hljs-string">&quot;192.168.137.3&quot;</span>,<span class="hljs-number">6379</span>);<br></code></pre></td></tr></table></figure><p>禁用Linux的防火墙：Linux(CentOS7)里执行命令</p><p><strong>systemctl stop&#x2F;disable firewalld.service</strong>  </p><p>redis.conf中注释掉bind 127.0.0.1 ,然后 protected-mode no</p><h1 id="六、Redis6和SpringBoot整合"><a href="#六、Redis6和SpringBoot整合" class="headerlink" title="六、Redis6和SpringBoot整合"></a>六、Redis6和SpringBoot整合</h1><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- redis --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-data-redis<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><br><span class="hljs-comment">&lt;!-- spring2.X集成redis所需common-pool2--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.apache.commons<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>commons-pool2<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.6.0<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><p>application.properties</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs properties"><span class="hljs-comment">#Redis服务器地址</span><br><span class="hljs-attr">spring.redis.host</span>=<span class="hljs-string">192.168.140.136</span><br><span class="hljs-comment">#Redis服务器连接端口</span><br><span class="hljs-attr">spring.redis.port</span>=<span class="hljs-string">6379</span><br><span class="hljs-comment">#Redis数据库索引（默认为0）</span><br><span class="hljs-attr">spring.redis.database</span>= <span class="hljs-string">0</span><br><span class="hljs-comment">#连接超时时间（毫秒）</span><br><span class="hljs-attr">spring.redis.timeout</span>=<span class="hljs-string">1800000</span><br><span class="hljs-comment">#连接池最大连接数（使用负值表示没有限制）</span><br><span class="hljs-attr">spring.redis.lettuce.pool.max-active</span>=<span class="hljs-string">20</span><br><span class="hljs-comment">#最大阻塞等待时间(负数表示没限制)</span><br><span class="hljs-attr">spring.redis.lettuce.pool.max-wait</span>=<span class="hljs-string">-1</span><br><span class="hljs-comment">#连接池中的最大空闲连接</span><br><span class="hljs-attr">spring.redis.lettuce.pool.max-idle</span>=<span class="hljs-string">5</span><br><span class="hljs-comment">#连接池中的最小空闲连接</span><br><span class="hljs-attr">spring.redis.lettuce.pool.min-idle</span>=<span class="hljs-string">0</span><br></code></pre></td></tr></table></figure><p>config</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.tt.config;<br><br><br><span class="hljs-comment">//import com.fasterxml.jackson.annotation.JsonAutoDetect;</span><br><span class="hljs-keyword">import</span> com.fasterxml.jackson.annotation.JsonAutoDetect;<br><span class="hljs-keyword">import</span> com.fasterxml.jackson.databind.ObjectMapper;<br><span class="hljs-keyword">import</span> org.springframework.cache.CacheManager;<br><span class="hljs-keyword">import</span> org.springframework.cache.annotation.CachingConfigurerSupport;<br><span class="hljs-keyword">import</span> org.springframework.cache.annotation.EnableCaching;<br><span class="hljs-keyword">import</span> org.springframework.context.annotation.Bean;<br><span class="hljs-keyword">import</span> org.springframework.context.annotation.Configuration;<br><span class="hljs-keyword">import</span> org.springframework.data.redis.cache.RedisCacheConfiguration;<br><span class="hljs-keyword">import</span> org.springframework.data.redis.cache.RedisCacheManager;<br><span class="hljs-keyword">import</span> org.springframework.data.redis.connection.RedisConnectionFactory;<br><span class="hljs-keyword">import</span> org.springframework.data.redis.core.RedisTemplate;<br><span class="hljs-keyword">import</span> org.springframework.data.redis.serializer.Jackson2JsonRedisSerializer;<br><span class="hljs-keyword">import</span> org.springframework.data.redis.serializer.RedisSerializationContext;<br><span class="hljs-keyword">import</span> org.springframework.data.redis.serializer.RedisSerializer;<br><span class="hljs-keyword">import</span> org.springframework.data.redis.serializer.StringRedisSerializer;<br><span class="hljs-keyword">import</span> com.fasterxml.jackson.annotation.PropertyAccessor;<br><br><span class="hljs-keyword">import</span> java.time.Duration;<br><br><span class="hljs-meta">@Configuration</span><br><span class="hljs-meta">@EnableCaching</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">RedisConfig</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">CachingConfigurerSupport</span>&#123;<br><br>    <span class="hljs-comment">//将redisTemplate放进容器中</span><br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-keyword">public</span> RedisTemplate&lt;String, Object&gt; <span class="hljs-title function_">redisTemplate</span><span class="hljs-params">(RedisConnectionFactory factory)</span> &#123;<br>        RedisTemplate&lt;String, Object&gt; template = <span class="hljs-keyword">new</span> <span class="hljs-title class_">RedisTemplate</span>&lt;&gt;();<br>        RedisSerializer&lt;String&gt; redisSerializer = <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringRedisSerializer</span>();<br>        <span class="hljs-type">Jackson2JsonRedisSerializer</span> <span class="hljs-variable">jackson2JsonRedisSerializer</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Jackson2JsonRedisSerializer</span>(Object.class);<br>        <span class="hljs-type">ObjectMapper</span> <span class="hljs-variable">om</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ObjectMapper</span>();<br>        om.setVisibility(PropertyAccessor.ALL, JsonAutoDetect.Visibility.ANY);<br>        om.enableDefaultTyping(ObjectMapper.DefaultTyping.NON_FINAL);<br>        jackson2JsonRedisSerializer.setObjectMapper(om);<br>        template.setConnectionFactory(factory);<br>        <span class="hljs-comment">//key序列化方式</span><br>        template.setKeySerializer(redisSerializer);<br>        <span class="hljs-comment">//value序列化</span><br>        template.setValueSerializer(jackson2JsonRedisSerializer);<br>        <span class="hljs-comment">//value hashmap序列化</span><br>        template.setHashValueSerializer(jackson2JsonRedisSerializer);<br>        <span class="hljs-keyword">return</span> template;<br>    &#125;<br><br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-keyword">public</span> CacheManager <span class="hljs-title function_">cacheManager</span><span class="hljs-params">(RedisConnectionFactory factory)</span> &#123;<br>        RedisSerializer&lt;String&gt; redisSerializer = <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringRedisSerializer</span>();<br>        <span class="hljs-type">Jackson2JsonRedisSerializer</span> <span class="hljs-variable">jackson2JsonRedisSerializer</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Jackson2JsonRedisSerializer</span>(Object.class);<br><span class="hljs-comment">//解决查询缓存转换异常的问题</span><br>        <span class="hljs-type">ObjectMapper</span> <span class="hljs-variable">om</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ObjectMapper</span>();<br>        om.setVisibility(PropertyAccessor.ALL, JsonAutoDetect.Visibility.ANY);<br>        om.enableDefaultTyping(ObjectMapper.DefaultTyping.NON_FINAL);<br>        jackson2JsonRedisSerializer.setObjectMapper(om);<br><span class="hljs-comment">// 配置序列化（解决乱码的问题）,过期时间600秒</span><br>        <span class="hljs-type">RedisCacheConfiguration</span> <span class="hljs-variable">config</span> <span class="hljs-operator">=</span> RedisCacheConfiguration.defaultCacheConfig()<br>                .entryTtl(Duration.ofSeconds(<span class="hljs-number">600</span>))<br>                .serializeKeysWith(RedisSerializationContext.SerializationPair.fromSerializer(redisSerializer))<br>                .serializeValuesWith(RedisSerializationContext.SerializationPair.fromSerializer(jackson2JsonRedisSerializer))<br>                .disableCachingNullValues();<br>        <span class="hljs-type">RedisCacheManager</span> <span class="hljs-variable">cacheManager</span> <span class="hljs-operator">=</span> RedisCacheManager.builder(factory)<br>                .cacheDefaults(config)<br>                .build();<br>        <span class="hljs-keyword">return</span> cacheManager;<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><p>controller</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.tt.control;<br><br><span class="hljs-keyword">import</span> org.springframework.beans.factory.annotation.Autowired;<br><span class="hljs-keyword">import</span> org.springframework.data.redis.core.RedisTemplate;<br><span class="hljs-keyword">import</span> org.springframework.web.bind.annotation.GetMapping;<br><span class="hljs-keyword">import</span> org.springframework.web.bind.annotation.RequestMapping;<br><span class="hljs-keyword">import</span> org.springframework.web.bind.annotation.RestController;<br><br><span class="hljs-meta">@RestController</span><br><span class="hljs-meta">@RequestMapping(&quot;/redisTest&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">RedisTestController</span> &#123;<br><br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> RedisTemplate redisTemplate;<br><br>    <span class="hljs-meta">@GetMapping(&quot;/get&quot;)</span><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">testRedis</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-comment">//设置值到redis</span><br>        redisTemplate.opsForValue().set(<span class="hljs-string">&quot;name&quot;</span>, <span class="hljs-string">&quot;lucy&quot;</span>);<br>        <span class="hljs-comment">//从redis中获取值</span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">name</span> <span class="hljs-operator">=</span> (String) redisTemplate.opsForValue().get(<span class="hljs-string">&quot;name&quot;</span>);<br>        <span class="hljs-keyword">return</span> name;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="七、Redis6的事务操作"><a href="#七、Redis6的事务操作" class="headerlink" title="七、Redis6的事务操作"></a>七、Redis6的事务操作</h1><p>Redis事务是一个单独的隔离操作：事务中的所有命令都会序列化、按顺序地执行。事务在执行的过程中，不会被其他客户端发送来的命令请求所打断。</p><p>Redis事务的主要作用就是**串联多个命令 ** 、 <strong>防止别的命令插队</strong>。</p><h2 id="1-命令"><a href="#1-命令" class="headerlink" title="1. 命令"></a>1. 命令</h2><p>从输入<strong>Multi</strong>命令开始，输入的命令都会依次进入命令队列中，但不会执行，直到输入<strong>Exec</strong>后，Redis会将之前的命令队列中的命令依次执行。</p><p>组队的过程中可以通过<strong>discard</strong>来放弃组队。（注意是全部放弃）</p><img src="/2022/02/12/Redis/image-20211101094002358.png" alt="image-20211101094002358" style="zoom:80%;"><h2 id="2-事务的错误处理"><a href="#2-事务的错误处理" class="headerlink" title="2.事务的错误处理"></a>2.事务的错误处理</h2><p>如果组队阶段输入有报错，则整个队列都无法执行</p><img src="/2022/02/12/Redis/image-20211101095828217.png" alt="image-20211101095828217" style="zoom:80%;"><p>组队成功，提交有成功、有失败</p><img src="/2022/02/12/Redis/image-20211101095800767.png" alt="image-20211101095800767" style="zoom:80%;"><h2 id="3-事务的冲突"><a href="#3-事务的冲突" class="headerlink" title="3. 事务的冲突"></a>3. 事务的冲突</h2><h3 id="1-问题描述"><a href="#1-问题描述" class="headerlink" title="(1) 问题描述"></a>(1) 问题描述</h3><img src="/2022/02/12/Redis/image-20211101111855203.png" alt="image-20211101111855203" style="zoom:80%;"><h3 id="2-悲观锁"><a href="#2-悲观锁" class="headerlink" title="(2) 悲观锁"></a>(2) 悲观锁</h3><p>操作之前先上锁——每次拿到数据后将数据上锁，别人想去拿这个数据时就会block，直到“我”释放了这个锁</p><p>传统关系型数据库里用到了很多这种锁的机制，例如行锁、表锁等，读锁、写锁等</p><h3 id="3-乐观锁-check-and-set"><a href="#3-乐观锁-check-and-set" class="headerlink" title="(3)乐观锁 check-and-set"></a>(3)乐观锁 check-and-set</h3><p> 更新数据时判断有没有别人已经更新了这个数据，如果更新了则“我”更新失败。（判断是否更新：使用版本号，更新成功则修改版本号）</p><p>乐观锁适用于<strong>多读</strong>的应用类型，可以提高吞吐率（例如抢票，大家都可以进入抢的页面，但是不是都能支付成功）</p><p><strong>watch key</strong></p><p><strong>unwatch key</strong> (如果执行了exec或者discard，直接unwatch key了)</p><figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs maxima">//在执行multi之前，先执行watch key1 [key2],可以监视一个(或多个) <span class="hljs-built_in">key</span> ，如果在事务执行之前这个(或这些) <span class="hljs-built_in">key</span> 被其他命令所改动，那么事务将被打断。<br>//如果没有watch <span class="hljs-built_in">key</span>，则两个事务可以修改同一个<span class="hljs-built_in">key</span><br>watch <span class="hljs-built_in">key</span><br></code></pre></td></tr></table></figure><h2 id="4-Redis事务三特性"><a href="#4-Redis事务三特性" class="headerlink" title="4. Redis事务三特性"></a>4. Redis事务三特性</h2><ul><li>单独的隔离操作 <ul><li>事务中的所有命令都会序列化、按顺序地执行。事务在执行的过程中，不会被其他客户端发送来的命令请求所打断。</li></ul></li><li>没有隔离级别的概念 <ul><li>队列中的命令没有提交之前都不会实际被执行，因为事务提交前任何指令都不会被实际执行</li></ul></li><li>不保证原子性 <ul><li>事务中如果有一条命令执行失败，其后的命令仍然会被执行，没有回滚</li></ul></li></ul><h1 id="八、Redis6持久化之RDB-Redis-DataBase"><a href="#八、Redis6持久化之RDB-Redis-DataBase" class="headerlink" title="八、Redis6持久化之RDB(Redis DataBase)"></a>八、Redis6持久化之RDB(Redis DataBase)</h1><p>在<strong>指定的时间间隔内</strong>将内存中的数据集快照写入磁盘， **&#x3D;&#x3D;Snapshot快照&#x3D;&#x3D;**，它恢复时是将快照文件直接读到内存里</p><p>默认开启</p><p>因为Redis是内存数据库，它将自己的数据库状态存储在内存里面，所以如果不想办法将存储在内存中的数据库状态保存到磁盘中，那么一旦服务器进程退出，服务器中的数据库状态也会消失。为了解决这个问题，Redis提供了RDB持久化功能，可以将Redis内存中的数据库状态保存到磁盘中，避免数据意外丢失</p><h2 id="1-RDB文件的创建和载入"><a href="#1-RDB文件的创建和载入" class="headerlink" title="1. RDB文件的创建和载入"></a>1. RDB文件的创建和载入</h2><p>两个Redis命令——SAVE和BGSAVE，</p><p>其中SAVE是阻塞式的，直到RDB文件创建完毕，阻塞期间，服务器不能处理任何命令请求</p><p>BGSAVE派生出fork子进程，由子进程创建RDB文件，父进程继续处理命令请求</p><table><thead><tr><th>命令</th><th>save</th><th>bgsave</th></tr></thead><tbody><tr><td>IO类型</td><td>同步</td><td>异步</td></tr><tr><td>是否阻塞redis其他命令</td><td>是</td><td>否（在生成子进程fork函数时会有短暂阻塞）</td></tr><tr><td>复杂度</td><td>O(n)</td><td>O(n)</td></tr><tr><td>优点</td><td>不会消耗额外内存</td><td>不阻塞客户端命令</td></tr><tr><td>缺点</td><td>阻塞客户端命令</td><td>需要fork子进程，大致两倍的膨胀性，消耗内存</td></tr></tbody></table><p>以下为伪代码</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">SAVE</span>():<br>    <span class="hljs-comment">#创建RDB文件</span><br>    rdbSave()<br> <br><span class="hljs-keyword">def</span> <span class="hljs-title function_">BGSAVE</span>():<br>    <span class="hljs-comment">#创建子进程</span><br>    pid = fork()<br>    <span class="hljs-keyword">if</span> pid == <span class="hljs-number">0</span>:<br>        <span class="hljs-comment">#子进程负责创建RDB文件并保存文件</span><br>        rdbSave()<br>        <span class="hljs-comment">#完成之后向父进程发出信号</span><br>        signal_parent()<br>    <span class="hljs-keyword">elif</span> pid &gt; <span class="hljs-number">0</span>:<br>        <span class="hljs-comment">#父进程继续处理命令请求，并通过轮询等待子进程信号</span><br>        handle_request_and_wait_signal()<br>    <span class="hljs-keyword">else</span>:<br>        <span class="hljs-comment">#处理出错情况</span><br>        handle_fork_error()<br></code></pre></td></tr></table></figure><p>持久化流程：</p><img src="/2022/02/12/Redis/image-20211101211942535.png" alt="image-20211101211942535" style="zoom:100%;"><p>**&#x3D;&#x3D;动态停止RDB&#x3D;&#x3D;**：redis-cli config set save “”#save后给空值，表示禁用保存策略</p><h2 id="2-自动间隔性保存"><a href="#2-自动间隔性保存" class="headerlink" title="2. 自动间隔性保存"></a>2. 自动间隔性保存</h2><p>因为BGSAVE命令可以在不阻塞服务器的情况下执行，所以Redis允许用户通过设置服务器配置的save选项，让服务器<strong>每隔一段时间</strong>自动执行一次BGSAVE命令。</p><img src="/2022/02/12/Redis/image-20211101185837827.png" alt="image-20211101185837827" style="zoom:80%;"><p>服务器状态redisServer结构体的saveparams属性中保存save选项设置的保存条件，</p><img src="/2022/02/12/Redis/image-20211101191148721.png" alt="image-20211101191148721 " style="zoom:80%;"><p>服务器状态还维持着一个dirty计数器和lastsave属性</p><ul><li>dirty计数器记录距离上一次成功执行SAVE命令或者BGSAVE命令之后，服务器对数据库状态（服务器中的所有数据库）进行了多少次修改（包括写入、删除、更新等操作）</li><li>lastsave属性是一个Unix时间戳，记录了服务器上一次成功执行SAVE命令或BGSAVE命令的时间</li></ul><p>Redis的服务器周期性操作函数serverCron默认每隔100毫秒就会执行一次，如果规定时间内满足了修改次数要求，则<strong>bgsave</strong></p><h2 id="3-redis-conf中的配置"><a href="#3-redis-conf中的配置" class="headerlink" title="3.redis.conf中的配置"></a>3.redis.conf中的配置</h2><ul><li><strong>save：</strong>这里是用来配置触发 Redis的 RDB 持久化条件，也就是什么时候将内存中的数据保存到硬盘。这时启动的是bgsave命令</li><li><strong>stop-writes-on-bgsave-error ：</strong>默认值为yes。后台存储过程中如果出现错误现象，是否停止保存操作</li><li><strong>rdbcompression ；</strong>默认值是yes。对于存储到磁盘中的快 照，可以设置是否进行压缩存储。如果是的话，redis会采用LZF算法进行压缩。</li><li><strong>rdbchecksum ：</strong>默认值是yes。在存储快照后，我们还可以让redis使用CRC64算法来进行数据校验，但是这样做会增加大约10%的性能消耗，如果希望获取到最大的性能提升，可以关闭此功能。</li><li><strong>dbfilename ：</strong>设置快照的文件名，默认是 <strong>&#x3D;&#x3D;dump.rdb&#x3D;&#x3D;</strong></li><li><strong>dir：</strong>设置快照文件的存放路径，这个配置项一定是个目录，而不能是文件名。默认是和当前配置文件保存在同一目录。</li></ul><h2 id="x3D-x3D-4-写时拷贝-COW-CopyOnWrite-x3D-x3D"><a href="#x3D-x3D-4-写时拷贝-COW-CopyOnWrite-x3D-x3D" class="headerlink" title="&#x3D;&#x3D;4. 写时拷贝(COW   CopyOnWrite)&#x3D;&#x3D;"></a>&#x3D;&#x3D;4. 写时拷贝(COW   CopyOnWrite)&#x3D;&#x3D;</h2><p>Redis 服务器会在触发 BGSAVE 时调用 redis Fork 函数来创建子进程并调用 rdbSave 在子进程中对数据进行持久化</p><ul><li><p>fork之后的子进程为什么能够获取父进程内存中的数据</p><p>调用 <code>fork</code> 后的父子进程会运行在不同的内存空间中，当 <code>fork</code> 发生时两者的<strong>内存空间有着完全相同的内容</strong>，对内存的写入和修改、文件的映射都是独立的，两个进程不会相互影响。</p><p>父子进程的内存在 fork 时是完全相同的，在 fork 之后父进程进行写入和修改也不会相互影响</p></li><li><p>fork函数带来的额外性能开销如何避免</p><p>&#x3D;&#x3D;写时拷贝&#x3D;&#x3D;：将拷贝推迟到写操作真正发生时，避免了大量无意义的拷贝操作</p></li></ul><p><strong>写时拷贝原理：</strong></p><p>在 fork 函数调用时，父进程和子进程会被 Kernel 分配到不同的虚拟内存空间中，所以在两个进程看来它们访问的是不同的内存：</p><ul><li>在真正访问虚拟内存空间时，Kernel 会将虚拟内存映射到物理内存上，所以父子进程共享了物理上的内存空间；</li><li>当父进程或者子进程对共享的内存进行修改时，共享的内存才会以页为单位进行拷贝，父进程会保留原有的物理空间，而子进程会使用拷贝后的新物理空间。</li></ul><h2 id="5-备份"><a href="#5-备份" class="headerlink" title="5. 备份"></a>5. 备份</h2><p>将*.rdb的文件拷贝到别的地方</p><p>rdb的恢复</p><ul><li><p>关闭Redis</p></li><li><p>先把备份的文件拷贝到工作目录下，修改备份文件的名称为dump.rdb</p></li><li><p>启动Redis, 备份数据会直接加载</p></li></ul><h2 id="6-优缺点"><a href="#6-优缺点" class="headerlink" title="6. 优缺点"></a>6. 优缺点</h2><p>优点</p><ul><li>适合大规模的数据恢复</li><li>对数据的完整性和一致性要求不高更适合使用（最后一次数据可能丢失）</li><li>节省磁盘空间</li><li>恢复速度快</li></ul><p>缺点</p><ul><li>最后一次持久化后的数据可能丢失</li><li>写时复制(COW)需要2倍的膨胀性能，消耗性能</li></ul><h1 id="九、Redis6持久化之AOF-Append-Only-File"><a href="#九、Redis6持久化之AOF-Append-Only-File" class="headerlink" title="九、Redis6持久化之AOF(Append Only File)"></a>九、Redis6持久化之AOF(Append Only File)</h1><p>以日志的形式记录每个<strong>写操作</strong>，将redis执行过的所有<strong>修改指令</strong>记录下来（读操作不记录），<strong>只许追加文件但不可以改写文件</strong></p><p>默认不开启（需要修改 ）</p><p>相比于RDB，AOF可以简单描述为**&#x3D;&#x3D;改记录数据为记录数据产生的过程&#x3D;&#x3D;**</p><h2 id="1-AOF流程"><a href="#1-AOF流程" class="headerlink" title="1.AOF流程"></a>1.AOF流程</h2><ul><li><p>命令追加(append)：将Redis的写命令追加到缓冲区aof_buf;</p></li><li><p>文件写入(write)和文件同步(sync)：根据不同的同步策略将aof_buf中的内容同步到硬盘;</p></li></ul><p>主进程接收客户端请求写命令，写入到aof_buf（aof缓冲区）然后主进程就返回了，有专门的子进程去调用fsync()函数把数据从aof_buf写入到aof文件。什么时候调用fsync()函数——appendfsync配置。</p><h2 id="2-AOF配置"><a href="#2-AOF配置" class="headerlink" title="2. AOF配置"></a>2. AOF配置</h2><p><strong>appendonly</strong> yes：开启AOF </p><p><strong>appendfilename</strong> “appendonly.aof”</p><p><strong>appendfsync</strong> ：同步频率，always为始终同步，每次Redis的写入都会立刻记入日志；性能较差但数据完整性比较好；everysec为每秒同步，每秒记入日志一次，如果宕机，本秒的数据可能丢失。no为redis不主动进行同步，把同步时机交给操作系统。</p><p><strong>no-appendfsync-on-rewrite</strong>：yes不写入aof文件只写入缓存，用户请求不会阻塞，但是在这段时间如果宕机会丢失这段时间的缓存数据。（降低数据安全性，提高性能）。no把数据往磁盘里刷，但是遇到重写操作，可能会发生阻塞。（数据安全，但是性能降低）</p><p><strong>异常恢复</strong>：&#x2F;usr&#x2F;local&#x2F;bin&#x2F; redis-check-aof–fix appendonly.aof</p><h2 id="3-Rewrite重写机制"><a href="#3-Rewrite重写机制" class="headerlink" title="3.  Rewrite重写机制"></a>3.  Rewrite重写机制</h2><p> <strong>重写后为什么会缩减文件大小</strong></p><ul><li>过期的数据不再写入文件</li><li>无效的命令不再写入文件：如有些数据被重复设值(set mykey v1, set mykey v2)、有些数据被删除了(sadd myset v1, del myset) 等。</li><li>多条命令可以合并为一个：如sadd myset v1, sadd myset v2， sadd myset v3可以合并为sadd myset v1 v2 v3。</li></ul><p><strong>重写方式</strong>：</p><ul><li>手动重写——bgrewriteaof</li></ul><img src="/2022/02/12/Redis/image-20211102102246066.png" alt="image-20211102102246066 " style="zoom:80%;"><ul><li>自动重写——配置触发条件</li></ul><p><strong>auto-aof-rewrite-min-size</strong> size<br><strong>auto-aof-rewrite-percentage</strong> percentage</p><p>在info Persistence里另外两个参数为aof_current_size和aof_base_size，其中aof_base_size为重写后的aof大小</p><p>自动重写触发条件：</p><p><strong>aof_current_size&gt;&#x3D; base_size +base_size*auto-aof-rewrite-percentage</strong> </p><p><strong>aof_current_size&gt;auto-aof-rewrite-min-size</strong></p><p><strong>重写流程：</strong></p><p>当redis开启了持久化功能，且达到了重写的条件：</p><p>1.调用fork系统级别函数，复制出完全一致的一个<strong>子进程</strong>，和主进程共用同一块内存空间</p><p>2.子进程调用aof_rewrite函数(redis客户端执行bgrewriteaof命令最终也是调用此函数)可以创建新的AOF文件去执行重写操作，根据已有数据进行命令的压缩和过期时间的检测并将压缩后的命令写入到新的AOF文件，直到写完</p><p>在AOF重写过程中，主进程是可以继续对外服务的，当接收到写命令，写入到<strong>AOF缓冲区</strong>后，然后判断此时是否正在执行重写操作，如果是再将写命令写入到<strong>AOF重写缓冲区</strong>，主进程返回</p><p>3.当子进程完成对AOF文件重写之后，它会向父进程发送一个完成信号，</p><p>4+5.父进程接到该完成信号之后，会调用一个信号处理函数，该函数完成以下工作：</p><ul><li>将<strong>AOF重写缓存中的内容</strong>全部写入到新的AOF文件中；这个时候新的AOF文件所保存的数据库状态和服务器当前的数据库状态一致；</li><li>对新的AOF文件进行改名，<strong>原子的</strong>覆盖原有的AOF文件；完成新旧两个AOF文件的替换。到这里才是一次完整的AOF重写流程</li></ul><img src="/2022/02/12/Redis/aof重写.png" alt="aof重写 " style="zoom:130%;"><h2 id="4-优缺点"><a href="#4-优缺点" class="headerlink" title="4.优缺点"></a>4.优缺点</h2><p>优点</p><ul><li>备份机制文件，丢失数据概率低</li><li>可以修复误操作导致的AOF</li></ul><p>缺点</p><ul><li>比RDB占用更多的磁盘空间</li><li>恢复备份速度慢一些</li><li>每次读写都同步有性能压力</li></ul><h1 id="十、Redis6的主从复制"><a href="#十、Redis6的主从复制" class="headerlink" title="十、Redis6的主从复制"></a>十、Redis6的主从复制</h1><h2 id="1-主从复制概述"><a href="#1-主从复制概述" class="headerlink" title="1.主从复制概述"></a>1.主从复制概述</h2><p><strong>提供数据方</strong>：master，主服务器、主节点、主库、主客户端</p><p>​    写数据、执行写操作的时候，将出现变化的数据自动同步到slave</p><p><strong>接收数据方</strong>：slave，从服务器、从节点、从库、从客户端</p><p>​    读数据（禁止写数据）</p><img src="/2022/02/12/Redis/image-20211103201313192.png" alt="image-20211103201313192 " style="zoom:80%;"><p><strong>主从复制的作用</strong>：</p><ul><li>读写分离：master写、slave读，提高服务器的读写负载能力</li><li>负载均衡：由slave分担master负载，根据需求的变化改变slave的数量，通过多个节点分担数据读取负载，大大提高redis服务器并发量与数据吞吐量</li><li>故障恢复：当master出现问题时，由slave推选出一个master来提供写的服务，实现快速的故障恢复</li><li>数据冗余：实现数据热备份，持久化之外的一种数据备份方式</li><li>高可用基石：基于主从复制，构建哨兵模式和高可用方案</li></ul><h2 id="2-主从复制工作流程"><a href="#2-主从复制工作流程" class="headerlink" title="2. 主从复制工作流程"></a>2. 主从复制工作流程</h2><h3 id="1-总述"><a href="#1-总述" class="headerlink" title="(1)总述"></a>(1)<strong>总述</strong></h3><ul><li>阶段一：建立连接阶段</li><li>阶段二：数据同步阶段：第一次建立连接后同步数据</li><li>阶段三：命令传播阶段：保证主从状态一致</li></ul><h3 id="2-阶段一：slave连接master"><a href="#2-阶段一：slave连接master" class="headerlink" title="(2)阶段一：slave连接master"></a>(2)<strong>阶段一</strong>：slave连接master</h3><img src="/2022/02/12/Redis/image-20211103220423448.png" alt="image-20211103220423448 " style="zoom:60%;"><p>开启主客户端和从客户端（<strong>需要开启redis-cli</strong>，不然报错），slave输入密码后，连接master（此时master可以不输入密码）</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-regexp">//</span>连接<br>slaveof &lt;masterip&gt; &lt;masterport&gt;<br><span class="hljs-regexp">//</span>断开连接<br>slaveof no one<br><span class="hljs-regexp">//</span>如果主客户端设置了密码，则需要从客户端在conf文件中配置密码<br><span class="hljs-regexp">//</span>配置<br>masterauth &lt;password&gt;<br></code></pre></td></tr></table></figure><h3 id="3-阶段二：数据同步阶段【全量复制】-【部分复制】"><a href="#3-阶段二：数据同步阶段【全量复制】-【部分复制】" class="headerlink" title="(3)阶段二：数据同步阶段【全量复制】 **+**【部分复制】"></a>(3)<strong>阶段二</strong>：数据同步阶段【全量复制】 **+**【部分复制】</h3><ul><li><p>master使用RDB是因为RDB恢复数据快</p></li><li><p>slave接收RDB之后，要<strong>清空数据</strong>再执行RDB文件恢复过程</p></li><li><p><strong>复制（积压）缓冲区</strong>类似于AOF中的重写缓冲区，保存RDB快照之后的指令，且master知道了到底传了多少数据给slave，下次复制从下一条数据开始传</p></li><li><p>由于是指令，slave接收之后先执行bgrewriteaof再恢复数据</p></li></ul><img src="/2022/02/12/Redis/image-20211104233211918.png" alt="image-20211104233211918 " style="zoom:150%;"><p><strong>一些说明</strong></p><p><strong>1.master</strong></p><ul><li><p>如果master数据量巨大，则数据同步应该避开高峰期</p></li><li><p>缓冲区的大小设置需谨慎，如果数据溢出，则会挤掉头部数据，进行部分复制的时候如果发现数据已经丢失了，则必须进行第二次全量复制，致使slave陷入死循环</p><p>&#x3D;&#x3D;修改缓冲区大小&#x3D;&#x3D;：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">repl</span>-backlog-size <span class="hljs-number">1</span>mb<br></code></pre></td></tr></table></figure></li><li><p>master单机内存占用主机内存的比例不应过大，建议50%-70%， 留下30%-50%的内存用于执行bgsave命令和创建复制缓冲区</p></li></ul><p><strong>2.slave</strong></p><ul><li><p>关闭复制时的对外服务</p><figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs coffeescript">slave-serve-stale-data <span class="hljs-literal">yes</span>|<span class="hljs-literal">no</span><br></code></pre></td></tr></table></figure></li><li><p>slave过多时，建议调整拓扑结构，由一主多从结构变为树状结构，中间的节点既是master，也是slave。但是此时层级深度导致最深层的slave和顶层的master间数据同步延迟较大，数据一致性变差，谨慎选择。</p></li><li><p>多个slave同时对master请求数据同步，master发送的RDB文件增多，会对带宽造成巨大冲击，应适量错峰</p></li></ul><h3 id="4-阶段三：命令传播阶段"><a href="#4-阶段三：命令传播阶段" class="headerlink" title="(4)阶段三：命令传播阶段"></a>(4)<strong>阶段三</strong>：命令传播阶段</h3><p>当master数据库状态被修改后，需要让主从数据同步到一致的状态，同步的动作称作<strong>命令传播</strong></p><p>此时如果发生了长时间网络中断，则直接【全量复制】</p><p>如果是短时间网络中断，则【部分复制】——复制积压缓冲区（在阶段二也用过）</p><p>【心跳机制】</p><p>master和slave需要进行信息交换和确保双方在线</p><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs livecodeserver"><span class="hljs-built_in">min</span>-slaves-<span class="hljs-built_in">to</span>-<span class="hljs-built_in">write</span> <span class="hljs-number">2</span><br><span class="hljs-built_in">min</span>-slaves-<span class="hljs-built_in">max</span>-lag <span class="hljs-number">8</span><br><span class="hljs-comment">#slave数量少于2个，或者所有slave的延迟都&gt;=8s时，强制关闭master写功能，停止数据同步</span><br></code></pre></td></tr></table></figure><ul><li>master心跳<ul><li>指令：PING</li><li>周期：由repl-ping-slave-period决定，默认10秒</li><li>作用：判断slave是否在线</li><li>查询：INFO replication</li></ul></li><li>slave心跳<ul><li>指令：REPLCONF ACK{offset}</li><li>周期：1秒</li><li>作用1：汇报自己offset，获取最新的数据变更指令</li><li>作用2：判断master是否在线</li></ul></li></ul><p>【复制积压缓冲区】</p><p>（概念）</p><p>先进先出的队列，用于储存master收到的指令（仅影响数据变更的指令，例如set、del、&#x3D;&#x3D;select(换库)&#x3D;&#x3D;）</p><p>（储存内容）【偏移量offset】+【字节值】</p><p>“set name itheima”</p><img src="/2022/02/12/Redis/image-20211104232431180.png" alt="image-20211104232431180" style="zoom:67%;"><img src="/2022/02/12/Redis/image-20211104232454698.png" alt="image-20211104232454698 " style="zoom:50%;"><p>master记录已发送信息对应的offset（多个）</p><p>slave记录已接收信息对应的offset（单个）</p><p>根据master和slave的 offset的不同查看是否正常传播</p><p><img src="/2022/02/12/Redis/Redis%5Cimage-20211104234427526.png" alt="image-20211104234427526"></p><h1 id="十一、哨兵模式"><a href="#十一、哨兵模式" class="headerlink" title="十一、哨兵模式"></a>十一、哨兵模式</h1><p>哨兵(sentinel) 是一个分布式系统，用于对主从结构中的每台服务器进行**&#x3D;&#x3D;监控&#x3D;&#x3D;<strong>，当出现故障时通过</strong>&#x3D;&#x3D;投票机制&#x3D;&#x3D;**选择新的master并将所有slave连接到新的master。</p><p>哨兵也是一个redis服务器，只是不提供数据服务，通常哨兵配置为**&#x3D;&#x3D;单数&#x3D;&#x3D;**</p><ul><li><p>监控</p><p>不断检查master和slave是否正常运行</p><p>master存活检测、master与slave运行情况检测</p></li><li><p>通知（提醒）</p><p>当被监控的服务器出现问题时，向其他（哨兵间、客户端）发送通知</p></li><li><p>自动故障转移</p><p>当master宕机时，断开master与slave连接，选取一个slave作为master，将其他slave连接到新的master，并告知客户端新的服务器地址</p></li></ul><h2 id="1-配置哨兵"><a href="#1-配置哨兵" class="headerlink" title="1.配置哨兵"></a>1.配置哨兵</h2><h2 id="2-工作原理"><a href="#2-工作原理" class="headerlink" title="2.工作原理"></a>2.工作原理</h2><h3 id="阶段一：监控阶段"><a href="#阶段一：监控阶段" class="headerlink" title="阶段一：监控阶段"></a>阶段一：监控阶段</h3><ul><li><p>sentinel向master发送【info】指令，并且建立了【cmd连接】（专门用来发送命令），并保存了master、slave、sentinel等相关的信息，且master也保存了<strong>SentinelRedisInstance</strong></p></li><li><p>由于【info】指令中获取了到了slave的信息，sentinel向每一个slave发送【info】指令并保存</p></li><li><p>新的sentinel_new连接master时，同样也是发送【info】指令，并发现master所保存的<strong>SentinelRedisInstance</strong>中已经有了sentinel，sentinel_new在此基础上保存相关信息，master也会更新信息</p></li><li><p>sentinel和sentinel_new之间建立<strong>发布订阅机制</strong>，且可以互发【ping】指令来确保相互连通</p></li></ul><img src="/2022/02/12/Redis/image-20211109154034550.png" alt="image-20211109154034550 " style="zoom:50%;"><img src="/2022/02/12/Redis/image-20211109154251588.png" alt="image-20211109154251588 " style="zoom:67%;"><h3 id="阶段二：通知阶段"><a href="#阶段二：通知阶段" class="headerlink" title="阶段二：通知阶段"></a>阶段二：通知阶段</h3><p>维护长期sentinel间信息对等</p><p>sentinel向master、slave通过cmd连接发送helllo信息，获取对应的工作状态，并在sentinel的发布订阅圈内进行信息互通。</p><img src="/2022/02/12/Redis/image-20211109154533925.png" alt="image-20211109154533925 " style="zoom:60%;"><h3 id="阶段三：故障转移阶段，只针对master"><a href="#阶段三：故障转移阶段，只针对master" class="headerlink" title="阶段三：故障转移阶段，只针对master"></a>阶段三：故障转移阶段，只针对master</h3><p><strong>1.发现故障：【master】宕机</strong></p><figure class="highlight smali"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs smali">sentinel down-after-milliseconds &lt;masterName&gt; &lt;timeout&gt;<br>sentinel<span class="hljs-built_in"> monitor </span>&lt;masterName&gt; &lt;ip&gt; &lt;port&gt; &lt;quorum&gt;<br></code></pre></td></tr></table></figure><p>（1）一个sentinel发现master宕机，主观下线【SDOWN】</p><p>服务器在down-after-milliseconds给定的毫秒数之内， 没有返回 Sentinel 发送的【PING】命令（每秒一次）的回复， 或者返回一个错误， 那么 Sentinel 将这个服务器标记为主观下线（SDOWN ）</p><p>（2）至少有quorum个sentinel确认master宕机，客观下线【ODOWN】【其中，quorum的值一般设置为sentinel个数的二分之一取顶】</p><img src="/2022/02/12/Redis/image-20211109160056468.png" alt="image-20211109160056468 " style="zoom:50%;"><p><strong>2.竞选自动故障迁移操作责任人</strong></p><p>一个redis服务被判断为客观下线时，多个监视该服务的sentinel协商，选举一个领头sentinel，对该redis服务进行故障转移操作。</p><ul><li>所有的sentinel都有公平被选举成领头的资格。</li><li>所有的sentinel都有且只有一次将某个sentinel选举成领头的机会（在一轮选举中），一旦选举某个sentinel为领头，不能更改。</li><li>sentinel设置领头sentinel是先到先得，一旦当前sentinel设置了领头sentinel，以后要求设置sentinel为领头请求都会被拒绝。</li><li>每个<strong>发现服务客观下线的sentinel</strong>，都会要求其他sentinel将自己设置成领头。</li><li>当一个sentinel（源sentinel）向另一个sentinel（目sentinel）发送<strong>is-master-down-by-addr ip port current_epoch runid</strong>命令的时候，runid参数不是*，而是sentinel运行id，就表示源sentinel要求目标sentinel选举其为领头。</li><li>源sentinel会检查目标sentinel对其要求设置成领头的回复，如果回复的leader_runid和leader_epoch为源sentinel，表示目标sentinel同意将源sentinel设置成领头。</li><li>如果某个sentinel被<strong>半数以上【quorum】的sentinel设置成领头</strong>，那么该sentinel既为领头。</li><li>如果在限定时间内，没有选举出领头sentinel，暂定一段时间，再选举。</li></ul><p><strong>3.slave选举</strong></p><p>当一个sentinel准备好了要进行failover，并且收到了其他sentinel的授权，那么就需要选举出一个合适的slave来做为新的master。</p><ul><li>在线的</li><li>响应快的</li><li>和原master断开时间短的</li><li>优先原则<ul><li>优先级</li><li>offset</li><li>runid</li></ul></li></ul><p>在线、和原master失去联系小于10次、每次都不超过配置的最大失联时间，则成为master候选人列表，并根据下面顺序进行排序：</p><p>1）sentinel首先会根据slaves的优先级来进行排序，优先级越小排名越靠前。<br>2）如果优先级相同，则查看复制的下标，哪个从master接收的复制数据多，哪个就靠前。<br>3）如果优先级和下标都相同，就选择进程ID较小的那个</p><p><strong>4.新master上任，其他slave切换master，原master作为slave，故障回复后连接</strong></p><p>向新的master发送slaveof no one</p><p>向其他slave发送slave 新masterIP 新master端口</p><h1 id="十二、集群cluster"><a href="#十二、集群cluster" class="headerlink" title="十二、集群cluster"></a>十二、集群cluster</h1><h2 id="1-简介"><a href="#1-简介" class="headerlink" title="1. 简介"></a>1. 简介</h2><p><strong>集群架构</strong></p><ul><li>集群就是使用网络将若干台计算机联通起来，并提供统一的管理方式，使其对外呈现单机的服务效果</li></ul><p><strong>集群作用</strong></p><ul><li>分散单台服务器的访问压力，实现<strong>负载均衡</strong></li><li>分散单台服务器的储存压力，实现<strong>可扩展性</strong></li><li>降低单台服务器宕机带来的<strong>业务灾难</strong></li></ul><h2 id="2-Redis集群结构设计"><a href="#2-Redis集群结构设计" class="headerlink" title="2. Redis集群结构设计"></a>2. Redis集群结构设计</h2><p><strong>数据存储设计</strong></p><ul><li>计算出key应该保存的位置</li><li>将所有的储存空间切割成<strong>16384</strong>份，每台主机保存一部分（注意：每份代表的是一个存储空间，不是一个key的保存空间）</li><li>将key按照计算出的结果放到对应的储存空间</li></ul><img src="/2022/02/12/Redis/image-20211110101631973.png" alt="image-20211110101631973 " style="zoom:80%;"><img src="/2022/02/12/Redis/image-20211110101616711.png" alt="image-20211110101616711 " style="zoom:68%;"><ul><li>增强可扩展性</li></ul><p>&#x3D;&#x3D;每一个存储空间被称为“<strong>槽</strong>”（slot， 每一个小格子），增&#x2F;去节点——改变槽所存储的位置&#x3D;&#x3D;，只有master有槽，slave没有槽</p><img src="/2022/02/12/Redis/image-20211110101825743-1636527404596.png" alt="image-20211110101825743 " style="zoom:67%;"><p><strong>集群内部通讯设计</strong></p><ul><li>各个数据库互相通信，保存各个库中槽的编号数据</li><li>一次命中，直接返回</li><li>一次未命中，告知具体位置</li></ul><img src="/2022/02/12/Redis/集群存储通讯设计.png" alt="集群存储通讯设计 " style="zoom:50%;"><h2 id="3-集群结构搭建"><a href="#3-集群结构搭建" class="headerlink" title="3.集群结构搭建"></a>3.集群结构搭建</h2><p><strong>cluster配置</strong></p><figure class="highlight pf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs pf"><span class="hljs-comment">#启动cluster配置</span><br>cluster-enabled yes|<span class="hljs-keyword">no</span><br><span class="hljs-comment">#配置文件名</span><br>cluster-config-file <span class="hljs-variable">&lt;filename&gt;</span><br><span class="hljs-comment">#节点服务响应超时时间，用于判定节点是否下线或切换为从节点</span><br>cluster-node-timeout <span class="hljs-variable">&lt;milliseconds&gt;</span><br><span class="hljs-comment">#(选配)master连接slave的最小数量</span><br>cluster-migration-barrier <span class="hljs-variable">&lt;count&gt;</span><br></code></pre></td></tr></table></figure><p><strong>cluster节点操作命令</strong></p><figure class="highlight pf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs pf"><span class="hljs-comment">#查看集群节点信息</span><br>cluster nodes<br><span class="hljs-comment">#进入一个从节点redis,切换其主节点</span><br>cluster replicate <span class="hljs-variable">&lt;master-id&gt;</span><br><span class="hljs-comment">#发现一个新节点，新增主节点</span><br>cluster meet ip:<span class="hljs-keyword">port</span><br><span class="hljs-comment">#忽略一个没有slot的节点</span><br>cluster forget <span class="hljs-variable">&lt;id&gt;</span><br><span class="hljs-comment">#手动故障转移</span><br>cluster failover<br></code></pre></td></tr></table></figure><p><strong>cluster启动</strong></p><figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs axapta"><span class="hljs-meta">#启动所有的server</span><br>redis-<span class="hljs-keyword">server</span> redis.conf<br></code></pre></td></tr></table></figure><img src="/2022/02/12/Redis/image-20211110134612200.png" alt="image-20211110134612200 " style="zoom:67%;"><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs dns">#安装ruby和gem<br>#执行trib.rb，在trib.rb所在的目录下执行<br>#其中<span class="hljs-number">1</span>指slave:master的比例数<br>#后面是集群里的所有的nodes，前面的是master，后面的是slave，和slave:master比例数相对应<br>#如下，<span class="hljs-number">6379、6380</span>、<span class="hljs-number">6381</span>是master，对应的slave分别是<span class="hljs-number">6382、6383</span>、<span class="hljs-number">6384</span><br>./redis-trib.rb create --replicas <span class="hljs-number">1 127.0.0</span>.<span class="hljs-number">1:6379 127</span>.<span class="hljs-number">0</span>.<span class="hljs-number">0.1:6380</span> <span class="hljs-number">127.0.0.1</span>:<span class="hljs-number">6381 127.0</span>.<span class="hljs-number">0.1:6382</span> <span class="hljs-number">127.0.0.1</span>:<span class="hljs-number">6383 127.0</span>.<span class="hljs-number">0.1:6384</span><br></code></pre></td></tr></table></figure><p>给master分配slot</p> <img src="/2022/02/12/Redis/image-20211110135519669.png" alt="image-20211110135519669 " style="zoom:67%;"><p>给master分配slave </p><img src="/2022/02/12/Redis/image-20211110135444856.png" alt="image-20211110135444856 " style="zoom:68%;"><p>同时在配置文件中记录分配的slots和主从关系</p><img src="/2022/02/12/Redis/image-20211110135932299.png" alt="image-20211110135932299" style="zoom:80%;"><p><strong>面向数据操作</strong></p><figure class="highlight avrasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs avrasm"><span class="hljs-meta">#连接客户端时，将数据放在对应的槽里面，并自动切换端口</span><br>redis-<span class="hljs-keyword">cli</span> -c<br></code></pre></td></tr></table></figure><img src="/2022/02/12/Redis/image-20211110140510889.png" alt="image-20211110140510889 " style="zoom:68%;"><p><strong>主从下线和主从切换</strong></p><p>如果主下线了，对应的从变成主，主如果后续上线，则变成从，其他的节点记录改变的信息</p><p>如果从下线了，其他节点记录改变的信息</p><h1 id="十三、企业级解决方案"><a href="#十三、企业级解决方案" class="headerlink" title="十三、企业级解决方案"></a>十三、企业级解决方案</h1><h2 id="1、缓存预热"><a href="#1、缓存预热" class="headerlink" title="1、缓存预热"></a>1、缓存预热</h2><p>服务器启动之后迅速宕机——</p><ul><li>请求数据量高</li><li>主从之间数据吞吐量较大，数据同步操作频度高</li></ul><p><strong>解决方案</strong></p><ul><li>日常统计数据访问记录，统计访问频度较高的<strong>热点数据</strong></li><li>利用<strong>LRU</strong>(Least Recently Used)数据删除策略，构建数据留存队列</li></ul><p><strong>准备工作</strong></p><ul><li>将统计结果中的数据分类，根据级别，redis优先加载级别较高的热点数据</li><li>利用分布式，多服务器同时进行数据读取，提速数据加载过程</li><li>热点数据主从同时预热</li></ul><p><strong>实施</strong></p><ul><li>使用脚本程序固定数据预热过程</li><li>如果条件允许，使用CDN（内容分发网络）</li></ul><h2 id="2、缓存雪崩"><a href="#2、缓存雪崩" class="headerlink" title="2、缓存雪崩"></a>2、缓存雪崩</h2><p><strong>问题：    短时间内大量Key集中过期</strong></p><ul><li>现象：<ul><li>系统平稳运行过程中，忽然数据库连接量激增【在此期间请求访问过期的数据，redis未命中，redis向数据库索取数据】</li><li>应用数据库无法及时处理请求，出现408、500错误页面、数据库崩溃【客户拿不到数据反复刷新页面，redis大量请求积压，开始出现超时现象，数据库流量激增，数据库崩溃】</li><li>应用服务器崩溃、redis服务器崩溃、redis集群瓦解【即使重启，仍然面对缓存中无数据可用的情况】</li></ul></li><li>解决方案：<ul><li>构建多级缓存架构：Nginx缓存+Redis缓存+ehcache缓存</li><li>优化Mysql耗时业务：例如超时查询、耗时较高的事务</li><li>灾难预警机制：<ul><li>监控Redis服务器性能指标：CPU占用、使用率，内存容量，查询平均响应时间，线程数</li></ul></li><li><strong>LRU</strong>换成<strong>LFU</strong>(Least Frequently Used)</li><li>数据有效期策略调整<ul><li>根据业务数据<strong>过期时间进行分类错峰</strong></li><li>过期时间使用固定时间+随机值的形式</li></ul></li><li><strong>超热数据</strong>使用永久key</li><li>定期维护【对即将过期的数据做访问量分析：热点数据进行延时】</li><li>加锁【慎用！】</li></ul></li></ul><p><strong>问题：   Redis中某个key过期且单个key高热</strong></p><ul><li>现象<ul><li>系统平稳运行过程中，数据库连接量瞬间激增</li><li>Redis服务器无大量key过期，内存平稳无波动，且Redis的CPU正常</li><li>数据库崩溃</li></ul></li><li>解决方案：<ul><li>预先设定【例如购物节的主打产品等】</li><li>现场调整：监控访问量，对自然流量激增的数据延长过期时间或设置为永久key</li><li>后台刷新数据：启动定时任务，高峰期来临时刷新数据有效期，确保不丢失</li><li>二级缓存：二级缓存设置不同的生效时间，保障不会被<strong>同时</strong>淘汰</li><li>加锁：分布式锁，防止被击穿，注意性能瓶颈【慎重】</li></ul></li></ul><h2 id="4、缓存穿透"><a href="#4、缓存穿透" class="headerlink" title="4、缓存穿透"></a>4、缓存穿透</h2><p><strong>问题：  Redis中出现大量未击中，出现非正常URL访问</strong>（大概率黑客攻击）</p><ul><li>现象<ul><li>获取的数据在数据库中也不存在，数据库查询未得到对应的数据</li></ul></li><li>解决方案<ul><li>缓存null</li><li>白名单策略<ul><li>提前预热各种分类数据id对应的bitmaps，id作为bitmaps的offset，加载到正常数据时放行，异常数据直接拦截</li><li>使用<strong>布隆过滤器</strong></li></ul></li><li>监控<ul><li></li></ul></li></ul></li></ul><h2 id="5、性能指标监控"><a href="#5、性能指标监控" class="headerlink" title="5、性能指标监控"></a>5、性能指标监控</h2>]]></content>
    
    
    <categories>
      
      <category>数据库</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据库</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>MyBatis笔记</title>
    <link href="/2022/02/09/MyBatis/"/>
    <url>/2022/02/09/MyBatis/</url>
    
    <content type="html"><![CDATA[<h1 id="第一章-概念"><a href="#第一章-概念" class="headerlink" title="第一章  概念"></a>第一章  概念</h1><p><a href="https://mybatis.org/mybatis-3/zh/configuration.html">mybatis官方文档</a></p><h2 id="1-三层架构"><a href="#1-三层架构" class="headerlink" title="1.三层架构"></a>1.三层架构</h2><p>界面层：和用户打交道的，接收用户的请求参数，显示处理结果。（jsp，html负责显示参数，servlet负责接收请求参数）</p><p>业务逻辑层：接收界面层传递的数据，计算逻辑，调用数据库获取数据</p><p>数据访问层（持久层）：访问数据库，执行对数据的查询、修改、删除等。</p><h3 id="三层对应的包"><a href="#三层对应的包" class="headerlink" title="三层对应的包"></a>三层对应的包</h3><p>​    界面层：controller 包（servlet）</p><p>​    业务逻辑层：service包（XXXService类）</p><p>​    数据访问层：dao包（XXXDao类）</p><h3 id="三层中类的交互"><a href="#三层中类的交互" class="headerlink" title="三层中类的交互"></a>三层中类的交互</h3><p>​    用户使用界面层–&gt;业务逻辑层–&gt;数据访问层–&gt;数据库</p><h3 id="三层对应的处理框架"><a href="#三层对应的处理框架" class="headerlink" title="三层对应的处理框架"></a>三层对应的处理框架</h3><p>​    界面层—–servlet—–$\textcolor{Red}{springmvc} $</p><p>​    业务逻辑层—–service类—–$\textcolor{Red}{spring} $</p><p>​    数据访问层—–dao类—–$\textcolor{Red}{mybatis} $</p><p>&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;     &#x3D;&#x3D;&#x3D;&#x3D;</p><p>所以mybatis是用来访问数据库的一个基本框架</p><h2 id="2-MyBatis框架"><a href="#2-MyBatis框架" class="headerlink" title="2.MyBatis框架"></a>2.MyBatis框架</h2><p>1.SQL Mapper：SQL映射</p><p>​    可以把数据库表中的一行数据映射为一个java对象</p><p>​    一行数据可以看做是一个java对象，操作这个对象即操作表中的数据</p><p>2.Data Access Object(DAOs)：数据访问，对数据库进行增删改查</p><h3 id="提供的功能"><a href="#提供的功能" class="headerlink" title="提供的功能"></a>提供的功能</h3><p>1.提供了创建Connection  , Statement , ResultSet的能力</p><p>2.提供了执行sql语句的能力，不需要开发人员执行sql语句</p><p>3.提供了循环sql，把sql的结果转换成java对象，List集合的能力</p><p>在JDBC中有这样的代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><pre><code class="hljs JDBC">while(rs.next())&#123;<br>Student stu = new Student();<br>stu.setId(rs.getInt(&quot;id&quot;)):<br>stu.setName(rs.getInt(&quot;name&quot;)):<br>stu.setAge(rs.getInt(&quot;age&quot;)):<br>//从数据库取出数据转化成Student对象，封装到List集合<br>stuList.add(stu);<br>&#125;<br></code></pre></td></tr></table></figure><p>4.提供了关闭资源的能力，不需要手动关闭Connection, Statement, ResultSet</p><img src="/2022/02/09/MyBatis/mybatis-1627872197463.png" style="zoom:80%;"><p>主配置文件一定在资源文件夹下（main目录下）：</p><img src="/2022/02/09/MyBatis/image-20210802105622067.png" alt="image-20210802105622067" style="zoom: 80%;"><p>主配置文件主要做两件事情：</p><p>连接数据库和指定mapper文件的位置</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java">&lt;environments <span class="hljs-keyword">default</span>=<span class="hljs-string">&quot;mydev&quot;</span>&gt;<br>    &lt;environment id=<span class="hljs-string">&quot;mydev&quot;</span>&gt;<br>        &lt;transactionManager type=<span class="hljs-string">&quot;JDBC&quot;</span>/&gt;<br>        &lt;!-- 表示数据源，连接数据库的，type表示数据源的类型，<span class="hljs-string">&quot;POOLED&quot;</span>表示连接池--&gt;<br>        &lt;dataSource type=<span class="hljs-string">&quot;POOLED&quot;</span>&gt;<br>            &lt;!--数据库的驱动类名 --&gt;<br>            &lt;property name=<span class="hljs-string">&quot;driver&quot;</span> value=<span class="hljs-string">&quot;$&#123;jdbc.driver&#125;&quot;</span>/&gt;<br>            &lt;!--                连接数据库的url字符串,这个地方localhost:<span class="hljs-number">1234</span>一定是：，指的是端口--&gt;<br>            &lt;property name=<span class="hljs-string">&quot;url&quot;</span> value=<span class="hljs-string">&quot;$&#123;jdbc.url&#125;&quot;</span>/&gt;<br>            &lt;!--                访问数据库的用户名称--&gt;<br>            &lt;property name=<span class="hljs-string">&quot;username&quot;</span> value=<span class="hljs-string">&quot;$&#123;jdbc.username&#125;&quot;</span>/&gt;<br>            &lt;!--                数据库密码--&gt;<br>            &lt;property name=<span class="hljs-string">&quot;password&quot;</span> value=<span class="hljs-string">&quot;$&#123;jdbc.password&#125;&quot;</span>/&gt;<br>        &lt;/dataSource&gt;<br>    &lt;/environment&gt;<br>&lt;/environments&gt;<br>                <br>&lt;mappers&gt;<br>&lt;!--        &lt;mapper resource=<span class="hljs-string">&quot;twinkle/dao/StudentDao.xml&quot;</span>/&gt;--&gt;<br>&lt;<span class="hljs-keyword">package</span> name=<span class="hljs-string">&quot;twinkle.dao&quot;</span>/&gt;<br>&lt;/mappers&gt;<br></code></pre></td></tr></table></figure><h1 id="第二章-方法"><a href="#第二章-方法" class="headerlink" title="第二章 方法"></a>第二章 方法</h1><h2 id="一、传统Dao方法（概念及理解，不用）"><a href="#一、传统Dao方法（概念及理解，不用）" class="headerlink" title="一、传统Dao方法（概念及理解，不用）"></a>一、传统Dao方法（概念及理解，不用）</h2><p>1.创建Maven模板的Module</p><p>2.修改pom.xml文件中的配置，加入依赖库</p><p>3.创建表中每一行数据对应的对象类（domain）</p><p>4.创建Dao</p><p>​    Dao接口：写方法（对应mapper文件中的sql执行语句）</p><p>​    mapper文件：指定好namespace、id（和Dao接口中方法名称对应），写sql语言</p><p>5.主配置文件——java同级目录下创建根资源文件夹，并在此文件夹中创建主配置文件</p><p>6.写utils工具包——得到SqlSessionFactory和SqlSession对象</p><p>7.实现Dao接口——通过utils工具包得到SqlSession对象，并执行sql语句，进行增删改查</p><h2 id="二、动态代理"><a href="#二、动态代理" class="headerlink" title="二、动态代理"></a>二、动态代理</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyBatisUtils</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">SqlSessionFactory</span> <span class="hljs-variable">factory</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>    <span class="hljs-comment">//得到唯一的SqlSessionFactory对象</span><br>    <span class="hljs-keyword">static</span> &#123;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">config</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;Mybatis.xml&quot;</span>;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-type">InputStream</span> <span class="hljs-variable">in</span> <span class="hljs-operator">=</span> Resources.getResourceAsStream(config);<br>            factory = <span class="hljs-keyword">new</span> <span class="hljs-title class_">SqlSessionFactoryBuilder</span>().build(in);<br>        &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 在此基础上创建SqlSession</span><br><span class="hljs-comment">     * 静态方法，直接类名.方法名，</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> SqlSession</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> SqlSession <span class="hljs-title function_">getSqlSession</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-comment">//5.获取SqlSession对象，从SqlSessionFactory中获取</span><br>        <span class="hljs-type">SqlSession</span> <span class="hljs-variable">sqlSession</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>        <span class="hljs-keyword">if</span>(factory != <span class="hljs-literal">null</span>)&#123;<br>            sqlSession = factory.openSession();<br>        &#125;<br>        <span class="hljs-keyword">return</span> sqlSession;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="1-sqlSession-getMapper-接口-class-，调用接口方法，不需要实现接口"><a href="#1-sqlSession-getMapper-接口-class-，调用接口方法，不需要实现接口" class="headerlink" title="1.sqlSession.getMapper(接口.class)，调用接口方法，不需要实现接口"></a>1.sqlSession.getMapper(接口.class)，调用接口方法，不需要实现接口</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//得到了SqlSession对象</span><br><span class="hljs-type">SqlSession</span> <span class="hljs-variable">sqlSession</span> <span class="hljs-operator">=</span> MyBatisUtils.getsqlsession();<br><span class="hljs-type">StudentDao</span> <span class="hljs-variable">mapper</span> <span class="hljs-operator">=</span> sqlSession.getMapper(StudentDao.class);<br>mapper.XXX(方法名)<br></code></pre></td></tr></table></figure><h3 id="2-传参"><a href="#2-传参" class="headerlink" title="2.传参"></a>2.传参</h3><h4 id="1-mapper中获取简单类型的一个参数的值：-任意字符"><a href="#1-mapper中获取简单类型的一个参数的值：-任意字符" class="headerlink" title="(1) mapper中获取简单类型的一个参数的值：#{任意字符}"></a>(1) mapper中获取简单类型的一个参数的值：#{任意字符}</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//接口</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">StudentDao</span> &#123;<br>    <span class="hljs-keyword">public</span> Student <span class="hljs-title function_">selectOneStudent</span><span class="hljs-params">(Integer id)</span>;<br>&#125;<br><span class="hljs-comment">//mapper文件，这里where id=#&#123;任意字符&#125;</span><br>&lt;select id=<span class="hljs-string">&quot;selectOneStudent&quot;</span> resultType=<span class="hljs-string">&quot;twinkle.domain.Student&quot;</span>&gt;<br>    select id,name,email,age from student where id=#&#123;studentID&#125;<br>&lt;/select&gt;<br></code></pre></td></tr></table></figure><h4 id="2-多个参数，使用Param传参：-Param-“字符和mapper文件中的对应”"><a href="#2-多个参数，使用Param传参：-Param-“字符和mapper文件中的对应”" class="headerlink" title="(2)多个参数，使用Param传参： @Param(“字符和mapper文件中的对应”)"></a>(2)多个参数，使用Param传参： @Param(“字符和mapper文件中的对应”)</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//接口</span><br><span class="hljs-keyword">public</span> List&lt;Student&gt; <span class="hljs-title function_">selectStudentByMulti</span><span class="hljs-params">(<span class="hljs-meta">@Param(&quot;id&quot;)</span> Integer id, </span><br><span class="hljs-params">                                          <span class="hljs-meta">@Param(&quot;name&quot;)</span> String name)</span>;<br><span class="hljs-comment">//mapper文件</span><br>&lt;select id=<span class="hljs-string">&quot;selectStudentByMulti&quot;</span> resultType=<span class="hljs-string">&quot;twinkle.domain.Student&quot;</span>&gt;<br>    select * from student where id=#&#123;id&#125; or name=#&#123;name&#125;<br>&lt;/select&gt;<br><br><span class="hljs-comment">//main()</span><br>    List&lt;Student&gt; selectstulist = mapper.selectStudentByMulti(<span class="hljs-number">1002</span>,<span class="hljs-string">&quot;Jack&quot;</span>);<br></code></pre></td></tr></table></figure><h4 id="3-多个参数，使用对象传参，这个对象可以是自定义的"><a href="#3-多个参数，使用对象传参，这个对象可以是自定义的" class="headerlink" title="(3)多个参数，使用对象传参，这个对象可以是自定义的"></a>(3)多个参数，使用对象传参，这个对象可以是自定义的</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//接口</span><br><span class="hljs-keyword">public</span> List&lt;Student&gt; <span class="hljs-title function_">selectStudentByObj</span><span class="hljs-params">(Student student)</span>;<br><br><span class="hljs-comment">//mapper文件，其中where id=#&#123;id&#125;中占位符里的id必须和对象的属性名称保持一致</span><br>&lt;select id=<span class="hljs-string">&quot;selectStudentByObj&quot;</span> resultType=<span class="hljs-string">&quot;twinkle.domain.Student&quot;</span>&gt;<br>    select * from student where id=#&#123;id&#125; or age=#&#123;age&#125;<br>&lt;/select&gt;<br>    <br><span class="hljs-comment">//main()</span><br>List&lt;Student&gt; selectstulist = mapper.selectStudentByObj(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Student</span>(<span class="hljs-number">1002</span>,<span class="hljs-number">30</span>));<br></code></pre></td></tr></table></figure><h2 id="三、-或者"><a href="#三、-或者" class="headerlink" title="三、$  或者#"></a>三、$  或者#</h2><p>#：使用？在sql语句中进行$\textcolor{Red}{占位，} $使用PerparedStatement执行sql，效率高；避免sql注入，更安全</p><p>$：在sql语句中进行字符串拼接，使用Statement对象执行sql效率低。test程序可以通过拼接字符串多加其他的sql语句，有sql注入的风险</p><h2 id="四、MyBatis输出结果"><a href="#四、MyBatis输出结果" class="headerlink" title="四、MyBatis输出结果"></a>四、MyBatis输出结果</h2><h3 id="1-ResultType结果类型"><a href="#1-ResultType结果类型" class="headerlink" title="1.ResultType结果类型"></a>1.ResultType结果类型</h3><h4 id="1-全限定名称（包名-类名）or别名"><a href="#1-全限定名称（包名-类名）or别名" class="headerlink" title="(1)全限定名称（包名+类名）or别名"></a>(1)全限定名称（包名+类名）or别名</h4><p>可以返回一个简单类型(int等)，或对象</p><p>其中别名有：</p><img src="/2022/02/09/MyBatis/image-20210803153140277.png" alt="image-20210803153140277 " style="zoom:67%;"><img src="/2022/02/09/MyBatis/image-20210803153150511.png" alt=" " style="zoom:67%;"><h5 id="自定义别名："><a href="#自定义别名：" class="headerlink" title="自定义别名："></a>自定义别名：</h5><p>a.新的Aliase</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">&lt;typeAliases&gt;<br>    &lt;typeAlias type=<span class="hljs-string">&quot;twinkle.domain.Student&quot;</span> alias=<span class="hljs-string">&quot;student&quot;</span>&gt;&lt;/typeAlias&gt;<br>&lt;/typeAliases&gt;<br></code></pre></td></tr></table></figure><p>b.用类名作Aliase，domain包里的类都有别名</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">&lt;typeAliases&gt;<br>    &lt;<span class="hljs-keyword">package</span> name=<span class="hljs-string">&quot;twinkle.domain&quot;</span>/&gt;<br>&lt;/typeAliases&gt;<br></code></pre></td></tr></table></figure><h4 id="2-返回值为Map"><a href="#2-返回值为Map" class="headerlink" title="(2)返回值为Map"></a>(2)返回值为Map</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//接口</span><br><span class="hljs-comment">//可以返回为一个map的List</span><br><span class="hljs-keyword">public</span> List&lt;Map&lt;Object,Object&gt;&gt; <span class="hljs-title function_">selectStudentMap</span><span class="hljs-params">(<span class="hljs-meta">@Param(&quot;id&quot;)</span> Integer id)</span>;<br><span class="hljs-comment">//mapper</span><br>&lt;select id=<span class="hljs-string">&quot;selectStudentMap&quot;</span> resultType=<span class="hljs-string">&quot;map&quot;</span>&gt;<br>    select * from student where id&gt;#&#123;id&#125;<br>&lt;/select&gt;<br><span class="hljs-comment">//main</span><br>List&lt;Map&lt;Object,Object&gt;&gt; map = mapper.selectStudentMap(<span class="hljs-number">1001</span>);<br>System.out.println(<span class="hljs-string">&quot;map&quot;</span> + map);<br></code></pre></td></tr></table></figure><h3 id="2-ResultMap（结果映射，即可以自定义表中列值和对象属性的对应关系）"><a href="#2-ResultMap（结果映射，即可以自定义表中列值和对象属性的对应关系）" class="headerlink" title="2.ResultMap（结果映射，即可以自定义表中列值和对象属性的对应关系）"></a>2.ResultMap（结果映射，即可以自定义表中列值和对象属性的对应关系）</h3><p>如果Student类重写了包含所有列名的有参构造方法，那么就可以查出来完整的信息！！！</p><p>（实际项目开发的时候可以试一下，重写全部参数的构造方法，看能否解决名称不对应的问题，如果不行，则用ResultMap）</p><p>(1)接口写方法名</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> List&lt;Student&gt; <span class="hljs-title function_">selectResultMap</span><span class="hljs-params">(<span class="hljs-meta">@Param(&quot;id&quot;)</span> Integer id)</span>;<br></code></pre></td></tr></table></figure><p>(2)mapper文件中定义ResultMap</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java">&lt;!--    定义ResultMap--&gt;<br>&lt;resultMap id=<span class="hljs-string">&quot;StudentMap&quot;</span> type=<span class="hljs-string">&quot;twinkle.domain.Student&quot;</span>&gt;<br>    &lt;!--主键列用id--&gt;<br>    &lt;id column=<span class="hljs-string">&quot;id&quot;</span> property=<span class="hljs-string">&quot;age&quot;</span>/&gt;<br>    &lt;!--非主键列用result--&gt;<br>    &lt;result column=<span class="hljs-string">&quot;name&quot;</span> property=<span class="hljs-string">&quot;name&quot;</span>/&gt;<br>    &lt;result column=<span class="hljs-string">&quot;email&quot;</span> property=<span class="hljs-string">&quot;email&quot;</span>/&gt;<br>    &lt;result column=<span class="hljs-string">&quot;age&quot;</span> property=<span class="hljs-string">&quot;id&quot;</span>/&gt;<br>&lt;/resultMap&gt;<br></code></pre></td></tr></table></figure><p>(3)mapper文件中写select字段</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">&lt;select id=<span class="hljs-string">&quot;selectResultMap&quot;</span> resultMap=<span class="hljs-string">&quot;StudentMap&quot;</span>&gt;<br>select * from student where id=#&#123;id&#125;<br>&lt;/select&gt;<br></code></pre></td></tr></table></figure><p>3.实体类属性名和表中列名不同处理方法</p><p>(1)使用resuleMap</p><p>(2)使用列别名和resultType</p><p>select id as xxx, name as xxx from student</p><h1 id="第三章-动态sql"><a href="#第三章-动态sql" class="headerlink" title="第三章 动态sql"></a>第三章 动态sql</h1><p>1.if</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java">&lt;select id=<span class="hljs-string">&quot;selectStudentIf&quot;</span> resultType=<span class="hljs-string">&quot;twinkle.domain.Student&quot;</span>&gt;<br>    select id,name,email,age from student<br>    where <span class="hljs-number">1</span>=<span class="hljs-number">1</span><br>    &lt;<span class="hljs-keyword">if</span> test=<span class="hljs-string">&quot;name != null and name !=&#x27;&#x27; &quot;</span>&gt;<br>        <span class="hljs-type">and</span> <span class="hljs-variable">name</span> <span class="hljs-operator">=</span> #&#123;name&#125;<br>    &lt;/<span class="hljs-keyword">if</span>&gt;<br>    &lt;<span class="hljs-keyword">if</span> test=<span class="hljs-string">&quot;age &gt; 0&quot;</span>&gt;<br>        and age &gt; #&#123;age&#125;<br>    &lt;/<span class="hljs-keyword">if</span>&gt;<br>&lt;/select&gt;<br></code></pre></td></tr></table></figure><p>2.where + if</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java">&lt;select id=<span class="hljs-string">&quot;selectStudentIf&quot;</span> resultType=<span class="hljs-string">&quot;twinkle.domain.Student&quot;</span>&gt;<br>    select * from student<br>    &lt;where&gt;<br>        &lt;<span class="hljs-keyword">if</span> test=<span class="hljs-string">&quot;name != null and name != &#x27;&#x27;&quot;</span>&gt;<br>            name = #&#123;name&#125;<br>        &lt;/<span class="hljs-keyword">if</span>&gt;<br>        &lt;<span class="hljs-keyword">if</span> test=<span class="hljs-string">&quot;age &gt; 0&quot;</span>&gt;<br>            age &gt; #&#123;age&#125;<br>        &lt;/<span class="hljs-keyword">if</span>&gt;<br>    &lt;/where&gt;<br>&lt;/select&gt;<br></code></pre></td></tr></table></figure><p>3.foreach</p><p>最终输出为select * from student where id in (?,?,?)，其中</p><p>collection：</p><p>item:循环的对象，主代码中需要传入的，可以是简单类型，也可以是对象，如果需要使用对象的属性值，</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java">&lt;select id=<span class="hljs-string">&quot;selectStudentForeachP&quot;</span> resultType=<span class="hljs-string">&quot;twinkle.domain.Student&quot;</span>&gt;<br>    select * from student where id in<br>    &lt;foreach collection=<span class="hljs-string">&quot;list&quot;</span> item=<span class="hljs-string">&quot;mystu&quot;</span> open=<span class="hljs-string">&quot;(&quot;</span> close=<span class="hljs-string">&quot;)&quot;</span> separator=<span class="hljs-string">&quot;,&quot;</span>&gt;<br>        #&#123;mystu.id&#125;<br>    &lt;/foreach&gt;<br>&lt;/select&gt;<br></code></pre></td></tr></table></figure><p>open：开始符号</p><p>close：结束符号</p><p>separator：分隔符</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java">select * from student where id in<br>&lt;foreach collection=<span class="hljs-string">&quot;list&quot;</span> item=<span class="hljs-string">&quot;myid&quot;</span> open=<span class="hljs-string">&quot;(&quot;</span> close=<span class="hljs-string">&quot;)&quot;</span> separator=<span class="hljs-string">&quot;,&quot;</span>&gt;<br>    #&#123;myid&#125;<br>&lt;/foreach&gt;<br><span class="hljs-comment">//main</span><br>List&lt;Integer&gt; list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>list.add(<span class="hljs-number">1001</span>);<br>list.add(<span class="hljs-number">1002</span>);<br>list.add(<span class="hljs-number">1003</span>);<br>List&lt;Student&gt; studentList = mapper.selectStudentForeach(list);<br></code></pre></td></tr></table></figure><p>4.sql代码片段</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java">&lt;sql id=<span class="hljs-string">&quot;studentsql&quot;</span>&gt;<br>    select * from student<br>&lt;/sql&gt;<br><br>&lt;select id=<span class="hljs-string">&quot;selectStudentIf&quot;</span> resultType=<span class="hljs-string">&quot;twinkle.domain.Student&quot;</span>&gt;<br>&lt;include refid=<span class="hljs-string">&quot;studentsql&quot;</span>/&gt;<br>&lt;/select&gt;<br></code></pre></td></tr></table></figure><h1 id="第四章-补充知识"><a href="#第四章-补充知识" class="headerlink" title="第四章  补充知识"></a>第四章  补充知识</h1><h2 id="1-数据库连接封装"><a href="#1-数据库连接封装" class="headerlink" title="1.数据库连接封装"></a>1.数据库连接封装</h2><p>resource目录下新增.properties文件，在文件中写数据库的连接信息</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-attr">jdbc.driver</span> = com.mysql.jdbc.Driver<br><span class="hljs-attr">jdbc.url</span> = jdbc:mysql://localhost:<span class="hljs-number">1234</span>/mybatis<br><span class="hljs-attr">jdbc.username</span> = root<br><span class="hljs-attr">jdbc.password</span> = <span class="hljs-number">333</span><br></code></pre></td></tr></table></figure><p>主配置文件中写.properties文件的位置</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">&lt;properties resource=<span class="hljs-string">&quot;jdbc.properties&quot;</span>/&gt;<br></code></pre></td></tr></table></figure><p>environment中的value值为${key}</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">&lt;property name=<span class="hljs-string">&quot;driver&quot;</span> value=<span class="hljs-string">&quot;$&#123;jdbc.driver&#125;&quot;</span>/&gt;<br></code></pre></td></tr></table></figure><h2 id="2-多个mapper文件"><a href="#2-多个mapper文件" class="headerlink" title="2.多个mapper文件"></a>2.多个mapper文件</h2><p>(1)主配置文件中<mappers>中依次添加<mapper></mapper></mappers></p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs routeros">&lt;mapper <span class="hljs-attribute">resource</span>=<span class="hljs-string">&quot;twinkle/dao/StudentDao.xml&quot;</span>/&gt;<br></code></pre></td></tr></table></figure><p>(2)主配置文件中<mappers>中添加<package></package></mappers></p><p>有如下要求：</p><p>i. mapper文件名需要和接口名称一样，区分大小写</p><p>ii. mapper文件和接口需要在同一目录下</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs routeros">&lt;package <span class="hljs-attribute">name</span>=<span class="hljs-string">&quot;twinkle.dao&quot;</span>/&gt;<br></code></pre></td></tr></table></figure><h2 id="3-PageHelper"><a href="#3-PageHelper" class="headerlink" title="3.PageHelper"></a>3.PageHelper</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java">&lt;!--pom文件，加载资源--&gt;<br>&lt;dependency&gt;<br>  &lt;groupId&gt;com.github.pagehelper&lt;/groupId&gt;<br>  &lt;artifactId&gt;pagehelper&lt;/artifactId&gt;<br>  &lt;version&gt;<span class="hljs-number">5.1</span><span class="hljs-number">.10</span>&lt;/version&gt;<br>&lt;/dependency&gt;<br></code></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--主配置文件，配置插件--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">plugins</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">plugin</span> <span class="hljs-attr">interceptor</span>=<span class="hljs-string">&quot;com.github.pagehelper.PageInterceptor&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">plugins</span>&gt;</span><br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">PageHelper.startPage(pageNum,pageSize);<span class="hljs-comment">//得到第几页的几个数据</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>MySQL初级笔记</title>
    <link href="/2022/02/09/MySQL/"/>
    <url>/2022/02/09/MySQL/</url>
    
    <content type="html"><![CDATA[<h1 id="一、一些杂七杂八"><a href="#一、一些杂七杂八" class="headerlink" title="一、一些杂七杂八"></a>一、一些杂七杂八</h1><h2 id="1-端口"><a href="#1-端口" class="headerlink" title="1.端口"></a>1.端口</h2><p>文件下载（FTP）：21</p><p>MySQL:3306(默认)</p><p>本机MySLQ port: 1234</p><p>Oracle:1521</p><h2 id="2-卸载"><a href="#2-卸载" class="headerlink" title="2.卸载"></a>2.卸载</h2><p>(1)直接在安装包里删掉软件和服务</p><p>(2)C:\Program Files\MySQL  此安装目录要手动删干净</p><p>​    C:\ProgramData\MySQL  这个手动删干净</p><h2 id="3-命令"><a href="#3-命令" class="headerlink" title="3.命令"></a>3.命令</h2><p>(1) 如果sql数据量太大，使用source命令初始化sql脚本</p><p>(2) mysql -u****-p****</p><p>(3) show databases;（查看有哪些数据库）</p><p>(4) create database aaa(数据库的名字);</p><p>(5) use aaa;(使用具体的数据库)</p><p>(6) show tables;(查看该数据库下的表)</p><p>(7)desc 表名;（查看表的结构）</p><p>(8)导入表（库）：</p><p>​    create database 表&#x2F;库名;</p><p>​    use 表&#x2F;库名;</p><p>​    source 表&#x2F;库名.sql;</p><p>(9)drop table if exists 表名;</p><p>(10)drop table 表名;    (这个更通用一些)</p><p>注意：</p><p>1.sql语句中，字符串用&#x3D;&#x3D;单引号&#x3D;&#x3D;（在Oracle和其他数据库中也是这样用的）</p><p>2.&#x3D;&#x3D;增删改查 CRUD&#x3D;&#x3D; (Create增加 Retrieve检索 Update Delete)</p><h2 id="4-关系型数据库和非关系型数据库"><a href="#4-关系型数据库和非关系型数据库" class="headerlink" title="4.关系型数据库和非关系型数据库"></a>4.关系型数据库和非关系型数据库</h2><h3 id="（1）关系型数据库"><a href="#（1）关系型数据库" class="headerlink" title="（1）关系型数据库"></a>（1）关系型数据库</h3><p>MySQL是关系型数据库，采用了关系模型来组织数据的数据库。</p><p>关系模型指的是&#x3D;&#x3D;二维表格&#x3D;&#x3D;，一个关系型数据库就是由二维表格及其之间的联系所组成的一个数据组织。</p><p>数据库事务具有&#x3D;&#x3D;ACID特性&#x3D;&#x3D;，Atomic原子性、Consistency一致性、Isolation隔离性、Durability持久性</p><p>优点：容易理解、使用方便、易于维护（丰富的完整性大大降低了数据冗余和数据不一致的概率）</p><p>瓶颈：</p><p>​        高并发读写需求；网站用户并发性非常高，往往每秒上万次读写请求，对于传统关系型数据库来说，磁盘IO是一个很大的问题</p><p>​        海量数据的高效率读写；在一张包含海量数据的表中查询，效率非常低</p><p>​        高扩展性和可用性；数据库升级和扩展往往需要停机维护和数据迁移。</p><h3 id="（2）非关系型数据库"><a href="#（2）非关系型数据库" class="headerlink" title="（2）非关系型数据库"></a>（2）非关系型数据库</h3><p>数据结构化存储方法的集合</p><ul><li>面向&#x3D;&#x3D;高性能并发读写&#x3D;&#x3D;的key-value数据库：</li></ul><p>key-value数据库的主要特点即使具有极高的并发读写性能，&#x3D;&#x3D;Redis,Tokyo Cabinet,Flare&#x3D;&#x3D;就是这类的代表</p><ul><li>面向&#x3D;&#x3D;海量数据访问&#x3D;&#x3D;的面向文档数据库：</li></ul><p>这类数据库的特点是，可以在海量的数据中快速的查询数据，典型代表为&#x3D;&#x3D;MongoDB&#x3D;&#x3D;以及&#x3D;&#x3D;CouchDB&#x3D;&#x3D;</p><ul><li>面向&#x3D;&#x3D;可扩展性&#x3D;&#x3D;的分布式数据库：</li></ul><p>这类数据库想解决的问题就是传统数据库存在可扩展性上的缺陷，这类数据库可以适应数据量的增加以及数据结构的变化</p><h1 id="二、MySQL"><a href="#二、MySQL" class="headerlink" title="二、MySQL"></a>二、MySQL</h1><ol><li><p>DB : DataBase （数据库，是一个文件）</p></li><li><p>DBMS: DataBase Management System（数据库管理系统，例如 MySQL  Oracle  DB2   Sybase  SqlServer…）</p></li><li><p>SQL:结构化查询语言，标准的SQL适合于所有的数据库产品</p><p>总结：DBMS使用SQL管理DB</p></li></ol><p>1.SQL语句的分类：</p><p>DQL（Data Query Language数据查询语言）：查询语句，凡是$\textcolor{red}{select}$（查找）语句都是DQL</p><p>DML（Data Manipulation Language数据操作语言）：$\textcolor{red}{insert}$（插入） $\textcolor{red}{delete}$（删除）$\textcolor{red}{update}$（修改），对<strong>表中的数据</strong>进行增删改</p><p>DDL（Data Definition Language数据定义语言）：create（创建）  drop（丢弃）  alter（修改），对<strong>表结构</strong>的增删改</p><p>TCL（Transaction Control Language事务控制语言）： commit（提交事务）  rollback（回滚事务）</p><p>DCL（Data Control Language数据控制语言）：grant（授权）  revoke（撤销权限）等</p><p>mysql&gt; source ***.sql            批量地执行sql语句（特别是sql语句很多的情况下）</p><h1 id="三、必须掌握语句"><a href="#三、必须掌握语句" class="headerlink" title="三、必须掌握语句"></a>三、必须掌握语句</h1><h2 id="1-查询"><a href="#1-查询" class="headerlink" title="1.查询"></a>1.查询</h2><h3 id="1）简单查询"><a href="#1）简单查询" class="headerlink" title="1）简单查询"></a>1）简单查询</h3><figure class="highlight sql"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> empno, ename <span class="hljs-keyword">as</span> <span class="hljs-string">&#x27;重命名&#x27;</span> <span class="hljs-keyword">from</span> emp(表名);<br><br><span class="hljs-operator">/</span><span class="hljs-operator">/</span>直接使用空格代替<span class="hljs-keyword">as</span><br><span class="hljs-keyword">select</span> sal <span class="hljs-operator">*</span> <span class="hljs-number">12</span> <span class="hljs-string">&#x27;年薪&#x27;</span> <span class="hljs-keyword">from</span> emp;<br></code></pre></td></tr></table></figure><h3 id="2）条件查询"><a href="#2）条件查询" class="headerlink" title="2）条件查询"></a>2）条件查询</h3><p>select</p><p>​        字段,字段…</p><p>from </p><p>​        表名</p><p>where</p><p>​        条件；</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> sal <span class="hljs-operator">*</span> <span class="hljs-number">12</span> yealsal <span class="hljs-keyword">from</span> emp <span class="hljs-keyword">where</span> sal<span class="hljs-operator">=</span><span class="hljs-number">800</span><br></code></pre></td></tr></table></figure><p>&#x3D;&#x3D;执行顺序： from、where、select&#x3D;&#x3D;</p><table><thead><tr><th>运算符</th><th>说明</th></tr></thead><tbody><tr><td>&#x3D;</td><td>等于</td></tr><tr><td>&lt;&gt;或!&#x3D;</td><td>不等于</td></tr><tr><td>&lt;</td><td>小于</td></tr><tr><td>&lt;&#x3D;</td><td>小于等于</td></tr><tr><td>&gt;</td><td>大于</td></tr><tr><td>&gt;&#x3D;</td><td>大于等于</td></tr><tr><td>between … and ….</td><td>两个值之间,<strong>等同于 &gt;&#x3D; and &lt;&#x3D;</strong>  (使用的时候，必须左小右大)</td></tr><tr><td>&#x3D;&#x3D;is null&#x3D;&#x3D;</td><td>为null（is not null 不为空）</td></tr><tr><td><strong>and</strong></td><td>并且</td></tr><tr><td><strong>or</strong></td><td>或者</td></tr><tr><td>in</td><td>包含，相当于多个or（not in不在这个范围中）,in后面的不是区间，而是具体的值</td></tr><tr><td>not</td><td>not可以取非，主要用在is 或in中</td></tr><tr><td>like</td><td>like称为模糊查询，支持%或下划线匹配  %匹配任意个字符  下划线，一个下划线只匹配一个字符</td></tr></tbody></table><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> ename, job <span class="hljs-keyword">from</span> emp <span class="hljs-keyword">where</span> job <span class="hljs-keyword">in</span>(<span class="hljs-string">&#x27;salesman&#x27;</span>, <span class="hljs-string">&#x27;manager&#x27;</span>);<br><span class="hljs-operator">/</span><span class="hljs-operator">/</span>找出工资等于<span class="hljs-number">1000</span>和等于<span class="hljs-number">5000</span>的<br><span class="hljs-keyword">select</span> ename, job <span class="hljs-keyword">from</span> emp <span class="hljs-keyword">where</span> sal <span class="hljs-keyword">in</span>(<span class="hljs-number">1000</span>, <span class="hljs-number">2000</span>);<br></code></pre></td></tr></table></figure><h3 id="3）模糊查询"><a href="#3）模糊查询" class="headerlink" title="3）模糊查询"></a>3）模糊查询</h3><figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs axapta"><span class="hljs-comment">//找出名字里有O的</span><br><span class="hljs-keyword">select</span> ename <span class="hljs-keyword">from</span> emp <span class="hljs-keyword">where</span> ename <span class="hljs-keyword">like</span> <span class="hljs-string">&#x27;%o%&#x27;</span>;<br><span class="hljs-comment">//找出名字的第二个字母是A的</span><br><span class="hljs-keyword">select</span> ename <span class="hljs-keyword">from</span> emp <span class="hljs-keyword">where</span> ename <span class="hljs-keyword">like</span> <span class="hljs-string">&#x27;_a%&#x27;</span>;<br><span class="hljs-comment">//找出名字中有_的，需要转义字符</span><br><span class="hljs-keyword">select</span> ename <span class="hljs-keyword">from</span> emp <span class="hljs-keyword">where</span> ename <span class="hljs-keyword">like</span> <span class="hljs-string">&#x27;%/_%&#x27;</span><br></code></pre></td></tr></table></figure><h2 id="2-排序"><a href="#2-排序" class="headerlink" title="2.排序"></a>2.排序</h2><p>select </p><p>​    字段</p><p>from </p><p>​    字段 </p><p>order by </p><p>​    字段; （默认采用升序asc）</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-operator">/</span><span class="hljs-operator">/</span>按照工资降序排<br><span class="hljs-keyword">select</span> ename <span class="hljs-keyword">from</span> emp <span class="hljs-keyword">order</span> <span class="hljs-keyword">by</span> sal <span class="hljs-keyword">desc</span>;<span class="hljs-operator">/</span><span class="hljs-operator">/</span>降序descend，升序是<span class="hljs-keyword">asc</span>,ascend<br><span class="hljs-operator">/</span><span class="hljs-operator">/</span>按照工资降序排，当工资一样的时候，按照名字升序排<br><span class="hljs-keyword">select</span> ename <span class="hljs-keyword">from</span> emp <span class="hljs-keyword">order</span> <span class="hljs-keyword">by</span> sal <span class="hljs-keyword">desc</span>, ename <span class="hljs-keyword">asc</span>;<br><span class="hljs-operator">/</span><span class="hljs-operator">/</span><br><span class="hljs-keyword">select</span> ename , job, sal <span class="hljs-keyword">from</span> emp <span class="hljs-keyword">where</span> job<span class="hljs-operator">=</span><span class="hljs-string">&#x27;salesman&#x27;</span> <span class="hljs-keyword">order</span> <span class="hljs-keyword">by</span> sal <span class="hljs-keyword">desc</span>;<br></code></pre></td></tr></table></figure><h2 id="3-单行处理函数"><a href="#3-单行处理函数" class="headerlink" title="3.单行处理函数"></a>3.单行处理函数</h2><p>&#x3D;&#x3D;只要式子中有值为NULL，则运算后的值都是NULL&#x3D;&#x3D;</p><p>ifnull(可能为NULL的数据,被当做什么来处理)</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> ename,(sal<span class="hljs-operator">+</span>ifnull(comm,<span class="hljs-number">0</span>))<span class="hljs-operator">*</span><span class="hljs-number">12</span> <span class="hljs-keyword">as</span> yearsal <span class="hljs-keyword">from</span> emp<br></code></pre></td></tr></table></figure><h2 id="4-多行处理函数（分组函数、聚合函数）（只有5个）"><a href="#4-多行处理函数（分组函数、聚合函数）（只有5个）" class="headerlink" title="4.多行处理函数（分组函数、聚合函数）（只有5个）"></a>4.多行处理函数（分组函数、聚合函数）（只有5个）</h2><p>分组函数一般和group by联合使用，所以叫做分组函数，</p><p>分组函数在group by语句执行完后才会执行</p><p>(1)多行处理函数（输入多行、输出一行），&#x3D;&#x3D;多行处理函数自动忽略NULL&#x3D;&#x3D;（即使有NULL，但是运算后值不为NULL）</p><p>(2)&#x3D;&#x3D;分组函数不能直接使用在where子句中&#x3D;&#x3D;(这和执行顺序有关！！！)</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-operator">/</span><span class="hljs-operator">/</span>找出工资大于平均工资的员工<br><span class="hljs-keyword">select</span> ename, sal <span class="hljs-keyword">from</span> emp <span class="hljs-keyword">where</span> sal <span class="hljs-operator">&gt;</span> (<span class="hljs-keyword">select</span> <span class="hljs-built_in">avg</span>(sal) <span class="hljs-keyword">from</span> emp);<br></code></pre></td></tr></table></figure><p>sum() 求和</p><p>max() 最大数</p><p>min() 最小数</p><p>avg() 平均数</p><p>count() 求和</p><p>​    &#x3D;&#x3D;count(*)为总记录条数&#x3D;&#x3D;</p><p>​    &#x3D;&#x3D;count(字段)为不为空的字段条数&#x3D;&#x3D;</p><h2 id="5-group-by-和having"><a href="#5-group-by-和having" class="headerlink" title="5.group by 和having"></a>5.group by 和having</h2><p>group by :按照某个字段或者某些字段进行过滤</p><p>having:对分组之后的数据进行再次过滤</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-operator">/</span><span class="hljs-operator">/</span>找出每个工作岗位的最高薪资<br><span class="hljs-keyword">select</span> <span class="hljs-built_in">max</span>(sal) <span class="hljs-keyword">from</span> emp <span class="hljs-keyword">group</span> <span class="hljs-keyword">by</span> job;<br><span class="hljs-operator">/</span><span class="hljs-operator">/</span>找出某个工作岗位的最高薪资<br><span class="hljs-keyword">select</span> <span class="hljs-built_in">max</span>(sal), job <span class="hljs-keyword">from</span> emp <span class="hljs-keyword">where</span> job<span class="hljs-operator">=</span><span class="hljs-string">&#x27;clerk&#x27;</span> <span class="hljs-keyword">group</span> <span class="hljs-keyword">by</span> job;<br><span class="hljs-operator">/</span><span class="hljs-operator">/</span>找出每个部门(deptno)每个工作岗位(job)的平均薪资<br><span class="hljs-keyword">select</span> <span class="hljs-built_in">avg</span>(sal), job, deptno <span class="hljs-keyword">from</span> emp <span class="hljs-keyword">group</span> <span class="hljs-keyword">by</span> deptno, job;<br></code></pre></td></tr></table></figure><p>&#x3D;&#x3D;group by后才能执行分组函数&#x3D;&#x3D;</p><p>&#x3D;&#x3D;如果sql语句用了group by，那么select后只能跟group by的参数和分组函数&#x3D;&#x3D;（mysql里是没有意义的，oracle里是报错的）</p><p>group by 解释：<a href="https://blog.csdn.net/zj20142213/article/details/81073428">https://blog.csdn.net/zj20142213/article/details/81073428</a></p><h2 id="6-having和where"><a href="#6-having和where" class="headerlink" title="6.having和where"></a>6.having和where</h2><p>1)where和having都能使用的情况用where，否则用having</p><p>where在group by 前执行，且只能操作原始数据</p><p>having在group by 后执行，可以操作分组函数</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-operator">/</span><span class="hljs-operator">/</span>找出每个部门的最高薪资，要求显示薪资大于<span class="hljs-number">3000</span>的数据<br><span class="hljs-keyword">select</span> <span class="hljs-built_in">max</span>(sal),deptno <span class="hljs-keyword">from</span> emp <span class="hljs-keyword">where</span> sal<span class="hljs-operator">&gt;</span><span class="hljs-number">3000</span> <span class="hljs-keyword">group</span> <span class="hljs-keyword">by</span> deptno;<br><span class="hljs-operator">/</span><span class="hljs-operator">/</span>找出每个部门的平均薪资，要求显示薪资大于<span class="hljs-number">2000</span>的数据<br><span class="hljs-keyword">select</span> <span class="hljs-built_in">avg</span>(sal) average, deptno <span class="hljs-keyword">from</span> emp <span class="hljs-keyword">group</span> <span class="hljs-keyword">by</span> deptno <span class="hljs-keyword">having</span> average<span class="hljs-operator">&gt;</span><span class="hljs-number">2000</span>;<br></code></pre></td></tr></table></figure><h2 id="7-执行顺序问题"><a href="#7-执行顺序问题" class="headerlink" title="7.执行顺序问题"></a>7.执行顺序问题</h2><p>选中某张表，确定where位置，是否group by ，过滤having，选择select，最后order by显示出来</p><p>select             5</p><p>​    ..</p><p>from             1</p><p>​    ..</p><p>where            2</p><p>​    ..</p><p>group by            3（group by之后，才能使用分组函数）</p><p>​    ..</p><p>having            4</p><p>​    ..    </p><p>order by            6</p><p>​    ..</p><p>limit                7</p><p>​    ..</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-number">1.</span><span class="hljs-keyword">FROM</span> <span class="hljs-operator">&lt;</span>left_table<span class="hljs-operator">&gt;</span><br><span class="hljs-number">2.</span><span class="hljs-keyword">ON</span> <span class="hljs-operator">&lt;</span>join_condition<span class="hljs-operator">&gt;</span><br><span class="hljs-number">3.</span><span class="hljs-operator">&lt;</span>join_type<span class="hljs-operator">&gt;</span> <span class="hljs-keyword">JOIN</span> <span class="hljs-operator">&lt;</span>right_table<span class="hljs-operator">&gt;</span><br><span class="hljs-number">4.</span><span class="hljs-keyword">WHERE</span> <span class="hljs-operator">&lt;</span>where_conditon<span class="hljs-operator">&gt;</span><br><span class="hljs-number">5.</span><span class="hljs-keyword">GROUP</span> <span class="hljs-keyword">BY</span> <span class="hljs-operator">&lt;</span>group_by_list<span class="hljs-operator">&gt;</span><br><span class="hljs-number">6.</span><span class="hljs-keyword">HAVING</span><br><span class="hljs-number">7.</span><span class="hljs-keyword">SELECT</span><br><span class="hljs-number">8.</span><span class="hljs-keyword">DISTINCT</span> <span class="hljs-operator">&lt;</span>select_list<span class="hljs-operator">&gt;</span><br><span class="hljs-number">9.</span><span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> <span class="hljs-operator">&lt;</span>order_by_condition<span class="hljs-operator">&gt;</span><br><span class="hljs-number">10.</span>LIMIT <span class="hljs-operator">&lt;</span>limit_number<span class="hljs-operator">&gt;</span><br></code></pre></td></tr></table></figure><h2 id="8-去除查询记录集里的重复记录distinct"><a href="#8-去除查询记录集里的重复记录distinct" class="headerlink" title="8.去除查询记录集里的重复记录distinct"></a>8.去除查询记录集里的重复记录distinct</h2><p>只是对查询结果集去重，但是不改变表的数据</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-operator">/</span><span class="hljs-operator">/</span>统计所有的岗位<br><span class="hljs-keyword">select</span> <span class="hljs-keyword">distinct</span> job <span class="hljs-keyword">from</span> emp;<br><span class="hljs-operator">/</span><span class="hljs-operator">/</span><span class="hljs-keyword">distinct</span>需放在所有的字段前，后面的字段联合<br><span class="hljs-keyword">select</span> <span class="hljs-keyword">distinct</span> job,deptno <span class="hljs-keyword">from</span> emp;<br></code></pre></td></tr></table></figure><h2 id="9-union"><a href="#9-union" class="headerlink" title="9.union"></a>9.union</h2><p>将查询的结果集拼接起来（只能拼接列数一样的查询结果集）</p><h1 id="四、连接查询"><a href="#四、连接查询" class="headerlink" title="四、连接查询"></a>四、连接查询</h1><h2 id="1-什么是连接查询"><a href="#1-什么是连接查询" class="headerlink" title="1.什么是连接查询"></a>1.什么是连接查询</h2><p>多张表联合查询取出最终的记录</p><h2 id="2-连接查询的分类"><a href="#2-连接查询的分类" class="headerlink" title="2.连接查询的分类"></a>2.连接查询的分类</h2><p>根据表的连接方式来划分，包括：</p><p>​        内连接：</p><p>​            等值连接</p><p>​            非等值连接</p><p>​            自连接</p><p>​        外连接：</p><p>​            左外连接（左连接，LEFT JOIN）</p><p>​            右外连接（右连接，RIGHT JOIN）</p><p>&#x3D;&#x3D;内连接&#x3D;&#x3D;：假设A和B两张表进行连接，AB两张表没有主副之分，A和B的数据匹配不上就不查</p><p>&#x3D;&#x3D;外连接&#x3D;&#x3D;：假设A和B两张表进行连接，有一张表是主表，一张是副表，当副表中的数据没有和主表中的数据匹配上，副表自动模拟出NULL与之匹配</p><h2 id="3-笛卡尔乘积现象："><a href="#3-笛卡尔乘积现象：" class="headerlink" title="3.笛卡尔乘积现象："></a>3.笛卡尔乘积现象：</h2><p>如果两张表连接，没有任何条件限制，那么查询结果条数就是两张表记录条数的乘积</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> ename, dname <span class="hljs-keyword">from</span> emp, dept;<br><span class="hljs-operator">/</span><span class="hljs-operator">/</span>一共有<span class="hljs-number">56</span>条记录，每个ename都会和每个dname匹配<br></code></pre></td></tr></table></figure><img src="/2022/02/09/MySQL/image-20210923142329662.png" alt="image-20210923142329662 " style="zoom:80%;"><img src="/2022/02/09/MySQL/image-20210923142319051.png" alt="image-20210923142319051 " style="zoom:80%;"><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sql">案例：找出每一个员工的部门名称，要求显示员工名和部门名<br><span class="hljs-keyword">select</span> e.ename, d.dname <span class="hljs-keyword">from</span> emp e, dept d <span class="hljs-keyword">where</span> e.deptno <span class="hljs-operator">=</span> d.deptno;<br></code></pre></td></tr></table></figure><p>如何避免笛卡尔乘积现象？——加条件进行过滤</p><p>但是&#x3D;&#x3D;不会减少记录的匹配次数&#x3D;&#x3D;，只是显示的是有效记录</p><h2 id="4-内连接-join-on"><a href="#4-内连接-join-on" class="headerlink" title="4.内连接 join on"></a>4.内连接 join on</h2><p>假设A和B两张表进行连接，AB两张表没有主副之分，A和B的数据匹配不上就不查</p><p>… A(表) (inner) join B(表) on 连接条件 where…</p><p>其中on后面接连接条件，where后跟过滤条件</p><p>1）内连接中的等值连接和非等值连接</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> e.ename, d.dname <span class="hljs-keyword">from</span> emp e, dept d <span class="hljs-keyword">where</span> e.deptno <span class="hljs-operator">=</span> d.deptno;`<span class="hljs-operator">/</span><span class="hljs-operator">/</span>SQL92语句<br><span class="hljs-operator">/</span><span class="hljs-operator">/</span>内连接中的等值连接<br><span class="hljs-operator">/</span><span class="hljs-operator">/</span>找出员工以及所对应的部门名称<br><span class="hljs-keyword">select</span> <br>e.ename, d.dname <br><span class="hljs-keyword">from</span> <br>emp e <br>(<span class="hljs-keyword">inner</span>) <span class="hljs-keyword">join</span>  <br>dept d <br><span class="hljs-keyword">on</span> <br>e.deptno <span class="hljs-operator">=</span> d.deptno;<span class="hljs-operator">/</span><span class="hljs-operator">/</span>SQL99语句<br><br><span class="hljs-operator">/</span><span class="hljs-operator">/</span>内连接中的非等值连接<br><span class="hljs-operator">/</span><span class="hljs-operator">/</span>找出员工以及所对应的工资等级<br><span class="hljs-keyword">select</span> e.ename, s.grade <span class="hljs-keyword">from</span> emp e <span class="hljs-keyword">join</span> salgrade s <span class="hljs-keyword">on</span> e.sal <span class="hljs-keyword">between</span> s.losal <span class="hljs-keyword">and</span> s.hisal;<br></code></pre></td></tr></table></figure><p>2）内连接中的自连接</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-operator">/</span><span class="hljs-operator">/</span>找出每个员工的上级领导，要求显示员工名和对应的领导名<br><span class="hljs-operator">/</span><span class="hljs-operator">/</span>此时员工中的king没有领导，没有记录<br><span class="hljs-operator">+</span><span class="hljs-comment">-------+--------+-------+</span><br><span class="hljs-operator">|</span> empno <span class="hljs-operator">|</span> ename  <span class="hljs-operator">|</span> ename <span class="hljs-operator">|</span><br><span class="hljs-operator">+</span><span class="hljs-comment">-------+--------+-------+</span><br><span class="hljs-operator">|</span>  <span class="hljs-number">7369</span> <span class="hljs-operator">|</span> SMITH  <span class="hljs-operator">|</span> FORD  <span class="hljs-operator">|</span><br><span class="hljs-operator">|</span>  <span class="hljs-number">7499</span> <span class="hljs-operator">|</span> ALLEN  <span class="hljs-operator">|</span> BLAKE <span class="hljs-operator">|</span><br><span class="hljs-operator">|</span>  <span class="hljs-number">7521</span> <span class="hljs-operator">|</span> WARD   <span class="hljs-operator">|</span> BLAKE <span class="hljs-operator">|</span><br><span class="hljs-operator">|</span>  <span class="hljs-number">7566</span> <span class="hljs-operator">|</span> JONES  <span class="hljs-operator">|</span> KING  <span class="hljs-operator">|</span><br><span class="hljs-operator">|</span>  <span class="hljs-number">7654</span> <span class="hljs-operator">|</span> MARTIN <span class="hljs-operator">|</span> BLAKE <span class="hljs-operator">|</span><br><span class="hljs-operator">|</span>  <span class="hljs-number">7698</span> <span class="hljs-operator">|</span> BLAKE  <span class="hljs-operator">|</span> KING  <span class="hljs-operator">|</span><br><span class="hljs-operator">|</span>  <span class="hljs-number">7782</span> <span class="hljs-operator">|</span> CLARK  <span class="hljs-operator">|</span> KING  <span class="hljs-operator">|</span><br><span class="hljs-operator">|</span>  <span class="hljs-number">7788</span> <span class="hljs-operator">|</span> SCOTT  <span class="hljs-operator">|</span> JONES <span class="hljs-operator">|</span><br><span class="hljs-operator">|</span>  <span class="hljs-number">7844</span> <span class="hljs-operator">|</span> TURNER <span class="hljs-operator">|</span> BLAKE <span class="hljs-operator">|</span><br><span class="hljs-operator">|</span>  <span class="hljs-number">7876</span> <span class="hljs-operator">|</span> ADAMS  <span class="hljs-operator">|</span> SCOTT <span class="hljs-operator">|</span><br><span class="hljs-operator">|</span>  <span class="hljs-number">7900</span> <span class="hljs-operator">|</span> JAMES  <span class="hljs-operator">|</span> BLAKE <span class="hljs-operator">|</span><br><span class="hljs-operator">|</span>  <span class="hljs-number">7902</span> <span class="hljs-operator">|</span> FORD   <span class="hljs-operator">|</span> JONES <span class="hljs-operator">|</span><br><span class="hljs-operator">|</span>  <span class="hljs-number">7934</span> <span class="hljs-operator">|</span> MILLER <span class="hljs-operator">|</span> CLARK <span class="hljs-operator">|</span><br><span class="hljs-operator">+</span><span class="hljs-comment">-------+--------+-------+</span><br><span class="hljs-number">13</span> <span class="hljs-keyword">rows</span> <span class="hljs-keyword">in</span> <span class="hljs-keyword">set</span> (<span class="hljs-number">0.00</span> sec)<br><br><span class="hljs-keyword">select</span> <br>e1.empno, e1.ename, e2.ename <br><span class="hljs-keyword">from</span> <br>emp e1 <br><span class="hljs-keyword">join</span> <br>emp e2 <br><span class="hljs-keyword">on</span> <br>e1.mgr <span class="hljs-operator">=</span> e2.empno;<br></code></pre></td></tr></table></figure><h2 id="5-外连接"><a href="#5-外连接" class="headerlink" title="5.外连接"></a>5.外连接</h2><p>当副表中的数据没有和主表中的数据匹配上，副表自动模拟出NULL与之匹配</p><p>左连接就是以join左边的表为主表，右连接以join右边的表为主表</p><p>… A(表) left&#x2F;right (outer) join B(表) on 连接条件 where…</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-operator">/</span><span class="hljs-operator">/</span>找出“每个”员工的上级领导<br><span class="hljs-keyword">select</span> employee.ename , employer.ename <span class="hljs-keyword">from</span> emp employee <span class="hljs-keyword">left</span> <span class="hljs-keyword">join</span> emp employer <span class="hljs-keyword">on</span> employee.mgr<span class="hljs-operator">=</span>employer.empno;<br><span class="hljs-operator">+</span><span class="hljs-comment">--------+-------+</span><br><span class="hljs-operator">|</span> ename  <span class="hljs-operator">|</span> ename <span class="hljs-operator">|</span><br><span class="hljs-operator">+</span><span class="hljs-comment">--------+-------+</span><br><span class="hljs-operator">|</span> SMITH  <span class="hljs-operator">|</span> FORD  <span class="hljs-operator">|</span><br><span class="hljs-operator">|</span> ALLEN  <span class="hljs-operator">|</span> BLAKE <span class="hljs-operator">|</span><br><span class="hljs-operator">|</span> WARD   <span class="hljs-operator">|</span> BLAKE <span class="hljs-operator">|</span><br><span class="hljs-operator">|</span> JONES  <span class="hljs-operator">|</span> KING  <span class="hljs-operator">|</span><br><span class="hljs-operator">|</span> MARTIN <span class="hljs-operator">|</span> BLAKE <span class="hljs-operator">|</span><br><span class="hljs-operator">|</span> BLAKE  <span class="hljs-operator">|</span> KING  <span class="hljs-operator">|</span><br><span class="hljs-operator">|</span> CLARK  <span class="hljs-operator">|</span> KING  <span class="hljs-operator">|</span><br><span class="hljs-operator">|</span> SCOTT  <span class="hljs-operator">|</span> JONES <span class="hljs-operator">|</span><br><span class="hljs-operator">|</span> KING   <span class="hljs-operator">|</span> <span class="hljs-keyword">NULL</span>  <span class="hljs-operator">|</span><br><span class="hljs-operator">|</span> TURNER <span class="hljs-operator">|</span> BLAKE <span class="hljs-operator">|</span><br><span class="hljs-operator">|</span> ADAMS  <span class="hljs-operator">|</span> SCOTT <span class="hljs-operator">|</span><br><span class="hljs-operator">|</span> JAMES  <span class="hljs-operator">|</span> BLAKE <span class="hljs-operator">|</span><br><span class="hljs-operator">|</span> FORD   <span class="hljs-operator">|</span> JONES <span class="hljs-operator">|</span><br><span class="hljs-operator">|</span> MILLER <span class="hljs-operator">|</span> CLARK <span class="hljs-operator">|</span><br><span class="hljs-operator">+</span><span class="hljs-comment">--------+-------+</span><br><span class="hljs-number">14</span> <span class="hljs-keyword">rows</span> <span class="hljs-keyword">in</span> <span class="hljs-keyword">set</span> (<span class="hljs-number">0.00</span> sec)<br><span class="hljs-operator">/</span><span class="hljs-operator">/</span>找出哪个部门没有员工<br><span class="hljs-operator">/</span><span class="hljs-operator">/</span>不用连接，直接筛选出emp表中员工所在部分的记录，选出不在这个记录中的，即没有员工<br><span class="hljs-keyword">select</span> d.deptno <span class="hljs-keyword">from</span> dept d <span class="hljs-keyword">where</span> d.deptno <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> (<span class="hljs-keyword">select</span> <span class="hljs-keyword">distinct</span> deptno <span class="hljs-keyword">from</span> emp);<br><span class="hljs-operator">/</span><span class="hljs-operator">/</span>用连接，拼接两张表的重合部分，然后挑选出为空的部分<br><span class="hljs-keyword">select</span> e.<span class="hljs-operator">*</span>,d.<span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> dept d <span class="hljs-keyword">left</span> <span class="hljs-keyword">join</span> emp e <span class="hljs-keyword">on</span> d.deptno <span class="hljs-operator">=</span> e.deptno <span class="hljs-keyword">where</span> e.ename <span class="hljs-keyword">is</span> <span class="hljs-keyword">null</span>;<br></code></pre></td></tr></table></figure><h2 id="6-三张表及以上的连接查询-可以分开写表的内连接-x2F-外连接"><a href="#6-三张表及以上的连接查询-可以分开写表的内连接-x2F-外连接" class="headerlink" title="6.三张表及以上的连接查询(可以分开写表的内连接&#x2F;外连接)"></a>6.三张表及以上的连接查询(可以分开写表的内连接&#x2F;外连接)</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-operator">/</span><span class="hljs-operator">/</span>找出每一个员工的部门名称、工资等级以及上级领导的名字（主要是上级领导的名字，如果用普通连接或者内连接，不会自动补全<span class="hljs-keyword">NULL</span>，只有外连接会补全<span class="hljs-keyword">NULL</span>）<br><span class="hljs-keyword">select</span> e1.ename,d.dname, s.grade, e2.ename <span class="hljs-keyword">from</span> emp e1, emp e2, dept d, salgrade s <span class="hljs-keyword">where</span> e1.sal <span class="hljs-keyword">between</span> s.losal <span class="hljs-keyword">and</span> s.hisal <span class="hljs-keyword">and</span> d.deptno<span class="hljs-operator">=</span>e1.deptno <span class="hljs-keyword">and</span> e1.mgr<span class="hljs-operator">=</span>e2.empno;<br><span class="hljs-operator">+</span><span class="hljs-comment">--------+------------+-------+-------+</span><br><span class="hljs-operator">|</span> ename  <span class="hljs-operator">|</span> dname      <span class="hljs-operator">|</span> grade <span class="hljs-operator">|</span> ename <span class="hljs-operator">|</span><br><span class="hljs-operator">+</span><span class="hljs-comment">--------+------------+-------+-------+</span><br><span class="hljs-operator">|</span> SMITH  <span class="hljs-operator">|</span> RESEARCH   <span class="hljs-operator">|</span>     <span class="hljs-number">1</span> <span class="hljs-operator">|</span> FORD  <span class="hljs-operator">|</span><br><span class="hljs-operator">|</span> ALLEN  <span class="hljs-operator">|</span> SALES      <span class="hljs-operator">|</span>     <span class="hljs-number">3</span> <span class="hljs-operator">|</span> BLAKE <span class="hljs-operator">|</span><br><span class="hljs-operator">|</span> WARD   <span class="hljs-operator">|</span> SALES      <span class="hljs-operator">|</span>     <span class="hljs-number">2</span> <span class="hljs-operator">|</span> BLAKE <span class="hljs-operator">|</span><br><span class="hljs-operator">|</span> JONES  <span class="hljs-operator">|</span> RESEARCH   <span class="hljs-operator">|</span>     <span class="hljs-number">4</span> <span class="hljs-operator">|</span> KING  <span class="hljs-operator">|</span><br><span class="hljs-operator">|</span> MARTIN <span class="hljs-operator">|</span> SALES      <span class="hljs-operator">|</span>     <span class="hljs-number">2</span> <span class="hljs-operator">|</span> BLAKE <span class="hljs-operator">|</span><br><span class="hljs-operator">|</span> BLAKE  <span class="hljs-operator">|</span> SALES      <span class="hljs-operator">|</span>     <span class="hljs-number">4</span> <span class="hljs-operator">|</span> KING  <span class="hljs-operator">|</span><br><span class="hljs-operator">|</span> CLARK  <span class="hljs-operator">|</span> ACCOUNTING <span class="hljs-operator">|</span>     <span class="hljs-number">4</span> <span class="hljs-operator">|</span> KING  <span class="hljs-operator">|</span><br><span class="hljs-operator">|</span> SCOTT  <span class="hljs-operator">|</span> RESEARCH   <span class="hljs-operator">|</span>     <span class="hljs-number">4</span> <span class="hljs-operator">|</span> JONES <span class="hljs-operator">|</span><br><span class="hljs-operator">|</span> TURNER <span class="hljs-operator">|</span> SALES      <span class="hljs-operator">|</span>     <span class="hljs-number">3</span> <span class="hljs-operator">|</span> BLAKE <span class="hljs-operator">|</span><br><span class="hljs-operator">|</span> ADAMS  <span class="hljs-operator">|</span> RESEARCH   <span class="hljs-operator">|</span>     <span class="hljs-number">1</span> <span class="hljs-operator">|</span> SCOTT <span class="hljs-operator">|</span><br><span class="hljs-operator">|</span> JAMES  <span class="hljs-operator">|</span> SALES      <span class="hljs-operator">|</span>     <span class="hljs-number">1</span> <span class="hljs-operator">|</span> BLAKE <span class="hljs-operator">|</span><br><span class="hljs-operator">|</span> FORD   <span class="hljs-operator">|</span> RESEARCH   <span class="hljs-operator">|</span>     <span class="hljs-number">4</span> <span class="hljs-operator">|</span> JONES <span class="hljs-operator">|</span><br><span class="hljs-operator">|</span> MILLER <span class="hljs-operator">|</span> ACCOUNTING <span class="hljs-operator">|</span>     <span class="hljs-number">2</span> <span class="hljs-operator">|</span> CLARK <span class="hljs-operator">|</span><br><span class="hljs-operator">+</span><span class="hljs-comment">--------+------------+-------+-------+</span><br><span class="hljs-number">13</span> <span class="hljs-keyword">rows</span> <span class="hljs-keyword">in</span> <span class="hljs-keyword">set</span> (<span class="hljs-number">0.00</span> sec)<br>此时只有<span class="hljs-number">13</span>条数据<br><span class="hljs-keyword">select</span> <br>e.ename, employer.ename, s.grade, d.dname <br><span class="hljs-keyword">from</span> <br>emp e <br><span class="hljs-keyword">join</span> <br>emp employer <br><span class="hljs-keyword">on</span> <br>e.mgr<span class="hljs-operator">=</span>employer.empno <br><span class="hljs-keyword">join</span> <br>dept d <br><span class="hljs-keyword">on</span> <br>d.deptno<span class="hljs-operator">=</span>e.deptno <br><span class="hljs-keyword">left</span> <span class="hljs-keyword">join</span> <br>salgrade s <br><span class="hljs-keyword">on</span> <br>e.sal <br><span class="hljs-keyword">between</span> <br>s.losal <span class="hljs-keyword">and</span> s.hisal;<br><span class="hljs-operator">+</span><span class="hljs-comment">--------+-------+-------+------------+</span><br><span class="hljs-operator">|</span> ename  <span class="hljs-operator">|</span> ename <span class="hljs-operator">|</span> grade <span class="hljs-operator">|</span> dname      <span class="hljs-operator">|</span><br><span class="hljs-operator">+</span><span class="hljs-comment">--------+-------+-------+------------+</span><br><span class="hljs-operator">|</span> SMITH  <span class="hljs-operator">|</span> FORD  <span class="hljs-operator">|</span>     <span class="hljs-number">1</span> <span class="hljs-operator">|</span> RESEARCH   <span class="hljs-operator">|</span><br><span class="hljs-operator">|</span> ALLEN  <span class="hljs-operator">|</span> BLAKE <span class="hljs-operator">|</span>     <span class="hljs-number">3</span> <span class="hljs-operator">|</span> SALES      <span class="hljs-operator">|</span><br><span class="hljs-operator">|</span> WARD   <span class="hljs-operator">|</span> BLAKE <span class="hljs-operator">|</span>     <span class="hljs-number">2</span> <span class="hljs-operator">|</span> SALES      <span class="hljs-operator">|</span><br><span class="hljs-operator">|</span> JONES  <span class="hljs-operator">|</span> KING  <span class="hljs-operator">|</span>     <span class="hljs-number">4</span> <span class="hljs-operator">|</span> RESEARCH   <span class="hljs-operator">|</span><br><span class="hljs-operator">|</span> MARTIN <span class="hljs-operator">|</span> BLAKE <span class="hljs-operator">|</span>     <span class="hljs-number">2</span> <span class="hljs-operator">|</span> SALES      <span class="hljs-operator">|</span><br><span class="hljs-operator">|</span> BLAKE  <span class="hljs-operator">|</span> KING  <span class="hljs-operator">|</span>     <span class="hljs-number">4</span> <span class="hljs-operator">|</span> SALES      <span class="hljs-operator">|</span><br><span class="hljs-operator">|</span> CLARK  <span class="hljs-operator">|</span> KING  <span class="hljs-operator">|</span>     <span class="hljs-number">4</span> <span class="hljs-operator">|</span> ACCOUNTING <span class="hljs-operator">|</span><br><span class="hljs-operator">|</span> SCOTT  <span class="hljs-operator">|</span> JONES <span class="hljs-operator">|</span>     <span class="hljs-number">4</span> <span class="hljs-operator">|</span> RESEARCH   <span class="hljs-operator">|</span><br><span class="hljs-operator">|</span> KING   <span class="hljs-operator">|</span> <span class="hljs-keyword">NULL</span>  <span class="hljs-operator">|</span>     <span class="hljs-number">5</span> <span class="hljs-operator">|</span> ACCOUNTING <span class="hljs-operator">|</span><br><span class="hljs-operator">|</span> TURNER <span class="hljs-operator">|</span> BLAKE <span class="hljs-operator">|</span>     <span class="hljs-number">3</span> <span class="hljs-operator">|</span> SALES      <span class="hljs-operator">|</span><br><span class="hljs-operator">|</span> ADAMS  <span class="hljs-operator">|</span> SCOTT <span class="hljs-operator">|</span>     <span class="hljs-number">1</span> <span class="hljs-operator">|</span> RESEARCH   <span class="hljs-operator">|</span><br><span class="hljs-operator">|</span> JAMES  <span class="hljs-operator">|</span> BLAKE <span class="hljs-operator">|</span>     <span class="hljs-number">1</span> <span class="hljs-operator">|</span> SALES      <span class="hljs-operator">|</span><br><span class="hljs-operator">|</span> FORD   <span class="hljs-operator">|</span> JONES <span class="hljs-operator">|</span>     <span class="hljs-number">4</span> <span class="hljs-operator">|</span> RESEARCH   <span class="hljs-operator">|</span><br><span class="hljs-operator">|</span> MILLER <span class="hljs-operator">|</span> CLARK <span class="hljs-operator">|</span>     <span class="hljs-number">2</span> <span class="hljs-operator">|</span> ACCOUNTING <span class="hljs-operator">|</span><br><span class="hljs-operator">+</span><span class="hljs-comment">--------+-------+-------+------------+</span><br><span class="hljs-number">14</span> <span class="hljs-keyword">rows</span> <span class="hljs-keyword">in</span> <span class="hljs-keyword">set</span> (<span class="hljs-number">0.00</span> sec)<br></code></pre></td></tr></table></figure><h1 id="五、子查询"><a href="#五、子查询" class="headerlink" title="五、子查询"></a>五、子查询</h1><h2 id="1-概念"><a href="#1-概念" class="headerlink" title="1.概念"></a>1.概念</h2><p>select语句当中嵌套select语句，被嵌套的select语句就是子查询</p><p>主要出现于：</p><p>select </p><p>​    …(select).</p><p>from </p><p>​    (select)</p><p>where</p><p>​    (select)</p><h2 id="2-from里面子查询（临时表，但是可能降低效率，权衡）"><a href="#2-from里面子查询（临时表，但是可能降低效率，权衡）" class="headerlink" title="2.from里面子查询（临时表，但是可能降低效率，权衡）"></a>2.from里面子查询（临时表，但是可能降低效率，权衡）</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-operator">/</span><span class="hljs-operator">/</span>案例：找出每个部门平均薪水的薪资等级<br><span class="hljs-operator">/</span><span class="hljs-operator">/</span>先找出每个部门的平均薪水<br><span class="hljs-keyword">select</span> deptno, <span class="hljs-built_in">avg</span>(sal) avg <span class="hljs-keyword">from</span> emp <span class="hljs-keyword">group</span> <span class="hljs-keyword">by</span> deptno;<br><span class="hljs-operator">/</span><span class="hljs-operator">/</span>再找出薪资等级<br><span class="hljs-keyword">select</span> emp.ename, emp.sal, salgrade.grade <span class="hljs-keyword">from</span> emp <span class="hljs-keyword">left</span> <span class="hljs-keyword">join</span> salgrade <span class="hljs-keyword">on</span> emp.sal <span class="hljs-keyword">between</span> salgrade.losal <span class="hljs-keyword">and</span> salgrade.hisal;<br><span class="hljs-operator">/</span><span class="hljs-operator">/</span>将两个逻辑拼接在一起<br><span class="hljs-keyword">select</span> e.<span class="hljs-operator">*</span>,s.grade <span class="hljs-keyword">from</span> (<span class="hljs-keyword">select</span> deptno, <span class="hljs-built_in">avg</span>(sal) avg <span class="hljs-keyword">from</span> emp <span class="hljs-keyword">group</span> <span class="hljs-keyword">by</span> deptno) e <span class="hljs-keyword">left</span> <span class="hljs-keyword">join</span> salgrade s <span class="hljs-keyword">on</span> e.avg <span class="hljs-keyword">between</span> s.losal <span class="hljs-keyword">and</span> s.hisal;<br><span class="hljs-operator">+</span><span class="hljs-comment">--------+-------------+-------+</span><br><span class="hljs-operator">|</span> deptno <span class="hljs-operator">|</span> avg         <span class="hljs-operator">|</span> grade <span class="hljs-operator">|</span><br><span class="hljs-operator">+</span><span class="hljs-comment">--------+-------------+-------+</span><br><span class="hljs-operator">|</span>     <span class="hljs-number">10</span> <span class="hljs-operator">|</span> <span class="hljs-number">2916.666667</span> <span class="hljs-operator">|</span>     <span class="hljs-number">4</span> <span class="hljs-operator">|</span><br><span class="hljs-operator">|</span>     <span class="hljs-number">20</span> <span class="hljs-operator">|</span> <span class="hljs-number">2175.000000</span> <span class="hljs-operator">|</span>     <span class="hljs-number">4</span> <span class="hljs-operator">|</span><br><span class="hljs-operator">|</span>     <span class="hljs-number">30</span> <span class="hljs-operator">|</span> <span class="hljs-number">1566.666667</span> <span class="hljs-operator">|</span>     <span class="hljs-number">3</span> <span class="hljs-operator">|</span><br><span class="hljs-operator">+</span><span class="hljs-comment">--------+-------------+-------+</span><br><span class="hljs-number">3</span> <span class="hljs-keyword">rows</span> <span class="hljs-keyword">in</span> <span class="hljs-keyword">set</span> (<span class="hljs-number">0.00</span> sec)<br><br><span class="hljs-operator">/</span><span class="hljs-operator">/</span>案例：找出每个部门平均的薪水等级（先求薪水等级，再部门平均）<br><span class="hljs-operator">/</span><span class="hljs-operator">/</span>求出薪水等级<br><span class="hljs-keyword">select</span> emp.ename, emp.sal, salgrade.grade <span class="hljs-keyword">from</span> emp <span class="hljs-keyword">left</span> <span class="hljs-keyword">join</span> salgrade <span class="hljs-keyword">on</span> emp.sal <span class="hljs-keyword">between</span> salgrade.losal <span class="hljs-keyword">and</span> salgrade.hisal;<br><span class="hljs-operator">/</span><span class="hljs-operator">/</span>再部门平均（<span class="hljs-keyword">group</span> <span class="hljs-keyword">by</span>）效率不高！！！！！<br><span class="hljs-keyword">select</span> <span class="hljs-built_in">avg</span>(grade), deptno <span class="hljs-keyword">from</span> (<span class="hljs-keyword">select</span> emp.ename, emp.sal, salgrade.grade, emp.deptno <span class="hljs-keyword">from</span> emp <span class="hljs-keyword">left</span> <span class="hljs-keyword">join</span> salgrade <span class="hljs-keyword">on</span> emp.sal <span class="hljs-keyword">between</span> salgrade.losal <span class="hljs-keyword">and</span> salgrade.hisal) t <span class="hljs-keyword">group</span> <span class="hljs-keyword">by</span> deptno;<br><span class="hljs-operator">/</span><span class="hljs-operator">/</span>以上语句执行效率低！！！可以直接在临时表后面<span class="hljs-keyword">group</span> <span class="hljs-keyword">by</span> <br><span class="hljs-keyword">select</span> e.deptno, <span class="hljs-built_in">avg</span>(salgrade.grade) <span class="hljs-keyword">from</span> emp e <span class="hljs-keyword">join</span> salgrade <span class="hljs-keyword">on</span> e.sal <span class="hljs-keyword">between</span> salgrade.losal <span class="hljs-keyword">and</span> salgrade.hisal <span class="hljs-keyword">group</span> <span class="hljs-keyword">by</span> e.deptno;<br><span class="hljs-operator">+</span><span class="hljs-comment">--------+---------------------+</span><br><span class="hljs-operator">|</span> deptno <span class="hljs-operator">|</span> <span class="hljs-built_in">avg</span>(salgrade.grade) <span class="hljs-operator">|</span><br><span class="hljs-operator">+</span><span class="hljs-comment">--------+---------------------+</span><br><span class="hljs-operator">|</span>     <span class="hljs-number">10</span> <span class="hljs-operator">|</span>              <span class="hljs-number">3.6667</span> <span class="hljs-operator">|</span><br><span class="hljs-operator">|</span>     <span class="hljs-number">20</span> <span class="hljs-operator">|</span>              <span class="hljs-number">2.8000</span> <span class="hljs-operator">|</span><br><span class="hljs-operator">|</span>     <span class="hljs-number">30</span> <span class="hljs-operator">|</span>              <span class="hljs-number">2.5000</span> <span class="hljs-operator">|</span><br><span class="hljs-operator">+</span><span class="hljs-comment">--------+---------------------+</span><br><span class="hljs-number">3</span> <span class="hljs-keyword">rows</span> <span class="hljs-keyword">in</span> <span class="hljs-keyword">set</span> (<span class="hljs-number">0.00</span> sec)<br></code></pre></td></tr></table></figure><h2 id="3-select后面子查询（显示，语句执行过程倒数第二）"><a href="#3-select后面子查询（显示，语句执行过程倒数第二）" class="headerlink" title="3.select后面子查询（显示，语句执行过程倒数第二）"></a>3.select后面子查询（显示，语句执行过程倒数第二）</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-operator">/</span><span class="hljs-operator">/</span>找出每个员工所在的部门名称，要求显示员工名和部门名<br><span class="hljs-operator">/</span><span class="hljs-operator">/</span>不用子查询的写法<br><span class="hljs-keyword">select</span> e.ename, d.dname <span class="hljs-keyword">from</span> emp e <span class="hljs-keyword">join</span> dept d <span class="hljs-keyword">on</span> e.deptno<span class="hljs-operator">=</span>d.deptno;<br><span class="hljs-operator">/</span><span class="hljs-operator">/</span>使用子查询的写法，<br><span class="hljs-keyword">select</span> e.ename, (<span class="hljs-keyword">select</span> d.dname <span class="hljs-keyword">from</span> dept d <span class="hljs-keyword">where</span> e.deptno<span class="hljs-operator">=</span>d.deptno) dname <span class="hljs-keyword">from</span> emp e;<br></code></pre></td></tr></table></figure><h1 id="六、limit"><a href="#六、limit" class="headerlink" title="六、limit"></a>六、limit</h1><h2 id="1-limit是mysql特有的，oracle中是rownum"><a href="#1-limit是mysql特有的，oracle中是rownum" class="headerlink" title="1.limit是mysql特有的，oracle中是rownum"></a>1.limit是mysql特有的，oracle中是rownum</h2><h2 id="2-语法机制"><a href="#2-语法机制" class="headerlink" title="2.语法机制"></a>2.语法机制</h2><p>limit startIndex, length</p><p>startIndex表示起始位置，从0开始，</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-operator">/</span><span class="hljs-operator">/</span>取出工资前五名的员工<br><span class="hljs-keyword">select</span> ename,sal <span class="hljs-keyword">from</span> emp <span class="hljs-keyword">order</span> <span class="hljs-keyword">by</span> sal <span class="hljs-keyword">desc</span> limit <span class="hljs-number">0</span>,<span class="hljs-number">5</span>;<br><span class="hljs-operator">/</span><span class="hljs-operator">/</span>如果从<span class="hljs-number">0</span>开始，那么<span class="hljs-number">0</span>可以省略<br><span class="hljs-keyword">select</span> ename,sal <span class="hljs-keyword">from</span> emp <span class="hljs-keyword">order</span> <span class="hljs-keyword">by</span> sal <span class="hljs-keyword">desc</span> limit <span class="hljs-number">5</span>;<br></code></pre></td></tr></table></figure><h2 id="3-通用的标准分页sql语句"><a href="#3-通用的标准分页sql语句" class="headerlink" title="3.通用的标准分页sql语句"></a>3.通用的标准分页sql语句</h2><p>每页显示3条记录：</p><p>第1页：0,3</p><p>第2页：3,3</p><p>第3页：6,3</p><p>第4页：9,3</p><p>每页显示pageSize条记录：</p><p>第pageNo页：(pageNo-1)*pageSize, pageSize</p><h1 id="七、表"><a href="#七、表" class="headerlink" title="七、表"></a>七、表</h1><h2 id="1-建表语法格式"><a href="#1-建表语法格式" class="headerlink" title="1.建表语法格式"></a>1.建表语法格式</h2><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs lua"><span class="hljs-built_in">create</span> <span class="hljs-built_in">table</span> 表名(<br>字段名<span class="hljs-number">1</span> 数据类型,<br>字段名<span class="hljs-number">2</span> 数据类型,<br>字段名<span class="hljs-number">3</span> 数据类型,<br>...<br>);<br></code></pre></td></tr></table></figure><table><thead><tr><th>类型</th><th>描述</th></tr></thead><tbody><tr><td>Char(长度)</td><td>定长字符串，存储空间大小固定，适合作为主键或外键(String)</td></tr><tr><td>Varchar(长度)</td><td>变长字符串，存储空间等于实际数据空间 ，最大255(StringBuffer&#x2F;StringBuilder)</td></tr><tr><td>double(有效数字位数，小数位)</td><td>数值型</td></tr><tr><td>Float(有效数字位数，小数位)</td><td>数值型</td></tr><tr><td>Int( 长度)</td><td>整型</td></tr><tr><td>bigint(长度)</td><td>长整型  （java中的long）</td></tr><tr><td>Date</td><td>日期型 年月日（也是个字符串）</td></tr><tr><td>DateTime</td><td>日期型 年月日 时分秒 毫秒（也是个字符串）</td></tr><tr><td>time</td><td>日期型 时分秒</td></tr><tr><td>BLOB</td><td>Binary Large OBject（二进制大对象）  储存流媒体信息</td></tr><tr><td>CLOB</td><td>Character Large OBject（字符大对象）  储存较大文本</td></tr><tr><td>其它…………………</td><td></td></tr></tbody></table><h2 id="2-插入语句"><a href="#2-插入语句" class="headerlink" title="2.插入语句"></a>2.插入语句</h2><p>插入数据后，表格里一定&#x3D;&#x3D;多一条数据&#x3D;&#x3D;</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">insert</span> into 表名(字段名<span class="hljs-number">1</span>,字段名<span class="hljs-number">2</span>,字段名<span class="hljs-number">3</span>...) values (值<span class="hljs-number">1</span>,值<span class="hljs-number">2</span>,值<span class="hljs-number">3</span>...);<br></code></pre></td></tr></table></figure><p>注意：</p><p>1.有字段名X和值X，两个的类型和位置要对应，并且可以只插某几个字段，其他字段不插，用默认值填充</p><p>2.字段名省略的，如下，…里的内容需要和表格里字段顺序和数量匹配</p><figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs n1ql"><span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> t_student <span class="hljs-keyword">values</span>(...);<br></code></pre></td></tr></table></figure><h2 id="3-表的复制"><a href="#3-表的复制" class="headerlink" title="3.表的复制"></a>3.表的复制</h2><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">//将查询结果当做表创建出来<br><span class="hljs-keyword">create</span> <span class="hljs-keyword">table</span> 表名 <span class="hljs-keyword">as</span> <span class="hljs-keyword">select</span>语句;<br>eg. <br><span class="hljs-keyword">create</span> <span class="hljs-keyword">table</span> t_student1 <span class="hljs-keyword">as</span> <span class="hljs-keyword">select</span> * <span class="hljs-keyword">from</span> t_student;<br>//将查询结果插入到一张表当中<br><span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> t_student1 <span class="hljs-keyword">select</span> * <span class="hljs-keyword">from</span> t_student;<br></code></pre></td></tr></table></figure><h2 id="4-更新"><a href="#4-更新" class="headerlink" title="4.更新"></a>4.更新</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">update</span> 表名 <span class="hljs-keyword">set</span> 字段名<span class="hljs-operator">=</span>值<span class="hljs-number">1</span>,字段名<span class="hljs-number">2</span><span class="hljs-operator">=</span>值<span class="hljs-number">2.</span>.. <span class="hljs-keyword">where</span> 条件;<br></code></pre></td></tr></table></figure><p>注意：没有条件整张表全部更新</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs routeros">update dept1 <span class="hljs-built_in">set</span> <span class="hljs-attribute">LOC</span>=<span class="hljs-string">&#x27;SHANGHAI&#x27;</span>, <span class="hljs-attribute">DNAME</span>=<span class="hljs-string">&#x27;RENSHIB&#x27;</span> where <span class="hljs-attribute">deptno</span>=10;<br></code></pre></td></tr></table></figure><h2 id="5-删除"><a href="#5-删除" class="headerlink" title="5.删除"></a>5.删除</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">delete</span> <span class="hljs-keyword">from</span> 表名 <span class="hljs-keyword">where</span> 条件;<br>eg.<br><span class="hljs-keyword">delete</span> <span class="hljs-keyword">from</span> dept1 <span class="hljs-keyword">where</span> deptno<span class="hljs-operator">=</span><span class="hljs-number">10</span>;<br></code></pre></td></tr></table></figure><p>删除大表中的数据不能恢复</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">truncate</span> <span class="hljs-keyword">table</span> 表名;<span class="hljs-operator">/</span><span class="hljs-operator">/</span>表被截断，不可回滚，永久丢失<br></code></pre></td></tr></table></figure><h1 id="八、约束"><a href="#八、约束" class="headerlink" title="八、约束"></a>八、约束</h1><p>a)    非空约束，not null</p><p>b)    唯一约束，unique </p><p>c)    主键约束，primary key </p><p>d)    外键约束，foreign key</p><p>e)     检查约束，check(在Oracle中使用，mysql中不使用)</p><h2 id="1-非空约束-not-null"><a href="#1-非空约束-not-null" class="headerlink" title="1.非空约束 not null"></a>1.非空约束 not null</h2><p>只有列级定义方式【只能加在字段后面】</p><h2 id="2-唯一性约束unique"><a href="#2-唯一性约束unique" class="headerlink" title="2.唯一性约束unique"></a>2.唯一性约束unique</h2><p>字段具有唯一性，不能重复，但是可以为NULL（换言之，&#x3D;&#x3D;NULL！&#x3D;NULL&#x3D;&#x3D;）</p><p>有【列级约束】和【表级约束】两种级别</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-operator">/</span><span class="hljs-operator">/</span>案例，给某一个字段添加<span class="hljs-keyword">unique</span><br><span class="hljs-keyword">drop</span> <span class="hljs-keyword">table</span> t_student;<br><span class="hljs-keyword">create</span> <span class="hljs-keyword">table</span> t_student(<br>id <span class="hljs-type">int</span>,<br>    name <span class="hljs-type">varchar</span>(<span class="hljs-number">255</span>) <span class="hljs-keyword">unique</span>【列级约束】<br>);<br><span class="hljs-operator">+</span><span class="hljs-comment">------+----------+</span><br><span class="hljs-operator">|</span> id   <span class="hljs-operator">|</span> name     <span class="hljs-operator">|</span><br><span class="hljs-operator">+</span><span class="hljs-comment">------+----------+</span><br><span class="hljs-operator">|</span> <span class="hljs-number">1001</span> <span class="hljs-operator">|</span> zhangsan <span class="hljs-operator">|</span><br><span class="hljs-operator">|</span>    <span class="hljs-number">2</span> <span class="hljs-operator">|</span> <span class="hljs-keyword">NULL</span>     <span class="hljs-operator">|</span><br><span class="hljs-operator">|</span>    <span class="hljs-number">3</span> <span class="hljs-operator">|</span> <span class="hljs-keyword">NULL</span>     <span class="hljs-operator">|</span><br><span class="hljs-operator">|</span>    <span class="hljs-number">4</span> <span class="hljs-operator">|</span> <span class="hljs-keyword">NULL</span>     <span class="hljs-operator">|</span><br><span class="hljs-operator">+</span><span class="hljs-comment">------+----------+</span><br><br><span class="hljs-operator">/</span><span class="hljs-operator">/</span>案例，给某两个字段联合起来具有唯一性<br><span class="hljs-keyword">drop</span> <span class="hljs-keyword">table</span> t_student;<br><span class="hljs-keyword">create</span> <span class="hljs-keyword">table</span> t_student(<br>id <span class="hljs-type">int</span>,<br>    name <span class="hljs-type">varchar</span>(<span class="hljs-number">255</span>),<br>    <span class="hljs-keyword">unique</span>(id,name)【表级约束】<br>); <br><span class="hljs-operator">+</span><span class="hljs-comment">------+----------+</span><br><span class="hljs-operator">|</span> id   <span class="hljs-operator">|</span> name     <span class="hljs-operator">|</span><br><span class="hljs-operator">+</span><span class="hljs-comment">------+----------+</span><br><span class="hljs-operator">|</span> <span class="hljs-number">1001</span> <span class="hljs-operator">|</span> zhangsan <span class="hljs-operator">|</span><br><span class="hljs-operator">|</span> <span class="hljs-number">1002</span> <span class="hljs-operator">|</span> zhangsan <span class="hljs-operator">|</span><br><span class="hljs-operator">|</span> <span class="hljs-number">1003</span> <span class="hljs-operator">|</span> zhangsan <span class="hljs-operator">|</span><br><span class="hljs-operator">+</span><span class="hljs-comment">------+----------+</span><br></code></pre></td></tr></table></figure><h2 id="3-主键约束primary-key"><a href="#3-主键约束primary-key" class="headerlink" title="3.主键约束primary key"></a>3.主键约束primary key</h2><p>主键约束：primary key</p><p>主键字段：primary key修饰的字段名称</p><p>主键值：主键字段中的每一个值</p><p>&#x3D;&#x3D;某一行记录的唯一标识，不能为空，也不能重复&#x3D;&#x3D;，一个表只能有一个主键，最好不要和业务有关的字段挂钩，&#x3D;&#x3D;自然主键&#x3D;&#x3D;</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-operator">/</span><span class="hljs-operator">/</span>案例<br><span class="hljs-keyword">drop</span> <span class="hljs-keyword">table</span> t_student;<br><span class="hljs-keyword">create</span> <span class="hljs-keyword">table</span> t_student(<br>id <span class="hljs-type">int</span> <span class="hljs-keyword">primary</span> key,<br>    name <span class="hljs-type">varchar</span>(<span class="hljs-number">255</span>)<br>); <br></code></pre></td></tr></table></figure><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">//主键自增 auto_increment,插入的时候就不需要写主键值了<br><span class="hljs-keyword">drop</span> <span class="hljs-keyword">table</span> t_student;<br><span class="hljs-keyword">create</span> <span class="hljs-keyword">table</span> t_student(<br>id <span class="hljs-type">int</span> <span class="hljs-keyword">primary key</span> auto_increment,<br>    <span class="hljs-type">name</span> <span class="hljs-type">varchar</span>(<span class="hljs-number">255</span>)<br>); <br><br><span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> t_student(<span class="hljs-type">name</span>) <span class="hljs-keyword">values</span> (<span class="hljs-string">&#x27;zhangsan&#x27;</span>);<br><span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> t_student(<span class="hljs-type">name</span>) <span class="hljs-keyword">values</span> (<span class="hljs-string">&#x27;lisio&#x27;</span>);<br><span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> t_student(<span class="hljs-type">name</span>) <span class="hljs-keyword">values</span> (<span class="hljs-string">&#x27;wangwu&#x27;</span>);<br><br></code></pre></td></tr></table></figure><h2 id="4-外键约束-foreign-key"><a href="#4-外键约束-foreign-key" class="headerlink" title="4.外键约束 foreign key"></a>4.外键约束 foreign key</h2><p>子表中的某个字段引用了父表中的某个字段，那么子表中的字段的值一定是在父表引用字段值的范围内，否则会报错1452</p><p>外键值（外键字段中的值）可以为NULL，被引用的字段需要具有唯一性（可以不是主键）</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs sql">父表t_class，班级编号和名称<br><span class="hljs-operator">+</span><span class="hljs-comment">-----+------------+</span><br><span class="hljs-operator">|</span> cno <span class="hljs-operator">|</span> cname      <span class="hljs-operator">|</span><br><span class="hljs-operator">+</span><span class="hljs-comment">-----+------------+</span><br><span class="hljs-operator">|</span> <span class="hljs-number">101</span> <span class="hljs-operator">|</span> gaosan1ban <span class="hljs-operator">|</span><br><span class="hljs-operator">|</span> <span class="hljs-number">102</span> <span class="hljs-operator">|</span> gaosan2ban <span class="hljs-operator">|</span><br><span class="hljs-operator">+</span><span class="hljs-comment">-----+------------+</span><br>子表t_student，个人信息<br><span class="hljs-operator">+</span><span class="hljs-comment">-----+----------+---------+</span><br><span class="hljs-operator">|</span> sno <span class="hljs-operator">|</span> sname    <span class="hljs-operator">|</span> classno <span class="hljs-operator">|</span><br><span class="hljs-operator">+</span><span class="hljs-comment">-----+----------+---------+</span><br><span class="hljs-operator">|</span>   <span class="hljs-number">1</span> <span class="hljs-operator">|</span> zhangsan <span class="hljs-operator">|</span>     <span class="hljs-number">101</span> <span class="hljs-operator">|</span><br><span class="hljs-operator">|</span>   <span class="hljs-number">2</span> <span class="hljs-operator">|</span> zhangsan <span class="hljs-operator">|</span>     <span class="hljs-number">102</span> <span class="hljs-operator">|</span><br><span class="hljs-operator">|</span>   <span class="hljs-number">4</span> <span class="hljs-operator">|</span> zhangsan <span class="hljs-operator">|</span>     <span class="hljs-number">102</span> <span class="hljs-operator">|</span><br><span class="hljs-operator">+</span><span class="hljs-comment">-----+----------+---------+</span><br>其中t_student中的classno引用自t_class中的cno，那么classno不能出现<span class="hljs-number">101</span>和<span class="hljs-number">102</span>以外的值，除非t_class有其他的字段<br></code></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">foreign</span> key(classno) reference t_class(cno)<br></code></pre></td></tr></table></figure> <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-operator">/</span><span class="hljs-operator">/</span>先删子表，再删父表<br><span class="hljs-keyword">drop</span> <span class="hljs-keyword">table</span> if <span class="hljs-keyword">exists</span> t_student;<br><span class="hljs-keyword">drop</span> <span class="hljs-keyword">table</span> if <span class="hljs-keyword">exists</span> t_class;<br><span class="hljs-operator">/</span><span class="hljs-operator">/</span>先创父表，再创子表<br><span class="hljs-keyword">create</span> <span class="hljs-keyword">table</span> t_class(<br>cno <span class="hljs-type">int</span> <span class="hljs-keyword">primary</span> key,<br>cname <span class="hljs-type">varchar</span>(<span class="hljs-number">255</span>)<br>);<br><br><span class="hljs-keyword">create</span> <span class="hljs-keyword">table</span> t_student(<br>sno <span class="hljs-type">int</span> <span class="hljs-keyword">primary</span> key,<br>sname <span class="hljs-type">varchar</span>(<span class="hljs-number">255</span>),<br>classno <span class="hljs-type">int</span>,<br><span class="hljs-keyword">foreign</span> key(classno) <span class="hljs-keyword">references</span> t_class(cno)<br>);<br><span class="hljs-operator">/</span><span class="hljs-operator">/</span>先加父表，再加子表<br><span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> t_class <span class="hljs-keyword">values</span> (<span class="hljs-number">101</span>,<span class="hljs-string">&#x27;gaosan1ban&#x27;</span>);<br><span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> t_class <span class="hljs-keyword">values</span> (<span class="hljs-number">102</span>,<span class="hljs-string">&#x27;gaosan2ban&#x27;</span>);<br><span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> t_student <span class="hljs-keyword">values</span> (<span class="hljs-number">1</span>,<span class="hljs-string">&#x27;zhangsan&#x27;</span>,<span class="hljs-number">101</span>);<br><span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> t_student <span class="hljs-keyword">values</span> (<span class="hljs-number">2</span>,<span class="hljs-string">&#x27;zhangsan&#x27;</span>,<span class="hljs-number">102</span>);<br><span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> t_student <span class="hljs-keyword">values</span> (<span class="hljs-number">3</span>,<span class="hljs-string">&#x27;zhangsan&#x27;</span>,<span class="hljs-number">103</span>);<br><span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> t_student <span class="hljs-keyword">values</span> (<span class="hljs-number">4</span>,<span class="hljs-string">&#x27;zhangsan&#x27;</span>,<span class="hljs-number">102</span>);<br></code></pre></td></tr></table></figure><h1 id="九、存储引擎"><a href="#九、存储引擎" class="headerlink" title="九、存储引擎"></a>九、存储引擎</h1><h2 id="1-MyISAM"><a href="#1-MyISAM" class="headerlink" title="1.MyISAM"></a>1.MyISAM</h2><p>采用三个文件组织一张表</p><p>xxx.frm（存储格式的文件）</p><p>xxx.MYD（存储表中数据的文件）</p><p>xxx.MYI（存储表中索引的文件）</p><p>优点：可被压缩，节省储存空间，并且可以转换为只读表，提高检索效率</p><p>缺点：不支持事务</p><h2 id="2-InnoDB"><a href="#2-InnoDB" class="headerlink" title="2.InnoDB"></a>2.InnoDB</h2><p>优点：支持事务，最安全（mysql默认存储引擎）</p><p>xxx.frm（存储格式的文件）</p><p>tablespace（表空间）存储数据的地方，逻辑概念</p><p>在MySQL数据库崩溃的时候提供自动恢复机制</p><p>支持级联删除和级联更新</p><h2 id="3-MEMORY"><a href="#3-MEMORY" class="headerlink" title="3.MEMORY"></a>3.MEMORY</h2><h1 id="十、索引"><a href="#十、索引" class="headerlink" title="十、索引"></a>十、索引</h1><h2 id="1-什么时候给字段添加索引"><a href="#1-什么时候给字段添加索引" class="headerlink" title="1.什么时候给字段添加索引"></a>1.什么时候给字段添加索引</h2><p>1.数据量庞大</p><p>2.该字段有很少的DML(Data Manipulate Language)操作（因为字段进行修改操作，索引也需要维护）</p><p>3.该字段经常出现在where语句中（经常根据哪个字段进行查询）</p><p>注意：主键和具有unique约束的字段会自动添加索引</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-operator">/</span><span class="hljs-operator">/</span>添加索引对象：<br><span class="hljs-keyword">create</span> index 索引名称 <span class="hljs-keyword">on</span> 表名(字段名);<br><span class="hljs-operator">/</span><span class="hljs-operator">/</span>删除索引对象：<br><span class="hljs-keyword">drop</span> index 索引名称 <span class="hljs-keyword">on</span> 表名;<br></code></pre></td></tr></table></figure><h2 id="2-实现原理"><a href="#2-实现原理" class="headerlink" title="2.实现原理"></a>2.实现原理</h2><img src="/2022/02/09/MySQL/image-20210928182126858.png" alt="image-20210928182126858 " style="zoom:90%;"><p>通过B + Tree缩小扫描范围，底层索引进行排序、分区</p><p>索引会携带数据在表中的“物理地址”，最终通过索引检索到数据后，获取到关联的物理地址，通过物理地址定位表中的数据（不在表中进行查找，直接物理地址定位）</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> ename <span class="hljs-keyword">from</span> emp <span class="hljs-keyword">where</span> ename <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;SMITH&#x27;</span>;<br>变成<br><span class="hljs-keyword">select</span> ename <span class="hljs-keyword">from</span> emp <span class="hljs-keyword">where</span> 物理地址 <span class="hljs-operator">=</span> <span class="hljs-number">0x3</span>;<br></code></pre></td></tr></table></figure><img src="/2022/02/09/MySQL/image-20210928185900804.png" alt="image-20210928185900804 " style="zoom:90%;"><p>浅蓝色为磁盘块，当中有深蓝色的数据块和指针块</p><p>叶子节点为数据库中的数据，非叶子节点不是真实数据，只储存指引搜索方向的数据项，例如17、35不是真实存在数据表中</p><p>要查找数据项29，那么把磁盘块1加载进内存，发生一次磁盘IO，29在17和35之间，那么锁定P2指针，通过磁盘块1的P2指针的磁盘地址，把磁盘块3加载到内存，发生第二次磁盘IO，29在26和30之间，锁定磁盘3的P2指针，通过磁盘地址将磁盘块8加载进内存，发生第三次磁盘IO，用二分法查找到29，结束查询。</p><h3 id="B-树性质"><a href="#B-树性质" class="headerlink" title="B+树性质"></a>B+树性质</h3><p>1.索引字段尽量小</p><p>IO的次数取决于b+树的高度。</p><p>假设数据表的数据为N，每块磁盘数据项的数量为m，b+树的高度为h，h&#x3D;㏒(m+1)N，m&#x3D;磁盘块的大小&#x2F;数据项的大小，其中磁盘块的大小是固定的（一个数据页的大小）。那么如果数据项（索引字段）越小，则m越大，则h越小，即磁盘IO的次数越小。</p><p>2.索引最左匹配特性</p><p>当b+树的数据项是复合的数据结构，比如(name,age,sex)的时候，b+数是按照从左到右的顺序来建立搜索树的，比如当(张三,20,F)这样的数据来检索的时候，b+树会优先比较name来确定下一步的所搜方向，如果name相同再依次比较age和sex，最后得到检索的数据；但当(20,F)这样的没有name的数据来的时候，b+树就不知道下一步该查哪个节点，因为建立搜索树的时候name就是第一个比较因子，必须要先根据name来搜索才能知道下一步去哪里查询。比如当(张三,F)这样的数据来检索时，b+树可以用name来指定搜索方向，但下一个字段age的缺失，所以只能把名字等于张三的数据都找到，然后再匹配性别是F的数据了， 这个是非常重要的性质，即索引的最左匹配特性。</p><h2 id="3-索引的分类"><a href="#3-索引的分类" class="headerlink" title="3.索引的分类"></a>3.索引的分类</h2><p>单一索引：给单个字段添加索引</p><p>复合索引：给多个字段联合起来添加一个索引</p><p>主键索引：主键上会自动添加索引</p><p>唯一索引：有unique约束的字段上会自动添加索引</p><h2 id="4-索引的失效"><a href="#4-索引的失效" class="headerlink" title="4.索引的失效"></a>4.索引的失效</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> ename <span class="hljs-keyword">from</span> emp <span class="hljs-keyword">where</span> ename <span class="hljs-keyword">like</span> <span class="hljs-string">&#x27;%A%&#x27;</span>;<br></code></pre></td></tr></table></figure><h1 id="十一、视图"><a href="#十一、视图" class="headerlink" title="十一、视图"></a>十一、视图</h1><p>可以通过操作视图来操作表，操作视图和操作表的方法是一样的，update 和delete</p><p>视图可以隐藏表的实现细节</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-operator">/</span><span class="hljs-operator">/</span>创建视图<br><span class="hljs-keyword">create</span> <span class="hljs-keyword">view</span> 视图名 <span class="hljs-keyword">as</span> <span class="hljs-keyword">select</span> ...(字段) <span class="hljs-keyword">from</span> 表名;<br><span class="hljs-operator">/</span><span class="hljs-operator">/</span>删除视图<br><span class="hljs-keyword">drop</span> <span class="hljs-keyword">view</span> 视图名;<br></code></pre></td></tr></table></figure><p>十二、其他</p><h2 id="1-mysql备份"><a href="#1-mysql备份" class="headerlink" title="1.mysql备份"></a>1.mysql备份</h2><p>DBA命令（dos命令行的命令）</p><p>​    1.导出整个库</p><p>​        mysqldump 库名&gt;地址 -uroot -p333</p><p>​    2.导出指定数据库中的指定表</p><p>​        mysqldump 库名 表名&gt;地址 -uroot -p333 </p><h2 id="2-数据库设计三范式"><a href="#2-数据库设计三范式" class="headerlink" title="2.数据库设计三范式"></a>2.数据库设计三范式</h2><p>三范式的目的是让表的设计没有冗余。</p><p>第一范式：任何一张表都应该有主键，并且每一个字段原子性不可再分；</p><p>第二范式：建立在第一范式的基础上，所有非主键字段完全依赖主键，不能产生【部分依赖】（即多个主键的情况）；</p><p>​            【多对多？三张表，关系表两个外键】</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-string">学生编号(PK)</span><span class="hljs-string">教师编号(PK)</span><span class="hljs-string">学生姓名</span>  <span class="hljs-string">教师姓名</span><br><span class="hljs-number">1001         </span><span class="hljs-number">001</span>       <span class="hljs-string">张三</span><span class="hljs-string">王老师</span><br><span class="hljs-number">1002         </span><span class="hljs-number">002</span>       <span class="hljs-string">李四</span><span class="hljs-string">赵老师</span><br><span class="hljs-number">1003         </span><span class="hljs-number">001</span>   <span class="hljs-string">王五</span><span class="hljs-string">王老师</span><br><span class="hljs-number">1001         </span><span class="hljs-number">002</span>   <span class="hljs-string">张三</span><span class="hljs-string">赵老师</span><br></code></pre></td></tr></table></figure><p>第三范式：建立在第二范式的基础上，所有非主键字段直接依赖主键，不能产生【传递依赖】</p><p>​            【一对多？两张表，多的表加外键】</p><p>  &#x3D;&#x3D;在实际的开发过程中，以满足客户的需求为主，有的时候会拿冗余换速度。&#x3D;&#x3D;</p>]]></content>
    
    
    <categories>
      
      <category>数据库</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据库</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JVM详解</title>
    <link href="/2022/02/09/JVM/"/>
    <url>/2022/02/09/JVM/</url>
    
    <content type="html"><![CDATA[<h1 id="一、简介"><a href="#一、简介" class="headerlink" title="一、简介"></a>一、简介</h1><ol><li><strong>定义</strong></li></ol><p> Java Virtual Machine  Java二进制字节码的运行环境，是一套规范</p><ol start="2"><li><strong>好处</strong></li></ol><ul><li>一次编写，到处运行</li><li>自动内存管理，垃圾回收功能</li><li>数组下标越界的越界检查</li><li>多态（我去，这个底层是怎么实现的？？？  0119回答：见类加载机制多态的底层字节码指令，在类加载的时候就已经加载了具体的对象，而不是父类）</li></ul><ol start="3"><li><strong>常见的 JVM</strong></li></ol><p><img src="/2022/02/09/JVM/image-20211114165203597.png" alt="image-20211114165203597"></p><ol start="4"><li><strong>学习路线</strong></li></ol><img src="/2022/02/09/JVM/image-20211114165654954.png" alt="image-20211114165654954 " style="zoom:67%;"><h1 id="二、JVM运行时内存结构-Runtime-data-area"><a href="#二、JVM运行时内存结构-Runtime-data-area" class="headerlink" title="二、JVM运行时内存结构(Runtime data area)"></a>二、JVM运行时内存结构(Runtime data area)</h1><img src="/2022/02/09/JVM/2123988-20210114183030899-547261528.png" alt="img " style="zoom:50%;"><p>二进制字节码文件保存【类基本信息（类的版本信息、字段、方法以及接口等描述符信息）、常量池表（Constant Pool Table）、类方法定义】，在bin目录结构中</p><p>下图是进行了反编译字节码文件javap -V XXX.class</p><img src="/2022/02/09/JVM/image-20211120153945300.png" alt="image-20211120153945300 " style="zoom:67%;"><img src="/2022/02/09/JVM/image-20211120153838835.png" alt="image-20211120153838835" style="zoom:67%;"><h2 id="1-程序计数器"><a href="#1-程序计数器" class="headerlink" title="1. 程序计数器"></a>1. 程序计数器</h2><p>Program Counter Register  程序计数器（寄存器）</p><p><strong>记住下一条jvm指令的执行地址</strong></p><p><strong>特点</strong>：</p><ul><li>线程私有【即每一条线程都有一个程序计数器，随着线程的创建而创建，销毁而销毁】</li><li>唯一一个不会存在内存溢出的区</li><li>是一块比较小的内存空间</li></ul><h2 id="2-虚拟机栈"><a href="#2-虚拟机栈" class="headerlink" title="2. 虚拟机栈"></a>2. 虚拟机栈</h2><h3 id="2-1-定义"><a href="#2-1-定义" class="headerlink" title="2.1 定义"></a>2.1 定义</h3><img src="/2022/02/09/JVM/image-20211115200831828.png" alt="image-20211115200831828 " style="zoom:50%;"><p>虚拟机栈(Stack)——<strong>线程运行需要的内存空间</strong>，一个栈由多个栈帧组成</p><p>栈帧(Frame)——每个方法运行时需要的内存【例如方法参数、局部变量、方法返回地址】</p><p>&#x3D;&#x3D;每个线程只能有一个活动栈帧&#x3D;&#x3D;，对应着当前正在执行的那个方法 </p><ul><li>问题：<ul><li>栈内存分配越大越好吗？【No!  栈内存越大，即线程运行的内存空间越大，所能运行的线程数变少】</li><li>方法内的局部变量是否是线程安全？<ul><li>如果方法内局部变量没有逃离方法的作用范围，那么就是线程安全的</li><li>如果局部变量引用了对象且<strong>逃离方法的作用范围</strong>（实参、返回值等），则有线程安全的风险</li></ul></li></ul></li></ul><h3 id="2-2-栈内存溢出"><a href="#2-2-栈内存溢出" class="headerlink" title="2.2 栈内存溢出"></a>2.2 栈内存溢出</h3><p> 异常：&#x3D;&#x3D;StackOverflowError&#x3D;&#x3D;</p><h3 id="2-3-线程运行诊断"><a href="#2-3-线程运行诊断" class="headerlink" title="2.3 线程运行诊断"></a>2.3 线程运行诊断</h3><p>&#x3D;&#x3D;【这里有一个线程和进程的区别】&#x3D;&#x3D;</p><p>Linux：</p><figure class="highlight shell"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="language-bash">找到cpu占用高的进程</span><br>top<br><span class="hljs-meta">#</span><span class="language-bash">找到相应的线程（用grep过滤想要的进程<span class="hljs-built_in">id</span>）</span><br>ps H -eo pid,tid,%cpu | grep 进程id<br><span class="hljs-meta">#</span><span class="language-bash">根据进程<span class="hljs-built_in">id</span>找到有问题的线程，并进一步locate到代码行数【这里对应的线程<span class="hljs-built_in">id</span>需要做十六进制转换】</span><br>jstack 进程id    <br></code></pre></td></tr></table></figure><h2 id="3-本地方法栈"><a href="#3-本地方法栈" class="headerlink" title="3. 本地方法栈"></a>3. 本地方法栈</h2><p>只讲了哪些方法用了native【看一下native】</p><h2 id="4-堆"><a href="#4-堆" class="headerlink" title="4. 堆"></a>4. 堆</h2><h3 id="４-1-定义"><a href="#４-1-定义" class="headerlink" title="４.1 定义"></a>４.1 定义</h3><p>Heap，存放：</p><ol><li>存储的全部是对象，每个对象都包含一个与之对应的class信息。(class的目的是得到操作指令)</li><li>jvm只有一个堆区(heap)被所有线程共享，堆中不存放基本类型和对象引用，只存放对象本身</li></ol><p>特点：</p><ul><li><strong>线程共享</strong>的，堆中的对象都需要考虑线程安全的问题</li><li>有<strong>垃圾回收机制</strong></li></ul><h3 id="4-2-堆内存溢出及诊断"><a href="#4-2-堆内存溢出及诊断" class="headerlink" title="4.2 堆内存溢出及诊断"></a>4.2 堆内存溢出及诊断</h3><p><strong>java.lang.OutOfMemoryError: Java heap space</strong></p><p>可以将内存设置得小一些来看是否有堆内存溢出的可能</p><figure class="highlight diff"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs diff"><span class="hljs-deletion">-Xmx10m</span><br></code></pre></td></tr></table></figure><p><strong>堆内存诊断</strong></p><p>Linux：</p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm"><span class="hljs-keyword">jps工具：查看当前系统中有哪些java进程</span><br><span class="hljs-keyword"></span><span class="hljs-keyword">jmap工具：查看堆内存占用情况 </span>  <br><span class="hljs-keyword">jmap </span>-heap 进程id<br><span class="hljs-keyword">jconsole工具：图形界面的，多功能监测工具，可以连续监测 </span>  <br><span class="hljs-keyword">jconsole </span><br></code></pre></td></tr></table></figure><h2 id="5-方法区"><a href="#5-方法区" class="headerlink" title="5. 方法区"></a>5. 方法区</h2><h3 id="5-1-定义"><a href="#5-1-定义" class="headerlink" title="5.1 定义"></a>5.1 定义</h3><p>所有<strong>JVM线程共享</strong>的区域，它用于存储已被虚拟机加载的<strong>类型信息</strong>、<strong>常量</strong>、<strong>静态变量</strong>、<strong>即时编译器编译后的代码缓存</strong>等。</p><ul><li>类的结构相关的信息——完整类名、继承关系、类的修饰符【这些都是加载class文件得到的】</li><li>方法相关——声明的顺序、修饰符、返回值类型、名字、参数列表（有序保存）、异常表（方法抛出的异常）、方法字节码（native、abstract方法除外）、操作数栈和局部变量表大小【这些都是加载class文件得到的】</li><li>全局变量</li><li>全局常量【static final修饰的变量】 ，在编译的时候就会被分配了</li><li>static 变量——【1.7以前跟着instanceKlass存在方法区中，1.7及以后跟着类对象存在堆中】</li><li>&#x3D;&#x3D;运行时常量池&#x3D;&#x3D;【1.7版本以前包含StringTable，1.7及以后，StringTable在堆中】——运行时常量池中包含多种不同的常量，包括<strong>编译期就已经明确的数值字面量</strong>，也包括到<strong>运行期解析后才能够获得的方法或者字段引用</strong><ul><li><strong>为什么要调整StringTable的位置</strong>——永久代的回收效率很低，只有full gc时才会触发，而full gc被触发是因为老年代空间不足、永久代空间不足才会触发，导致StringTable的回收效率不高，放到堆里，能及时回收内存。</li></ul></li></ul><p>启动时被创建。</p><p>逻辑上是堆的组成部分，但是不同的JVM实现不一样</p><img src="/2022/02/09/JVM/image-20211120144944118.png" alt="image-20211120144944118 " style="zoom:100%;"><p>元空间默认情况使用系统内存，</p><img src="/2022/02/09/JVM/image-20211120144955570.png" alt="image-20211120144955570 " style="zoom:100%;"><h3 id="5-2-方法区内存溢出"><a href="#5-2-方法区内存溢出" class="headerlink" title="5.2 方法区内存溢出"></a>5.2 方法区内存溢出</h3><ul><li>1.7以前导致永久代内存溢出</li></ul><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-section">java.lang.OutOfMemoryError: PerGen space</span><br><span class="hljs-section">-XX:MaxPermSize=8m</span><br></code></pre></td></tr></table></figure><ul><li>1.7之后导致元空间内存溢出</li></ul><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-section">java.lang.OutOfMemoryError: Metaspace</span><br><span class="hljs-section">-XX:MaxMetaspace=8m</span><br></code></pre></td></tr></table></figure><p>在Spring和Mybatis中会&#x3D;&#x3D;动态加载字节码文件&#x3D;&#x3D;，所以会出现方法区内存溢出的可能。</p><h3 id="5-3-StringTable-x3D-x3D-P34-x3D-x3D"><a href="#5-3-StringTable-x3D-x3D-P34-x3D-x3D" class="headerlink" title="5.3 StringTable  &#x3D;&#x3D;P34&#x3D;&#x3D;"></a>5.3 StringTable  &#x3D;&#x3D;P34&#x3D;&#x3D;</h3><ul><li>常量池：一张表，加载二进制字节码文件（.class文件），表中储存要执行的类名、方法名、参数类型、字面量【例如字符串、布尔值等】等信息</li></ul><img src="/2022/02/09/JVM/image-20211120154544601.png" alt="image-20211120154544601 " style="zoom:67%;"><ul><li><p>运行时常量池：当该类被加载的时候，它的常量池信息就会放入<strong>运行时常量池</strong>，并把里面的符号变成真实地址。</p><p>但此时运行时常量池中的常量”a”只是符号，还没有变成java字符串对象，等待具体执行到某一行代码的时候String s1 &#x3D; “a”，将符号变成字符串对象，并准备好StringTable串池，以”a”字符串对象为key，在StringTable中找是否有相同的key，没有则将”a”字符串对象放入串池。</p></li><li><p><strong>StringTable字符串常量池，串池</strong>，底层HashTable</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">String</span> <span class="hljs-variable">s1</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;a&quot;</span>;<br><span class="hljs-type">String</span> <span class="hljs-variable">s2</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;b&quot;</span>;<br><span class="hljs-type">String</span> <span class="hljs-variable">s3</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;ab&quot;</span>;<br><span class="hljs-type">String</span> <span class="hljs-variable">s4</span> <span class="hljs-operator">=</span> s1 + s2;<span class="hljs-comment">//s1和s2为变量，则可能会发生修改，结果不是确定的，字节码文件中写的是创建StringBuilder等过程</span><br><span class="hljs-type">String</span> <span class="hljs-variable">s5</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;a&quot;</span> + <span class="hljs-string">&quot;b&quot;</span>;<span class="hljs-comment">//javac在编译期间的优化，结果已经在编译期间确定为ab，写进了字节码文件</span><br><span class="hljs-type">String</span> <span class="hljs-variable">s6</span> <span class="hljs-operator">=</span> s4.intern();<span class="hljs-comment">//串池中已有&quot;ab&quot;，则s6和s3相等，和s4不相等</span><br><br>System.out.println(s3 == s4);<span class="hljs-comment">//false</span><br>System.out.println(s3 == s5);<span class="hljs-comment">//true</span><br>System.out.println(s3 == s6);<span class="hljs-comment">//true</span><br><br><span class="hljs-type">String</span> <span class="hljs-variable">x2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(<span class="hljs-string">&quot;c&quot;</span>) + <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(<span class="hljs-string">&quot;d&quot;</span>);<span class="hljs-comment">//串池中放入&quot;c&quot;对象，堆中new String()值为“c”，串池中放入&quot;d&quot;对象，堆中new String()值为“d”，变量字符串拼接new StringBuilder.append(&quot;c&quot;).append(&quot;d&quot;).toString()，相当于new String(&quot;cd&quot;)，也是在堆中，&quot;cd&quot;不会放进串池中</span><br>x2.intern();<span class="hljs-comment">//串池中没有&quot;cd&quot;，放入</span><br><span class="hljs-type">String</span> <span class="hljs-variable">x1</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;cd&quot;</span>;<span class="hljs-comment">//直接映射到串池中已有的&quot;cd&quot;</span><br>System.out.println(x1 == x2);<span class="hljs-comment">//true</span><br></code></pre></td></tr></table></figure><p>s1、s2、s3保存的地址都是指向串池StringTable，且是运行过程执行到了这一行，才将对象放入串池中</p><p>s4是s1+s2，底层是&#x3D;&#x3D;new StringBuilder.append(“a”).append(“b”).toString()&#x3D;&#x3D;，而StringBuilder.toString()方法是new String(value,0 count)，则是创建了一个新的字符串对象，最后得到的是一个对象的引用</p><p>s5底层是直接在串池中查找String ab，和s3的底层过程是完全一样的，且发现串池中已经有了ab，则不再新建ab，直接指向原有的ab</p><p> <strong>5.3.1 特性</strong></p><ul><li>常量池中的字符串仅是符号，第一次用到时才变成对象，并将以该对象为key保存在串池中</li><li>利用串池HashTable的机制，来避免重复创建字符串对象</li><li>字符串**&#x3D;&#x3D;变量&#x3D;&#x3D;**拼接的原理是StringBuilder（jvm 1.8）</li><li>字符串**&#x3D;&#x3D;常量&#x3D;&#x3D;**拼接的原理是编译期优化</li><li>可以使用**intern()**方法，主动将串池中还没有的字符串对象放入串池<ul><li>1.6将这个字符串对象尝试方式串池，如果有则不会放入，如果没有<strong>会把此对象复制一份</strong>（此时原字符串和放入的字符串不一样），放入串池，再把串池中的对象返回。</li><li>1.7以后这个字符串对象尝试放入串池，如果有则不会放入，如果没有则放入串池，再把串池中的对象返回。</li></ul></li></ul><p><strong>5.3.2 位置</strong></p><p>在1.6版本及以前，StringTable存放在永久代PermGen中</p><p>在1.7版本及以后，StringTable存放在堆内存中</p><p>永久代的垃圾回收效率会很慢(在FULL GC时，才会进行垃圾回收，而Stringtable的更新十分频繁，所以不合适在永久代中，放在堆中可实现Minor GC即可回收)</p><p>&#x3D;&#x3D;<strong>5.3.3  StringTable的垃圾回收</strong>&#x3D;&#x3D;</p><p>StringTable会发生垃圾回收【这里具体是怎么进行垃圾回收的呢？】</p><p><strong>5.3.4  StringTable的性能调优</strong></p><p>扩大StringTable的buckets【桶】的个数，hash查找的速度会变快</p><figure class="highlight gams"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs gams">前面VM <span class="hljs-keyword">options</span>指打印StringTable的相关信息，后面VM <span class="hljs-keyword">Options</span>指修改StringTable的桶的个数<br>-XX:+PrintStringStatistics -XX:StringTableSize=<span class="hljs-number">1009</span><br></code></pre></td></tr></table></figure><h2 id="6-直接内存"><a href="#6-直接内存" class="headerlink" title="6. 直接内存"></a>6. 直接内存</h2><h1 id="三、垃圾回收【堆】"><a href="#三、垃圾回收【堆】" class="headerlink" title="三、垃圾回收【堆】"></a>三、垃圾回收【堆】</h1><h2 id="1-如何判断对象可以回收"><a href="#1-如何判断对象可以回收" class="headerlink" title="1.如何判断对象可以回收"></a>1.如何判断对象可以回收</h2><h3 id="1-1-引用计数法"><a href="#1-1-引用计数法" class="headerlink" title="1.1 引用计数法"></a>1.1 <strong>引用计数法</strong></h3><p>如果有变量引用了对象，则计数器+1，当该变量引用了其他对象，则计数器-1，计数器为0，该对象可以被回收。但是循环引用（如下图）即使没有用到对象，但是由于互相引用，还是不会被垃圾回收</p><img src="/2022/02/09/JVM/image-20211121151726713.png" alt="image-20211121151726713 " style="zoom:50%;"><h3 id="1-2-可达性分析算法"><a href="#1-2-可达性分析算法" class="headerlink" title="1.2 可达性分析算法"></a>1.2 <strong>可达性分析算法</strong></h3><ul><li>扫描堆中的对象，看是否能够沿着GC Root对象为七点的引用链找到该对象，如果找不到，则该对象可以回收</li><li>哪些对象可以作为GC Root对象？<ul><li>System Class系统类，核心类</li><li>Native Stack  操作系统在执行时引用的java对象</li><li>Thread 当前活动线程执行过程中，局部变量所引用的对象</li><li>Busy Monitor  被加锁的对象</li></ul></li></ul><h3 id="1-3-五种引用"><a href="#1-3-五种引用" class="headerlink" title="1.3 五种引用"></a>1.3 五种引用</h3><img src="/2022/02/09/JVM/image-20211121160307960.png" alt="image-20211121160307960" style="zoom:40%;"><p>1.强引用</p><ul><li>只有所有GC Root对象都不通过【强引用】引用该对象，该对象才能被垃圾回收</li></ul><p>2.软引用（SoftReference）</p><ul><li><strong>仅有</strong>软引用引用该对象时，在垃圾回收<strong>后</strong>，内存<strong>仍</strong>不足时会再次触发垃圾回收，回收软引用对象</li><li>可以配合引用队列来释放软引用自身</li></ul><p>3.弱引用（WeakReference）</p><ul><li><strong>仅有</strong>软引用引用该对象时，在垃圾回收<strong>时</strong>，无论内存是否充足，都会回收弱引用对象</li><li>可以配合引用队列来释放弱引用自身</li></ul><p>4.虚引用（PhantomReference）&#x2F;ˈfæntəm&#x2F; 幽灵</p><ul><li>必须配合引用队列使用。主要配合ByteBuffer<ul><li>创建ByteBuffer对象时，还会创建一个Cleaner虚引用对象，ByteBuffer会分配一块直接内存，并将直接内存地址传递给虚引用对象。当ByteBuffer不被强引用时垃圾回收，直接内存不会被java垃圾回收管理，此时让虚引用Cleaner对象进入引用队列，Refefence Handler线程定时确认队列中是否有新入的Cleaner，如果有，则调用Cleaner.clean()，根据直接内存地址调用Unsafe.freeMemory()释放直接内存。</li></ul></li></ul><img src="/2022/02/09/JVM/image-20211121160736903.png" alt="image-20211121160736903 " style="zoom:50%;"><p>4.虚引用</p><p>5.终结器引用（FinalReference）</p><ul><li>在垃圾回收时，终结器引用入队（被引用对象暂时没有被回收），再由Finalize Handler线程【优先级很低】通过终结器引用找到引用对象，调用其重写的finalize()方法，第二次GC时才能回收其引用对象</li></ul><p><strong>案例</strong></p><h2 id="2-垃圾回收-x2F-收集算法"><a href="#2-垃圾回收-x2F-收集算法" class="headerlink" title="2. 垃圾回收&#x2F;收集算法"></a>2. 垃圾回收&#x2F;收集算法</h2><h3 id="2-1-标记清除算法"><a href="#2-1-标记清除算法" class="headerlink" title="2.1 标记清除算法"></a>2.1 标记清除算法</h3><p>Mark Sweep</p><p>【标记阶段】对没有GC Root直接引用的对象进行标记</p><p>【清除阶段】将对象的开始结束地址放进空闲的地址列表里，下一次分配新对象的时候在空闲地址列表里找是否有合适内存空间</p><ul><li>优点：速度快，清除内存只是保存地址信息</li><li>缺点：容易产生内存碎片【原因：内存空间不连续】，容易产生内存溢出</li></ul><img src="/2022/02/09/JVM/image-20211208152202902.png" alt="image-20211208152202902" style="zoom:70%;"><h3 id="2-2-标记整理"><a href="#2-2-标记整理" class="headerlink" title="2.2 标记整理"></a>2.2 标记整理</h3><p>Mark Compact</p><p>【标记阶段】对没有GC Root直接引用的对象进行标记</p><p>【整理阶段】移动对象，进行内存整理</p><ul><li>优点：没有内存碎片</li><li>缺点：速度较慢</li></ul><img src="/2022/02/09/JVM/image-20211208152839135.png" alt="image-20211208152839135 " style="zoom:67%;"><h3 id="2-3-标记复制【半区复制】"><a href="#2-3-标记复制【半区复制】" class="headerlink" title="2.3 标记复制【半区复制】"></a>2.3 标记复制【半区复制】</h3><p>Copy</p><p>创建两个大小一模一样的堆内存空间，一个叫做【FROM】，一个叫做【TO】，每次只使用其中的一块</p><p>将存活对象复制到【TO】中，并按顺序分配空间，全部清除【FROM】中的可回收对象，最后交换【FROM】和【TO】的位置，<strong>保证【TO】里面是空的</strong></p><ul><li>优点：没有内存碎片</li><li>缺点：需要占用两倍内存空间</li><li><img src="/2022/02/09/JVM/image-20211208161229475.png" alt="image-20211208161229475 " style="zoom:67%;"></li></ul><h3 id="2-4-分代垃圾回收机制"><a href="#2-4-分代垃圾回收机制" class="headerlink" title="2.4 分代垃圾回收机制"></a>2.4 分代垃圾回收机制</h3><img src="/2022/02/09/JVM/image-20211208161242615.png" alt="image-20211208161242615 " style="zoom:80%;"><ul><li>对象首先分配在伊甸园区</li><li>新生代空间不足时，触发<strong>Minor GC</strong>， 对伊甸园区和【FROM】区使用复制标记算法——存活对象复制到【TO】，存活对象年龄加1，并删除其他所有的可回收对象，交换【FROM】和【TO】<ul><li>注1：Minor GC时会引发<strong>stop the world</strong>——暂停其他用户的线程，直到Minor GC结束，用户线程才恢复正常【一般时间比较短，因为存活对象少，复制量少】</li><li>注2：当对象寿命超过阈值【最大寿命是15(4bit)，也可能提前晋升】时，会晋升至老年代</li></ul></li><li>当老年代空间不足时，会先尝试触发<strong>Minor GC</strong>，如果之后空间仍然不足，触发<strong>Full GC</strong>，此时STW的时间更长【会采用标记清除或者标记整理算法】</li><li>当新生代本来空间就不足而老年代空间足够，会直接晋升，将大对象放入老年代中</li><li>当一个线程抛出OOM【OutOfMemoryError】异常，会清空该线程占用的堆内存</li></ul><table><thead><tr><th>含义</th><th>参数</th><th>举例</th></tr></thead><tbody><tr><td>堆初始大小</td><td>-Xms</td><td>-Xms20M</td></tr><tr><td>堆最大大小</td><td>-Xmx或-XX:MaxHeapSize&#x3D;size</td><td>-Xmx10M</td></tr><tr><td>新生代大小</td><td>-Xmn或-XX:NewSize&#x3D;size + -XX:MaxNewSize&#x3D;size</td><td>-Xmn10Ｍ</td></tr><tr><td>幸存区比例（动态）</td><td>-XX:InitialSurvivorRatio&#x3D;ratio和-XX:+UseAdaptiveSizePolicy，其中这个ratio是伊甸园的占比</td><td></td></tr><tr><td>幸存区比例</td><td>-XX:SurvivorRatio&#x3D;ratio</td><td></td></tr><tr><td>晋升阈值</td><td>-XX:MaxTenuringThreshold&#x3D;threshold</td><td></td></tr><tr><td>晋升详情</td><td>-XX:+PrintTenuringDistribution</td><td></td></tr><tr><td>GC详情</td><td>-XX:+PrintGCDetails -verbose:gc</td><td></td></tr><tr><td>FullGC前MinorGC</td><td>-XX:+ScavengeBeforeFullGC</td><td></td></tr></tbody></table><h2 id="3-垃圾回收器"><a href="#3-垃圾回收器" class="headerlink" title="3.垃圾回收器"></a>3.垃圾回收器</h2><p>新生代都采用复制算法，老年代串行和吞吐量优先采用标记整理算法，响应时间优先采用标记清除算法</p><h3 id="3-1-Serial串行"><a href="#3-1-Serial串行" class="headerlink" title="3.1 Serial串行"></a>3.1 Serial串行</h3><p>Serial：工作在新生代，采用的是<strong>复制算法</strong></p><p>SerialOld：工作在老年代，采用的是<strong>标记整理算法</strong></p><p>垃圾回收的时候此线程不阻塞，其他线程都处于阻塞状态</p><p>-XX:+UseSerialGC&#x3D;Serial+SerialOld</p><img src="/2022/02/09/JVM/image-20211208165715959.png" alt="image-20211208165715959 " style="zoom:67%;"><h3 id="3-2-Parallel-吞吐量优先"><a href="#3-2-Parallel-吞吐量优先" class="headerlink" title="3.2 Parallel 吞吐量优先"></a>3.2 Parallel 吞吐量优先</h3><p>UseParalleGC：Paralle是并行的意思，UseParalleGC工作在新生代，采用<strong>复制算法</strong></p><p>UseParalleoldGC：工作在老年代，采用<strong>标记整理算法</strong></p><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs stata">-XX:+UseParallelGC ~ -XX:+UseParallelOldGC【只要打开一个，另外一个就默认开启】<br>-XX:+UseAdaptiveSizePolicy【动态调整eden和survivor区的比例】<br>-XX:GCTimeRatio=<span class="hljs-keyword">ratio</span>【通过公式1/(1+<span class="hljs-keyword">ratio</span>)计算垃圾回收时间占总运行时间的比例，一般<span class="hljs-keyword">ratio</span>=19，<span class="hljs-keyword">ratio</span>越大，则占总运行时间越小，jvm内部会增大堆内存以减少GC次数，降低GC运行时间】（radio默认为99）【这里显示吞吐量，<span class="hljs-keyword">ratio</span>越大吞吐量越大】<br>-XX:MaxGCPauseMillis=ms【垃圾回收STW的时间，和<span class="hljs-keyword">ratio</span>之间需要权衡，<span class="hljs-keyword">ratio</span>↑，堆↑，暂停时间也会变大】（默认200ms）<br>-XX:ParallelGCThreads=<span class="hljs-keyword">n</span>【控制垃圾回收的线程数】<br></code></pre></td></tr></table></figure><p>多个线程运行到安全点的时候STW，垃圾回收器开启多个线程【线程数和已开启线程数相关】</p><img src="/2022/02/09/JVM/image-20211208211536605.png" alt="image-20211208211536605 " style="zoom:67%;"><h3 id="3-3-CMS响应时间优先"><a href="#3-3-CMS响应时间优先" class="headerlink" title="3.3 CMS响应时间优先"></a>3.3 CMS响应时间优先</h3><p>老年代<strong>标记清除算法</strong>的并发(Concurrent)CMS，当CMS发生并发失败【碎片太多】时，老年代算法变为SerialOld单线程GC，此时垃圾回收时间很长</p><p>新生代<strong>复制</strong>算法</p><p>这里并发是指：用户线程和垃圾回收线程并发执行</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs xml">-XX:+UseConcMarkSweepGC ~ -XX:+UseParNewGC ~ SerialOld<br>-XX:ParallelGCThreads=n ~ -XX:ConcGCThreads=threads<br>-XX:CMSInitiatingOccupancyFraction=percent【当老年代空间用了percent，开启CMS，这样做是预留空间给浮动垃圾】（默认68%）<br>-XX:+CMSScavengeBeforeRemark【在重新标记之前强制minor gc，减少remark的时间 +打开 -禁用】<br></code></pre></td></tr></table></figure><img src="/2022/02/09/JVM/image-20211208212814746.png" alt="image-20211208212814746" style="zoom:67%;"><p>初始标记(CMS-initial-mark)：标记<strong>根对象</strong>，较快，此时<strong>STW</strong></p><p>并发标记(CMS-concurrent-mark)：和用户线程并发执行，标记可回收对象</p><p>重新标记(CMS-remark)：标记在并发标记时没有标记到的对象，<strong>STW</strong></p><p>并发清理(CMS-concurrent-sweep)：和其他用户线程并发执行，但是无法清理此时用户线程产生的新垃圾【<strong>浮动垃圾</strong>】，要下次垃圾回收才能清理</p><h3 id="3-4-Garbage-First-G1——优先收集垃圾多的区域，达到最大暂停时间的目标"><a href="#3-4-Garbage-First-G1——优先收集垃圾多的区域，达到最大暂停时间的目标" class="headerlink" title="3.4 Garbage First  G1——优先收集垃圾多的区域，达到最大暂停时间的目标"></a>3.4 Garbage First  G1——优先收集垃圾多的区域，达到最大暂停时间的目标</h3><p>同时注重吞吐量（Throughput）和低延迟（Low latency），默认的暂停目标是 200 ms</p><p>超大堆内存，会将堆划分为多个大小相等的 Region</p><p>整体上是 标记+整理 算法，两个区域之间是 复制 算法</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs routeros">-XX:+UseG1GC【jdk1.8需要开启G1作为垃圾回收器】<br>-XX:<span class="hljs-attribute">G1HeapRegionSize</span>=size<br>-XX:<span class="hljs-attribute">MaxGCPauseMillis</span>=time<br></code></pre></td></tr></table></figure><h4 id="3-4-1工作流程"><a href="#3-4-1工作流程" class="headerlink" title="3.4.1工作流程"></a>3.4.1<strong>工作流程</strong></h4><p><img src="/2022/02/09/JVM/image-20220117133712153.png" alt="image-20220117133712153"></p><img src="/2022/02/09/JVM/image-20220116223304511.png" alt="image-20220116223304511" style="zoom:50%;"><h4 id="3-4-2-Young-Collection——会STW"><a href="#3-4-2-Young-Collection——会STW" class="headerlink" title="3.4.2 Young Collection——会STW"></a>3.4.2 <strong>Young Collection</strong>——会STW</h4><p>新创建的对象被分配到<strong>伊甸园区E</strong>，当被占满时会触发Young Collection，将E中的对象拷贝到<strong>幸存区S</strong>中，当幸存区满或幸存区中的对象年龄超过一定阈值，会触发Young Collection，S中的对象会晋升到<strong>老年代O</strong>中</p><img src="/2022/02/09/JVM/image-20220116225620091.png" alt="image-20220116225620091" style="zoom:67%;"><img src="/2022/02/09/JVM/image-20220116225710287.png" alt="image-20220116225710287" style="zoom:67%;"><h4 id="3-4-3-Young-Collection-Concurrent-Mark（并发标记）——"><a href="#3-4-3-Young-Collection-Concurrent-Mark（并发标记）——" class="headerlink" title="3.4.3 Young Collection + Concurrent Mark（并发标记）——"></a>3.4.3 Young Collection + Concurrent Mark（并发标记）——</h4><ul><li>在Young Collection时会进行GC Root的<strong>初始标记</strong></li><li>当老年代占用堆空间比例达到阈值时会进行CM（<strong>并发标记</strong>，在标记的同时不会影响到用户工作线程，在root的基础上通过引用链找到其他对象，不会STW），阈值由参数决定(-XX:InitiatingHeapOccupancyPercent&#x3D;percent)，默认45%</li></ul><img src="/2022/02/09/JVM/image-20220116230249008.png" alt="image-20220116230249008" style="zoom:67%;"><h4 id="3-4-4-Mixed-Collection——对E、S、O进行全面垃圾回收"><a href="#3-4-4-Mixed-Collection——对E、S、O进行全面垃圾回收" class="headerlink" title="3.4.4 Mixed Collection——对E、S、O进行全面垃圾回收"></a>3.4.4 <strong>Mixed Collection</strong>——对E、S、O进行全面垃圾回收</h4><ul><li>最终标记（Remark），会STW，弥补并发标记没有被标记的对象【在并发阶段还在工作的线程所产生的对象】</li><li>拷贝存活（Evacuation），会STW：</li></ul><p>​        E会复制到新的S中，满了的S也会复制到新的S中，满的S中够年龄的对象会被复制到O中</p><p>​        O【&#x3D;&#x3D;优先收集垃圾最多的区域&#x3D;&#x3D;】：根据最大暂停时间(-XX:MaxGCPauseMillis&#x3D;ms)有选择地对老年代进行垃圾回收，如果可能会超过这个时间，那么JVM会挑出最有回收价值的老年代区域【能释放的空间更大】进行回收，那么复制的区域少了，则复制时间更少。如果复制的对象没有那么多，则会回收所有的老年代——这也是叫做<strong>Garbage First的原因</strong></p><img src="/2022/02/09/JVM/image-20220116224538710.png" alt="image-20220116224538710" style="zoom:67%;"><h4 id="3-4-5-避免全堆扫描——Rememberd-Set-CardTable"><a href="#3-4-5-避免全堆扫描——Rememberd-Set-CardTable" class="headerlink" title="3.4.5 避免全堆扫描——Rememberd Set + CardTable"></a>3.4.5 <strong>避免全堆扫描——Rememberd Set + CardTable</strong></h4><p>每一个Region都有一个对应的Rememberd Set，在对Reference类型的数据进行写操作的时候，会产生一个Write Barrier暂时中断写操作，检查Reference引用的对象是否处于不同的Region之中，如果是，在concurrent refinememt threads线程中，通过CartTable将相关引用信息记录到被引用对象（新生代对象）所属Region的Rememberd Set中</p><p>新生代在GC Root的时候大部分是去老年代找，而老年代很大，直接找效率低，采用&#x3D;&#x3D;卡表&#x3D;&#x3D;Card Table的技术，将老年代的区域进行划分成Card，每一个区域512Kb</p><img src="/2022/02/09/JVM/image-20220116232640057.png" alt="image-20220116232640057" style="zoom:67%;"><p>粉红色的区是**&#x3D;&#x3D;脏卡区&#x3D;&#x3D;**，表示老年代的对象被新生代引用。</p><p>新生代中有**&#x3D;&#x3D;Rememberd Set&#x3D;&#x3D;**，记录in coming reference，有哪些脏卡，将来遍历GC Root</p><img src="/2022/02/09/JVM/image-20220116233223658.png" alt="image-20220116233223658" style="zoom:67%;"><h4 id="3-4-6-Final-Marking阶段细讲"><a href="#3-4-6-Final-Marking阶段细讲" class="headerlink" title="3.4.6 Final Marking阶段细讲"></a>3.4.6 <strong>Final Marking阶段细讲</strong></h4><p>在并发标记阶段，如果<strong>对象引用发生变化</strong>，则触发写屏障，将<strong>该对象的引用对象（如下图的A对象）</strong>加入到satb_mark_queue队列中，在Final Marking时将这中的数据进行检查合并到Remembered Set中</p><p>pre-write barrier +satb_mark_queue</p><img src="/2022/02/09/JVM/image-20220117135034871.png" alt="image-20220117135034871" style="zoom:67%;"><h4 id="3-4-7"><a href="#3-4-7" class="headerlink" title="3.4.7"></a>3.4.7</h4><h3 id="3-5-小总结"><a href="#3-5-小总结" class="headerlink" title="3.5 小总结"></a>3.5 小总结</h3><ul><li>SerialGC——<ul><li>新生代内存不足发生的垃圾收集：minor gc  <strong>Serial 复制算法</strong></li><li>老年代内存不足发生的垃圾收集：full gc    <strong>SerialOld  标记-整理算法</strong></li></ul></li><li>ParallelGC<ul><li>新生代内存不足发生的垃圾收集： minor gc  <strong>Parallel Scavenge 复制算法</strong></li><li>老年代内存不足发生的垃圾收集：full gc    <strong>ParallelOld  标记-整理算法</strong></li></ul></li><li>CMS<ul><li>新生代内存不足发生的垃圾收集： minor gc  <strong>Serial 复制算法</strong></li><li>老年代内存不足                                                  <ul><li>如果回收速度&gt;垃圾产生速度，<strong>CMS 标记-清除算法</strong></li><li>如果回收速度&lt;垃圾产生速度，退化为串行<strong>SerialOld</strong>收集</li></ul></li></ul></li><li>G1    <strong>标记-整理算法</strong><ul><li>新生代内存不足发生的垃圾收集： minor gc   </li><li>老年代内存不足（并发标记+混合收集）<ul><li>如果回收速度&gt;垃圾产生速度，则还处于Mixed Collection阶段，虽然也有STW，但是时间都没有full gc的STW时间长</li><li>如果回收速度&lt;垃圾产生速度，并发标记失败，退化为串行收集，更长时间STW</li></ul></li></ul></li></ul><p><img src="/2022/02/09/JVM/image-20220117195213775.png" alt="image-20220117195213775"></p><h2 id="4-垃圾回收调优"><a href="#4-垃圾回收调优" class="headerlink" title="4. 垃圾回收调优"></a>4. 垃圾回收调优</h2><h1 id="四、类加载与字节码技术-ClassLoader"><a href="#四、类加载与字节码技术-ClassLoader" class="headerlink" title="四、类加载与字节码技术(ClassLoader)"></a>四、类加载与字节码技术(ClassLoader)</h1><p><img src="/2022/02/09/JVM/image-20220117203826429.png" alt="image-20220117203826429"></p><h2 id="4-1-类文件【class文件】结构"><a href="#4-1-类文件【class文件】结构" class="headerlink" title="4.1 类文件【class文件】结构"></a>4.1 类文件【class文件】结构</h2><p><a href="https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-4.html">java虚拟机规范文档</a></p><p>魔数【0-3字节】、版本号【4-7字节】、<strong>常量池</strong>【到29 56结束】、访问标识与继承关系、Field信息、Method信息、附加属性</p><h2 id="4-2-字节码指令"><a href="#4-2-字节码指令" class="headerlink" title="4.2 字节码指令"></a>4.2 字节码指令</h2><h3 id="4-2-1字节码指令demo"><a href="#4-2-1字节码指令demo" class="headerlink" title="4.2.1字节码指令demo"></a>4.2.1字节码指令demo</h3><p>如下图的红框中是main函数的字节码指令</p><p><img src="/2022/02/09/JVM/image-20220117222505659.png" alt="image-20220117222505659"></p><p>类加载器加载class文件时，常量池的数据会放进运行时常量池，<strong>方法字节码指令</strong>【和方法有关】存入方法区</p><p><img src="/2022/02/09/JVM/image-20220117221347233.png" alt="image-20220117221347233"></p><p>执行引擎逐行执行方法区内的指令</p><p><img src="/2022/02/09/JVM/image-20220118142106682.png" alt="image-20220118142106682"></p><p>这里小的数字都是和字节码指令存在一起，超过 short 范围的数字存入了常量池</p><h3 id="4-2-2-经典面试题用字节码角度分析"><a href="#4-2-2-经典面试题用字节码角度分析" class="headerlink" title="4.2.2 经典面试题用字节码角度分析"></a>4.2.2 经典面试题用字节码角度分析</h3><p><strong>1.</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java">a = <span class="hljs-number">10</span>;<br>b = a++ + ++a + a--;<br>print(a);<br>print(b);<br></code></pre></td></tr></table></figure><p>最终，a &#x3D; 11， b &#x3D; 34</p><p><strong>过程见原笔记</strong></p><p><strong>2.x &#x3D; x++，最终x还是不变</strong></p><p>正常分析思路：x将值先赋给x，再自增，但是x还是x本身</p><p>字节码角度分析：iload_x将槽中的数读取出来放入操作数槽中，iinc x 1 将槽中的数+1，<strong>但是不影响操作数栈中的数值</strong>，istore x又将操作数栈中的数放入槽中，覆盖了原来的值，所以x的值一直不会变</p><p><strong>3.代码块执行顺序问题</strong></p><p>按照先后来分：静态代码块-&gt;非静态代码块-&gt;类的构造方法，</p><p>如果都是静态的或者都是非静态的，则按照程序的顺序进行加载</p><p><strong>4.不要在finally中写return，这样会吞掉所有的异常</strong>，但是可以在try中return，finally中也照样给抛出其他异常athrow</p><img src="/2022/02/09/JVM/image-20220118143527208.png" alt="image-20220118143527208 " style="zoom:67%;"><img src="/2022/02/09/JVM/image-20220118143543953.png" alt="image-20220118143543953 " style="zoom:67%;"><h3 id="4-2-3-多态原理"><a href="#4-2-3-多态原理" class="headerlink" title="4.2.3 多态原理"></a>4.2.3 多态原理</h3><h3 id="4-2-4-异常字节码指令"><a href="#4-2-4-异常字节码指令" class="headerlink" title="4.2.4 异常字节码指令"></a>4.2.4 异常字节码指令</h3><h2 id="4-3-编译期处理【语法糖优化】"><a href="#4-3-编译期处理【语法糖优化】" class="headerlink" title="4.3 编译期处理【语法糖优化】"></a>4.3 编译期处理【语法糖优化】</h2><p>将.java源码编译为.class字节码的过程，自动生成和转换的一些代码【class字节码的形式】</p><h3 id="4-3-1-默认生成构造器"><a href="#4-3-1-默认生成构造器" class="headerlink" title="4.3.1 默认生成构造器"></a>4.3.1 默认生成构造器</h3><h3 id="4-3-2-自动拆装箱"><a href="#4-3-2-自动拆装箱" class="headerlink" title="4.3.2 自动拆装箱"></a>4.3.2 自动拆装箱</h3><p>JDK5之后编译器自动加上的</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">Integer x = <span class="hljs-number">1</span>;<br><span class="hljs-built_in">int</span> y = x<br><br><span class="hljs-comment">//======================【自动拆装箱】生成的字节码的伪代码为:</span><br>Integer x = <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Integer</span>.</span></span>value<span class="hljs-constructor">Of(1)</span>;<br><span class="hljs-built_in">int</span> y = x.<span class="hljs-built_in">int</span><span class="hljs-constructor">Value()</span>;<br></code></pre></td></tr></table></figure><h3 id="4-3-3-泛型集合取值"><a href="#4-3-3-泛型集合取值" class="headerlink" title="4.3.3 泛型集合取值"></a>4.3.3 泛型集合取值</h3><p>泛型擦除——在编译时将泛型信息删除，泛型类型的参数被替换成Object类型，并在得到这个泛型数据的时候进行强制转换checkcast操作。</p><p>在字节码文件【LocalVariableTypeTable】中保存了泛型的信息，这个信息并没有被擦除</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Candy3</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        List&lt;Integer&gt; list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        list.add(<span class="hljs-number">10</span>); <span class="hljs-comment">// 实际调用的是 List.add(Object e)</span><br>        <span class="hljs-type">Integer</span> <span class="hljs-variable">x</span> <span class="hljs-operator">=</span> list.get(<span class="hljs-number">0</span>); <span class="hljs-comment">// 实际调用的是 Object obj = List.get(int index);</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="/2022/02/09/JVM/image-20220118165434177.png" alt="image-20220118165434177"></p><p><img src="/2022/02/09/JVM/image-20220118165711020.png" alt="image-20220118165711020"></p><h3 id="4-3-4-foreach循环"><a href="#4-3-4-foreach循环" class="headerlink" title="4.3.4 foreach循环"></a>4.3.4 foreach循环</h3><p>数组的foreach循环会被编译成正常的for循环</p><p>继承自Collection接口的集合的foreach循环会被编译成迭代器循环</p><h3 id="4-3-5-switch"><a href="#4-3-5-switch" class="headerlink" title="4.3.5 switch"></a>4.3.5 switch</h3><h2 id="4-4-类加载阶段"><a href="#4-4-类加载阶段" class="headerlink" title="4.4 类加载阶段"></a>4.4 类加载阶段</h2><h3 id="4-4-1-加载"><a href="#4-4-1-加载" class="headerlink" title="4.4.1 加载"></a>4.4.1 加载</h3><p>将类的字节码class文件载入方法区，内部采用C++的<strong>instanceKlass</strong>描述java类，它的重要field有：</p><ul><li>_java_mirror：java的类镜像，例如对于String来说，string.class【<strong>String的类对象</strong>】就是类镜像，作用是把<strong>klass</strong>暴露给java使用【使用者和klass之间的桥梁】</li><li>_super  父类</li><li>_fields  成员变量</li><li>_method  方法</li><li>_constants  常量池</li><li>_class_loader  类加载器</li><li>_vtable  虚拟方法表</li><li>_itable  接口方法表</li></ul><p>如图所示是jdk1.8以后的版本，方法区用元空间实现的，其中java_mirror中保存了Person.class的地址，Person.class中保存了instanceKlass的地址</p><p>当Person对象要调用成员变量或者方法的时候，会在对象头部找到Person.class的地址，再在Person.class中找到InstanceKlass的地址，最后访问方法区中的InstanceKlass得到相关信息。</p><p><img src="/2022/02/09/JVM/image-20220118200043460.png" alt="image-20220118200043460"></p><p><img src="/2022/02/09/JVM/image-20220118194722163.png" alt="image-20220118194722163"></p><h3 id="4-4-2-连接"><a href="#4-4-2-连接" class="headerlink" title="4.4.2 连接"></a>4.4.2 连接</h3><h4 id="1、-验证"><a href="#1、-验证" class="headerlink" title="1、 验证"></a>1、 验证</h4><p>验证.class文件是否符合JVM规范，安全性检查，主要检查以下，目的是保证输入的字节流能正确地解析并储存于方法区之内，只有通过了这个阶段的验证后，字节流才会进入内存的方法区中进行存储，后面的阶段全部是基于方法区的存储结构进行的，不会再直接操作字节流</p><ul><li>是否以魔数0xCAFEBABE开头</li><li>主次版本号是否在当前虚拟机处理范围之内</li><li>常量池中的常量中是否有不被支持的常量类型（检查常量tag标志）</li><li>指向常量的各种索引值中是否有指向不存在的常量或者不符合类型的常量</li><li>class文件中各个部分及文件本身是否有被删除的或者附加的其他信息</li><li>……</li></ul><h4 id="2、-准备"><a href="#2、-准备" class="headerlink" title="2、 准备"></a>2、 准备</h4><p>为类变量（static修饰的变量）分配空间并设置初始值的阶段</p><ul><li>static变量在JDK7之前储存于instanceKlass末尾（方法区），之后在类对象末尾（堆中）</li><li>static变量——准备阶段分配空间，初始化阶段赋值</li><li>static final基本类型变量——准备阶段分配空间+赋值</li><li>static final引用类型变量——准备阶段分配空间，初始化阶段赋值</li></ul><p><img src="/2022/02/09/JVM/image-20220118201412153.png" alt="image-20220118201412153"></p><h4 id="3、-解析"><a href="#3、-解析" class="headerlink" title="3、 解析"></a>3、 解析</h4><p>将常量池内的符号引用替换为直接引用的过程</p><h3 id="4-4-3-初始化"><a href="#4-4-3-初始化" class="headerlink" title="4.4.3 初始化"></a>4.4.3 初始化</h3><p>类的初始化是【懒惰的】，触发类初始化的时机有：</p><ul><li>main 方法所在的类，总会被首先初始化</li><li>首次访问这个类的静态变量或静态方法时</li><li>子类初始化，如果父类还没初始化，会引发</li><li>子类访问父类的静态变量，只会触发父类的初始化</li><li>Class.forName</li><li>new 会导致初始化</li></ul><p>不会导致类初始化有：</p><ul><li>访问类的 static final 静态常量（基本类型和字符串）不会触发初始化</li><li>类对象.class 不会触发初始化</li><li>创建该类的数组不会触发初始化</li><li>类加载器的 loadClass 方法</li><li>Class.forName 的参数 2 为 false 时</li></ul><h3 id="x3D-x3D-4-4-4-面试题——懒汉式-x3D-x3D"><a href="#x3D-x3D-4-4-4-面试题——懒汉式-x3D-x3D" class="headerlink" title="&#x3D;&#x3D;4.4.4 面试题——懒汉式&#x3D;&#x3D;"></a>&#x3D;&#x3D;4.4.4 面试题——懒汉式&#x3D;&#x3D;</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TestSingTon</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        Sington.test();<br>        Sington.getInstance();<br>    &#125;<br>&#125;<br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 懒汉式，即只有触发初始化的操作的时候，才能初始化一个类，否则这个类是不会初始化的</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Sington</span>&#123;<br>    <span class="hljs-comment">//private修饰的构造方法，让外部访问不到</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-title function_">Sington</span><span class="hljs-params">()</span>&#123;&#125;;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 定义一个静态内部类</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">LasyHolder</span>&#123;<br>        <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">Sington</span> <span class="hljs-variable">SINGTON</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Sington</span>();<br>        <span class="hljs-keyword">static</span>&#123;<br>            System.out.println(<span class="hljs-string">&quot;lasyHolder init&quot;</span>);<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">//定义一个测试方法，直接用类名调用</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test</span><span class="hljs-params">()</span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;test&quot;</span>);<br>    &#125;<br>    <span class="hljs-comment">//定义一个懒汉测试方法，调用的时候会触发懒汉类的初始化</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Sington <span class="hljs-title function_">getInstance</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-keyword">return</span> LasyHolder.SINGTON;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="x3D-x3D-4-5-类加载器-x3D-x3D"><a href="#x3D-x3D-4-5-类加载器-x3D-x3D" class="headerlink" title="&#x3D;&#x3D;4.5 类加载器&#x3D;&#x3D;"></a>&#x3D;&#x3D;4.5 类加载器&#x3D;&#x3D;</h2><table><thead><tr><th>名称</th><th>加载类的路径</th><th>说明</th></tr></thead><tbody><tr><td>Bootstrap ClassLoader启动类加载器</td><td>JAVA_HOME&#x2F;jre&#x2F;lib</td><td>无法直接访问</td></tr><tr><td>Extension ClassLoader扩展类加载器</td><td>JAVA_HOME&#x2F;jre&#x2F;lib&#x2F;ext</td><td>上级为Bootstrap，显示为null，因为无法直接访问Bootstrap ClassLoader</td></tr><tr><td>Application ClassLoader应用类加载器</td><td>classpath</td><td>上级为Extension</td></tr><tr><td>自定义类加载器</td><td>自定义</td><td>上级为Application</td></tr></tbody></table> <figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-comment">//得到类对象，此时会进行类的加载、连接和初始化</span><br>Class&lt;?&gt; aClass = <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Class</span>.</span></span><span class="hljs-keyword">for</span><span class="hljs-constructor">Name(<span class="hljs-string">&quot;类路径&quot;</span>)</span>;<br><span class="hljs-comment">//调用类加载方法</span><br>.<span class="hljs-keyword">class</span>.get<span class="hljs-constructor">ClassLoader()</span>.load<span class="hljs-constructor">Class(<span class="hljs-string">&quot;类路径&quot;</span>)</span>;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//自定义类加载器</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyClassLoader</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">ClassLoader</span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">protected</span> Class&lt;?&gt; findClass(String name) <span class="hljs-keyword">throws</span> ClassNotFoundException &#123;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">path</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;&quot;</span>;   <span class="hljs-comment">//class文件所在的路径</span><br>        <span class="hljs-type">ByteArrayOutputStream</span> <span class="hljs-variable">os</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ByteArrayOutputStream</span>();<br>        <span class="hljs-keyword">try</span> &#123;<br>            Files.copy(Paths.get(path), os);<br>            <span class="hljs-type">byte</span>[] bytes = os.toByteArray();<br>            <span class="hljs-keyword">return</span> defineClass(name, bytes, <span class="hljs-number">0</span>, bytes.length);<br>        &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>            e.printStackTrace();<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ClassNotFoundException</span>(<span class="hljs-string">&quot;类文件未找到&quot;</span>,e);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="4-5-1-双亲委派模型"><a href="#4-5-1-双亲委派模型" class="headerlink" title="4.5.1 双亲委派模型"></a>4.5.1 双亲委派模型</h3><p>调用类加载器**loadClass()**方法的时候查找类的规则</p><p>源码如下：先在当前查找已加载的类对象中是否有，如果没有，去上级类加载器中找是否有此类【这里一般是在AppClassLoader，所以parent是ExtClassLoader】，ExtClassLoader查找当前已加载的类对象是否有，如果没有，此时其parent为null，调用findBootstrapClassOrNull在启动类加载器中查找，如果也找不到，则检查一遍ExtClassLoader，如果找不到会抛出异常，这个异常被AppClassLoader接收，此时c还是没有，AppClassLoader查找当前路径下是否有，如果有则返回。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">protected</span> Class&lt;?&gt; loadClass(String name, <span class="hljs-type">boolean</span> resolve)<br>        <span class="hljs-keyword">throws</span> ClassNotFoundException<br>    &#123;<br>        <span class="hljs-keyword">synchronized</span> (getClassLoadingLock(name)) &#123;<br>            <span class="hljs-comment">// First, check if the class has already been loaded</span><br>            Class&lt;?&gt; c = findLoadedClass(name);<br>            <span class="hljs-keyword">if</span> (c == <span class="hljs-literal">null</span>) &#123;<br>                <span class="hljs-type">long</span> <span class="hljs-variable">t0</span> <span class="hljs-operator">=</span> System.nanoTime();<br>                <span class="hljs-keyword">try</span> &#123;<br>                    <span class="hljs-keyword">if</span> (parent != <span class="hljs-literal">null</span>) &#123;<br>                        <span class="hljs-comment">//如果有上级，则委派上级loadClass</span><br>                        c = parent.loadClass(name, <span class="hljs-literal">false</span>);<br>                    &#125; <span class="hljs-keyword">else</span> &#123;<br>                        <span class="hljs-comment">//如果没有上级，则委派BootstrapClassLoader</span><br>                        c = findBootstrapClassOrNull(name);<br>                    &#125;<br>                &#125; <span class="hljs-keyword">catch</span> (ClassNotFoundException e) &#123;<br>                    <span class="hljs-comment">// ClassNotFoundException thrown if class not found</span><br>                    <span class="hljs-comment">// from the non-null parent class loader</span><br>                &#125;<br><br>                <span class="hljs-keyword">if</span> (c == <span class="hljs-literal">null</span>) &#123;<br>                    <span class="hljs-comment">// If still not found, then invoke findClass in order</span><br>                    <span class="hljs-comment">// to find the class.</span><br>                    <span class="hljs-type">long</span> <span class="hljs-variable">t1</span> <span class="hljs-operator">=</span> System.nanoTime();<br>                    <span class="hljs-comment">//在自己的类加载器路径下查找</span><br>                    c = findClass(name);<br><br>                    <span class="hljs-comment">// this is the defining class loader; record the stats</span><br>                    sun.misc.PerfCounter.getParentDelegationTime().addTime(t1 - t0);<br>                    sun.misc.PerfCounter.getFindClassTime().addElapsedTimeFrom(t1);<br>                    sun.misc.PerfCounter.getFindClasses().increment();<br>                &#125;<br>            &#125;<br>            <span class="hljs-keyword">if</span> (resolve) &#123;<br>                resolveClass(c);<br>            &#125;<br>            <span class="hljs-keyword">return</span> c;<br>        &#125;<br>    &#125;<br></code></pre></td></tr></table></figure><h3 id="4-5-2-线程上下文类加载器——破坏双亲委派模型"><a href="#4-5-2-线程上下文类加载器——破坏双亲委派模型" class="headerlink" title="4.5.2 线程上下文类加载器——破坏双亲委派模型"></a>4.5.2 线程上下文类加载器——破坏双亲委派模型</h3><p>以jdbc.Driver举例</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">DriverManager</span> &#123;<br><span class="hljs-comment">/* Prevent the DriverManager class from being instantiated. */</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-title function_">DriverManager</span><span class="hljs-params">()</span>&#123;&#125;<br><br>    <span class="hljs-keyword">static</span> &#123;<br>        loadInitialDrivers();<br>        println(<span class="hljs-string">&quot;JDBC DriverManager initialized&quot;</span>);<br>    &#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">loadInitialDrivers</span><span class="hljs-params">()</span> &#123;<br>        String drivers;<br>        <span class="hljs-keyword">try</span> &#123;<br>            drivers = AccessController.doPrivileged(<span class="hljs-keyword">new</span> <span class="hljs-title class_">PrivilegedAction</span>&lt;String&gt;() &#123;<br>                <span class="hljs-keyword">public</span> String <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>                    <span class="hljs-keyword">return</span> System.getProperty(<span class="hljs-string">&quot;jdbc.drivers&quot;</span>);<br>                &#125;<br>            &#125;);<br>        &#125; <span class="hljs-keyword">catch</span> (Exception ex) &#123;<br>            drivers = <span class="hljs-literal">null</span>;<br>        &#125;<br><br>    <span class="hljs-comment">//1.使用ServiceLoader机制加载驱动，SPI(Service Provider Interface)</span><br>        AccessController.doPrivileged(<span class="hljs-keyword">new</span> <span class="hljs-title class_">PrivilegedAction</span>&lt;Void&gt;() &#123;<br>            <span class="hljs-keyword">public</span> Void <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br><br>                ServiceLoader&lt;Driver&gt; loadedDrivers = ServiceLoader.load(Driver.class);<br>                Iterator&lt;Driver&gt; driversIterator = loadedDrivers.iterator();<br>               <br>                <span class="hljs-keyword">try</span>&#123;<br>                    <span class="hljs-keyword">while</span>(driversIterator.hasNext()) &#123;<br>                        driversIterator.next();<br>                    &#125;<br>                &#125; <span class="hljs-keyword">catch</span>(Throwable t) &#123;<br>                <span class="hljs-comment">// Do nothing</span><br>                &#125;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>            &#125;<br>        &#125;);<br><br>        println(<span class="hljs-string">&quot;DriverManager.initialize: jdbc.drivers = &quot;</span> + drivers);<br><br>    <span class="hljs-comment">//2.使用jdbc.Drivers定义的驱动名加载驱动</span><br>        <span class="hljs-keyword">if</span> (drivers == <span class="hljs-literal">null</span> || drivers.equals(<span class="hljs-string">&quot;&quot;</span>)) &#123;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        String[] driversList = drivers.split(<span class="hljs-string">&quot;:&quot;</span>);<br>        println(<span class="hljs-string">&quot;number of Drivers:&quot;</span> + driversList.length);<br>        <span class="hljs-keyword">for</span> (String aDriver : driversList) &#123;<br>            <span class="hljs-keyword">try</span> &#123;<br>                println(<span class="hljs-string">&quot;DriverManager.Initialize: loading &quot;</span> + aDriver);<br>                <span class="hljs-comment">//getSystemClassLoader()就是应用程序类加载器</span><br>                Class.forName(aDriver, <span class="hljs-literal">true</span>,<br>                        ClassLoader.getSystemClassLoader());<br>            &#125; <span class="hljs-keyword">catch</span> (Exception ex) &#123;<br>                println(<span class="hljs-string">&quot;DriverManager.Initialize: load failed: &quot;</span> + ex);<br>            &#125;<br>        &#125;<br>    &#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> &lt;S&gt; ServiceLoader&lt;S&gt; <span class="hljs-title function_">load</span><span class="hljs-params">(Class&lt;S&gt; service)</span> &#123;<br>    <span class="hljs-comment">//获取线程上下文类加载器，默认就是应用程序类加载器</span><br>    <span class="hljs-type">ClassLoader</span> <span class="hljs-variable">cl</span> <span class="hljs-operator">=</span> Thread.currentThread().getContextClassLoader();<br>    <span class="hljs-keyword">return</span> ServiceLoader.load(service, cl);<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> &lt;S&gt; ServiceLoader&lt;S&gt; <span class="hljs-title function_">load</span><span class="hljs-params">(Class&lt;S&gt; service,ClassLoader loader)</span><br>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ServiceLoader</span>&lt;&gt;(service, loader);<br>&#125;<br><span class="hljs-comment">//在ServiceLoader类中的内部类LazyIterator中的nextService()方法使用class.forName方法从应用类加载器开始加载</span><br></code></pre></td></tr></table></figure><p>&#x3D;&#x3D;SPI详细&#x3D;&#x3D;：在 jar 包的 META-INF&#x2F;services 包下，以接口全限定名名为文件，文件内容是实现类名称</p><img src="/2022/02/09/JVM/image-20220118233933846.png" alt="image-20220118233933846 " style="zoom:67%;"><p>只要做了这样的配置，就可以使用这种写法加载接口的实现类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java">ServiceLoader&lt;接口类型&gt; allImpls = ServiceLoader.load(接口类型.class);<br>Iterator&lt;接口类型&gt; iter = allImpls.iterator();<br><span class="hljs-keyword">while</span>(iter.hasNext()) &#123;<br>iter.next();<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="4-6-运行期优化"><a href="#4-6-运行期优化" class="headerlink" title="4.6 运行期优化"></a>4.6 运行期优化</h2>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
