

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=auto>



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/favicon.png">
  <link rel="icon" href="/img/favicon.png">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="author" content="John Doe">
  <meta name="keywords" content="">
  
    <meta name="description" content="一、简介 定义   Java Virtual Machine  Java二进制字节码的运行环境，是一套规范  好处   一次编写，到处运行 自动内存管理，垃圾回收功能 数组下标越界的越界检查 多态（我去，这个底层是怎么实现的？？？  0119回答：见类加载机制多态的底层字节码指令，在类加载的时候就已经加载了具体的对象，而不是父类）   常见的 JVM    学习路线    二、JVM运行时内存结构">
<meta property="og:type" content="article">
<meta property="og:title" content="JVM详解">
<meta property="og:url" content="https://yoursite.com/2022/02/09/JVM/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="一、简介 定义   Java Virtual Machine  Java二进制字节码的运行环境，是一套规范  好处   一次编写，到处运行 自动内存管理，垃圾回收功能 数组下标越界的越界检查 多态（我去，这个底层是怎么实现的？？？  0119回答：见类加载机制多态的底层字节码指令，在类加载的时候就已经加载了具体的对象，而不是父类）   常见的 JVM    学习路线    二、JVM运行时内存结构">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://yoursite.com/2022/02/09/JVM/image-20211114165203597.png">
<meta property="og:image" content="https://yoursite.com/2022/02/09/JVM/image-20211114165654954.png">
<meta property="og:image" content="https://yoursite.com/2022/02/09/JVM/2123988-20210114183030899-547261528.png">
<meta property="og:image" content="https://yoursite.com/2022/02/09/JVM/image-20211120153945300.png">
<meta property="og:image" content="https://yoursite.com/2022/02/09/JVM/image-20211120153838835.png">
<meta property="og:image" content="https://yoursite.com/2022/02/09/JVM/image-20211115200831828.png">
<meta property="og:image" content="https://yoursite.com/2022/02/09/JVM/image-20211120144944118.png">
<meta property="og:image" content="https://yoursite.com/2022/02/09/JVM/image-20211120144955570.png">
<meta property="og:image" content="https://yoursite.com/2022/02/09/JVM/image-20211120154544601.png">
<meta property="og:image" content="https://yoursite.com/2022/02/09/JVM/image-20211121151726713.png">
<meta property="og:image" content="https://yoursite.com/2022/02/09/JVM/image-20211121160307960.png">
<meta property="og:image" content="https://yoursite.com/2022/02/09/JVM/image-20211121160736903.png">
<meta property="og:image" content="https://yoursite.com/2022/02/09/JVM/image-20211208152202902.png">
<meta property="og:image" content="https://yoursite.com/2022/02/09/JVM/image-20211208152839135.png">
<meta property="og:image" content="https://yoursite.com/2022/02/09/JVM/image-20211208161229475.png">
<meta property="og:image" content="https://yoursite.com/2022/02/09/JVM/image-20211208161242615.png">
<meta property="og:image" content="https://yoursite.com/2022/02/09/JVM/image-20211208165715959.png">
<meta property="og:image" content="https://yoursite.com/2022/02/09/JVM/image-20211208211536605.png">
<meta property="og:image" content="https://yoursite.com/2022/02/09/JVM/image-20211208212814746.png">
<meta property="og:image" content="https://yoursite.com/2022/02/09/JVM/image-20220117133712153.png">
<meta property="og:image" content="https://yoursite.com/2022/02/09/JVM/image-20220116223304511.png">
<meta property="og:image" content="https://yoursite.com/2022/02/09/JVM/image-20220116225620091.png">
<meta property="og:image" content="https://yoursite.com/2022/02/09/JVM/image-20220116225710287.png">
<meta property="og:image" content="https://yoursite.com/2022/02/09/JVM/image-20220116230249008.png">
<meta property="og:image" content="https://yoursite.com/2022/02/09/JVM/image-20220116224538710.png">
<meta property="og:image" content="https://yoursite.com/2022/02/09/JVM/image-20220116232640057.png">
<meta property="og:image" content="https://yoursite.com/2022/02/09/JVM/image-20220116233223658.png">
<meta property="og:image" content="https://yoursite.com/2022/02/09/JVM/image-20220117135034871.png">
<meta property="og:image" content="https://yoursite.com/2022/02/09/JVM/image-20220117195213775.png">
<meta property="og:image" content="https://yoursite.com/2022/02/09/JVM/image-20220117203826429.png">
<meta property="og:image" content="https://yoursite.com/2022/02/09/JVM/image-20220117222505659.png">
<meta property="og:image" content="https://yoursite.com/2022/02/09/JVM/image-20220117221347233.png">
<meta property="og:image" content="https://yoursite.com/2022/02/09/JVM/image-20220118142106682.png">
<meta property="og:image" content="https://yoursite.com/2022/02/09/JVM/image-20220118143527208.png">
<meta property="og:image" content="https://yoursite.com/2022/02/09/JVM/image-20220118143543953.png">
<meta property="og:image" content="https://yoursite.com/2022/02/09/JVM/image-20220118165434177.png">
<meta property="og:image" content="https://yoursite.com/2022/02/09/JVM/image-20220118165711020.png">
<meta property="og:image" content="https://yoursite.com/2022/02/09/JVM/image-20220118200043460.png">
<meta property="og:image" content="https://yoursite.com/2022/02/09/JVM/image-20220118194722163.png">
<meta property="og:image" content="https://yoursite.com/2022/02/09/JVM/image-20220118201412153.png">
<meta property="og:image" content="https://yoursite.com/2022/02/09/JVM/image-20220118233933846.png">
<meta property="article:published_time" content="2022-02-09T02:24:09.000Z">
<meta property="article:modified_time" content="2022-02-09T14:59:43.056Z">
<meta property="article:author" content="John Doe">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="https://yoursite.com/2022/02/09/JVM/image-20211114165203597.png">
  
  
  <title>JVM详解 - Hexo</title>

  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4/dist/css/bootstrap.min.css" />


  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/github-markdown-css@4/github-markdown.min.css" />
  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/hint.css@2/hint.min.css" />

  
    
    
      
      <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@10/styles/github-gist.min.css" />
    
  

  
    <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3/dist/jquery.fancybox.min.css" />
  


<!-- 主题依赖的图标库，不要自行修改 -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_ba1fz6golrf.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_lbnruvf0jn.css">


<link  rel="stylesheet" href="/css/main.css" />

<!-- 自定义样式保持在最底部 -->


  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    var CONFIG = {"hostname":"yoursite.com","root":"/","version":"1.8.14","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"right","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"copy_btn":true,"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":false,"baidu":null,"google":null,"gtag":null,"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":null,"app_key":null,"server_url":null,"path":"window.location.pathname","ignore_local":false}},"search_path":"/local-search.xml"};
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
<meta name="generator" content="Hexo 6.0.0"></head>


<body>
  <header style="height: 70vh;">
    <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong>Twinkle&#39;s Blog</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/">
                <i class="iconfont icon-home-fill"></i>
                首页
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/">
                <i class="iconfont icon-archive-fill"></i>
                归档
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/">
                <i class="iconfont icon-category-fill"></i>
                分类
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/">
                <i class="iconfont icon-tags-fill"></i>
                标签
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/">
                <i class="iconfont icon-user-fill"></i>
                关于
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              &nbsp;<i class="iconfont icon-search"></i>&nbsp;
            </a>
          </li>
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">&nbsp;<i
                class="iconfont icon-dark" id="color-toggle-icon"></i>&nbsp;</a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

    <div class="banner" id="banner" parallax=true
         style="background: url('/img/default.png') no-repeat center center;
           background-size: cover;">
      <div class="full-bg-img">
        <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
          <div class="page-header text-center fade-in-up">
            <span class="h2" id="subtitle" title="JVM详解">
              
            </span>

            
              <div class="mt-3">
  
  
    <span class="post-meta">
      <i class="iconfont icon-date-fill" aria-hidden="true"></i>
      <time datetime="2022-02-09 10:24" pubdate>
        2022年2月9日 上午
      </time>
    </span>
  
</div>

<div class="mt-1">
  
    <span class="post-meta mr-2">
      <i class="iconfont icon-chart"></i>
      17k 字
    </span>
  

  
    <span class="post-meta mr-2">
      <i class="iconfont icon-clock-fill"></i>
      
      
      146 分钟
    </span>
  

  
  
</div>

            
          </div>

          
        </div>
      </div>
    </div>
  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="d-none d-lg-block col-lg-2"></div>
    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div class="py-5" id="board">
          <article class="post-content mx-auto">
            <!-- SEO header -->
            <h1 style="display: none">JVM详解</h1>
            
            <div class="markdown-body">
              <h1 id="一、简介"><a href="#一、简介" class="headerlink" title="一、简介"></a>一、简介</h1><ol>
<li><strong>定义</strong></li>
</ol>
<p> Java Virtual Machine  Java二进制字节码的运行环境，是一套规范</p>
<ol start="2">
<li><strong>好处</strong></li>
</ol>
<ul>
<li>一次编写，到处运行</li>
<li>自动内存管理，垃圾回收功能</li>
<li>数组下标越界的越界检查</li>
<li>多态（我去，这个底层是怎么实现的？？？  0119回答：见类加载机制多态的底层字节码指令，在类加载的时候就已经加载了具体的对象，而不是父类）</li>
</ul>
<ol start="3">
<li><strong>常见的 JVM</strong></li>
</ol>
<p><img src="/2022/02/09/JVM/image-20211114165203597.png" srcset="/img/loading.gif" lazyload alt="image-20211114165203597"></p>
<ol start="4">
<li><strong>学习路线</strong></li>
</ol>
<img src="/2022/02/09/JVM/image-20211114165654954.png" srcset="/img/loading.gif" lazyload alt="image-20211114165654954 " style="zoom:67%;">

<h1 id="二、JVM运行时内存结构-Runtime-data-area"><a href="#二、JVM运行时内存结构-Runtime-data-area" class="headerlink" title="二、JVM运行时内存结构(Runtime data area)"></a>二、JVM运行时内存结构(Runtime data area)</h1><img src="/2022/02/09/JVM/2123988-20210114183030899-547261528.png" srcset="/img/loading.gif" lazyload alt="img " style="zoom:50%;">

<p>二进制字节码文件保存【类基本信息（类的版本信息、字段、方法以及接口等描述符信息）、常量池表（Constant Pool Table）、类方法定义】，在bin目录结构中</p>
<p>下图是进行了反编译字节码文件javap -V XXX.class</p>
<img src="/2022/02/09/JVM/image-20211120153945300.png" srcset="/img/loading.gif" lazyload alt="image-20211120153945300 " style="zoom:67%;">

<img src="/2022/02/09/JVM/image-20211120153838835.png" srcset="/img/loading.gif" lazyload alt="image-20211120153838835" style="zoom:67%;">

<h2 id="1-程序计数器"><a href="#1-程序计数器" class="headerlink" title="1. 程序计数器"></a>1. 程序计数器</h2><p>Program Counter Register  程序计数器（寄存器）</p>
<p><strong>记住下一条jvm指令的执行地址</strong></p>
<p><strong>特点</strong>：</p>
<ul>
<li>线程私有【即每一条线程都有一个程序计数器，随着线程的创建而创建，销毁而销毁】</li>
<li>唯一一个不会存在内存溢出的区</li>
<li>是一块比较小的内存空间</li>
</ul>
<h2 id="2-虚拟机栈"><a href="#2-虚拟机栈" class="headerlink" title="2. 虚拟机栈"></a>2. 虚拟机栈</h2><h3 id="2-1-定义"><a href="#2-1-定义" class="headerlink" title="2.1 定义"></a>2.1 定义</h3><img src="/2022/02/09/JVM/image-20211115200831828.png" srcset="/img/loading.gif" lazyload alt="image-20211115200831828 " style="zoom:50%;">

<p>虚拟机栈(Stack)——<strong>线程运行需要的内存空间</strong>，一个栈由多个栈帧组成</p>
<p>栈帧(Frame)——每个方法运行时需要的内存【例如方法参数、局部变量、方法返回地址】</p>
<p>&#x3D;&#x3D;每个线程只能有一个活动栈帧&#x3D;&#x3D;，对应着当前正在执行的那个方法 </p>
<ul>
<li>问题：<ul>
<li>栈内存分配越大越好吗？【No!  栈内存越大，即线程运行的内存空间越大，所能运行的线程数变少】</li>
<li>方法内的局部变量是否是线程安全？<ul>
<li>如果方法内局部变量没有逃离方法的作用范围，那么就是线程安全的</li>
<li>如果局部变量引用了对象且<strong>逃离方法的作用范围</strong>（实参、返回值等），则有线程安全的风险</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="2-2-栈内存溢出"><a href="#2-2-栈内存溢出" class="headerlink" title="2.2 栈内存溢出"></a>2.2 栈内存溢出</h3><p> 异常：&#x3D;&#x3D;StackOverflowError&#x3D;&#x3D;</p>
<h3 id="2-3-线程运行诊断"><a href="#2-3-线程运行诊断" class="headerlink" title="2.3 线程运行诊断"></a>2.3 线程运行诊断</h3><p>&#x3D;&#x3D;【这里有一个线程和进程的区别】&#x3D;&#x3D;</p>
<p>Linux：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="language-bash">找到cpu占用高的进程</span><br>top<br><span class="hljs-meta">#</span><span class="language-bash">找到相应的线程（用grep过滤想要的进程<span class="hljs-built_in">id</span>）</span><br>ps H -eo pid,tid,%cpu | grep 进程id<br><span class="hljs-meta">#</span><span class="language-bash">根据进程<span class="hljs-built_in">id</span>找到有问题的线程，并进一步locate到代码行数【这里对应的线程<span class="hljs-built_in">id</span>需要做十六进制转换】</span><br>jstack 进程id    <br></code></pre></td></tr></table></figure>

<h2 id="3-本地方法栈"><a href="#3-本地方法栈" class="headerlink" title="3. 本地方法栈"></a>3. 本地方法栈</h2><p>只讲了哪些方法用了native【看一下native】</p>
<h2 id="4-堆"><a href="#4-堆" class="headerlink" title="4. 堆"></a>4. 堆</h2><h3 id="４-1-定义"><a href="#４-1-定义" class="headerlink" title="４.1 定义"></a>４.1 定义</h3><p>Heap，存放：</p>
<ol>
<li>存储的全部是对象，每个对象都包含一个与之对应的class信息。(class的目的是得到操作指令)</li>
<li>jvm只有一个堆区(heap)被所有线程共享，堆中不存放基本类型和对象引用，只存放对象本身</li>
</ol>
<p>特点：</p>
<ul>
<li><strong>线程共享</strong>的，堆中的对象都需要考虑线程安全的问题</li>
<li>有<strong>垃圾回收机制</strong></li>
</ul>
<h3 id="4-2-堆内存溢出及诊断"><a href="#4-2-堆内存溢出及诊断" class="headerlink" title="4.2 堆内存溢出及诊断"></a>4.2 堆内存溢出及诊断</h3><p><strong>java.lang.OutOfMemoryError: Java heap space</strong></p>
<p>可以将内存设置得小一些来看是否有堆内存溢出的可能</p>
<figure class="highlight diff"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs diff"><span class="hljs-deletion">-Xmx10m</span><br></code></pre></td></tr></table></figure>

<p><strong>堆内存诊断</strong></p>
<p>Linux：</p>
<figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm"><span class="hljs-keyword">jps工具：查看当前系统中有哪些java进程</span><br><span class="hljs-keyword"></span><span class="hljs-keyword">jmap工具：查看堆内存占用情况 </span>  <br>	<span class="hljs-keyword">jmap </span>-heap 进程id<br><span class="hljs-keyword">jconsole工具：图形界面的，多功能监测工具，可以连续监测 </span>  <br>	<span class="hljs-keyword">jconsole </span><br></code></pre></td></tr></table></figure>

<h2 id="5-方法区"><a href="#5-方法区" class="headerlink" title="5. 方法区"></a>5. 方法区</h2><h3 id="5-1-定义"><a href="#5-1-定义" class="headerlink" title="5.1 定义"></a>5.1 定义</h3><p>所有<strong>JVM线程共享</strong>的区域，它用于存储已被虚拟机加载的<strong>类型信息</strong>、<strong>常量</strong>、<strong>静态变量</strong>、<strong>即时编译器编译后的代码缓存</strong>等。</p>
<ul>
<li>类的结构相关的信息——完整类名、继承关系、类的修饰符【这些都是加载class文件得到的】</li>
<li>方法相关——声明的顺序、修饰符、返回值类型、名字、参数列表（有序保存）、异常表（方法抛出的异常）、方法字节码（native、abstract方法除外）、操作数栈和局部变量表大小【这些都是加载class文件得到的】</li>
<li>全局变量</li>
<li>全局常量【static final修饰的变量】 ，在编译的时候就会被分配了</li>
<li>static 变量——【1.7以前跟着instanceKlass存在方法区中，1.7及以后跟着类对象存在堆中】</li>
<li>&#x3D;&#x3D;运行时常量池&#x3D;&#x3D;【1.7版本以前包含StringTable，1.7及以后，StringTable在堆中】——运行时常量池中包含多种不同的常量，包括<strong>编译期就已经明确的数值字面量</strong>，也包括到<strong>运行期解析后才能够获得的方法或者字段引用</strong><ul>
<li><strong>为什么要调整StringTable的位置</strong>——永久代的回收效率很低，只有full gc时才会触发，而full gc被触发是因为老年代空间不足、永久代空间不足才会触发，导致StringTable的回收效率不高，放到堆里，能及时回收内存。</li>
</ul>
</li>
</ul>
<p>启动时被创建。</p>
<p>逻辑上是堆的组成部分，但是不同的JVM实现不一样</p>
<img src="/2022/02/09/JVM/image-20211120144944118.png" srcset="/img/loading.gif" lazyload alt="image-20211120144944118 " style="zoom:100%;">

<p>元空间默认情况使用系统内存，</p>
<img src="/2022/02/09/JVM/image-20211120144955570.png" srcset="/img/loading.gif" lazyload alt="image-20211120144955570 " style="zoom:100%;">

<h3 id="5-2-方法区内存溢出"><a href="#5-2-方法区内存溢出" class="headerlink" title="5.2 方法区内存溢出"></a>5.2 方法区内存溢出</h3><ul>
<li>1.7以前导致永久代内存溢出</li>
</ul>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-section">java.lang.OutOfMemoryError: PerGen space</span><br><span class="hljs-section">-XX:MaxPermSize=8m</span><br></code></pre></td></tr></table></figure>

<ul>
<li>1.7之后导致元空间内存溢出</li>
</ul>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-section">java.lang.OutOfMemoryError: Metaspace</span><br><span class="hljs-section">-XX:MaxMetaspace=8m</span><br></code></pre></td></tr></table></figure>

<p>在Spring和Mybatis中会&#x3D;&#x3D;动态加载字节码文件&#x3D;&#x3D;，所以会出现方法区内存溢出的可能。</p>
<h3 id="5-3-StringTable-x3D-x3D-P34-x3D-x3D"><a href="#5-3-StringTable-x3D-x3D-P34-x3D-x3D" class="headerlink" title="5.3 StringTable  &#x3D;&#x3D;P34&#x3D;&#x3D;"></a>5.3 StringTable  &#x3D;&#x3D;P34&#x3D;&#x3D;</h3><ul>
<li>常量池：一张表，加载二进制字节码文件（.class文件），表中储存要执行的类名、方法名、参数类型、字面量【例如字符串、布尔值等】等信息</li>
</ul>
<img src="/2022/02/09/JVM/image-20211120154544601.png" srcset="/img/loading.gif" lazyload alt="image-20211120154544601 " style="zoom:67%;">

<ul>
<li><p>运行时常量池：当该类被加载的时候，它的常量池信息就会放入<strong>运行时常量池</strong>，并把里面的符号变成真实地址。</p>
<p>但此时运行时常量池中的常量”a”只是符号，还没有变成java字符串对象，等待具体执行到某一行代码的时候String s1 &#x3D; “a”，将符号变成字符串对象，并准备好StringTable串池，以”a”字符串对象为key，在StringTable中找是否有相同的key，没有则将”a”字符串对象放入串池。</p>
</li>
<li><p><strong>StringTable字符串常量池，串池</strong>，底层HashTable</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">String</span> <span class="hljs-variable">s1</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;a&quot;</span>;<br><span class="hljs-type">String</span> <span class="hljs-variable">s2</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;b&quot;</span>;<br><span class="hljs-type">String</span> <span class="hljs-variable">s3</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;ab&quot;</span>;<br><span class="hljs-type">String</span> <span class="hljs-variable">s4</span> <span class="hljs-operator">=</span> s1 + s2;	<span class="hljs-comment">//s1和s2为变量，则可能会发生修改，结果不是确定的，字节码文件中写的是创建StringBuilder等过程</span><br><span class="hljs-type">String</span> <span class="hljs-variable">s5</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;a&quot;</span> + <span class="hljs-string">&quot;b&quot;</span>;	<span class="hljs-comment">//javac在编译期间的优化，结果已经在编译期间确定为ab，写进了字节码文件</span><br><span class="hljs-type">String</span> <span class="hljs-variable">s6</span> <span class="hljs-operator">=</span> s4.intern();	<span class="hljs-comment">//串池中已有&quot;ab&quot;，则s6和s3相等，和s4不相等</span><br><br>System.out.println(s3 == s4);	<span class="hljs-comment">//false</span><br>System.out.println(s3 == s5);	<span class="hljs-comment">//true</span><br>System.out.println(s3 == s6);	<span class="hljs-comment">//true</span><br><br><span class="hljs-type">String</span> <span class="hljs-variable">x2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(<span class="hljs-string">&quot;c&quot;</span>) + <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(<span class="hljs-string">&quot;d&quot;</span>);	<span class="hljs-comment">//串池中放入&quot;c&quot;对象，堆中new String()值为“c”，串池中放入&quot;d&quot;对象，堆中new String()值为“d”，变量字符串拼接new StringBuilder.append(&quot;c&quot;).append(&quot;d&quot;).toString()，相当于new String(&quot;cd&quot;)，也是在堆中，&quot;cd&quot;不会放进串池中</span><br>x2.intern();	<span class="hljs-comment">//串池中没有&quot;cd&quot;，放入</span><br><span class="hljs-type">String</span> <span class="hljs-variable">x1</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;cd&quot;</span>;	<span class="hljs-comment">//直接映射到串池中已有的&quot;cd&quot;</span><br>System.out.println(x1 == x2);	<span class="hljs-comment">//true</span><br></code></pre></td></tr></table></figure>

<p>s1、s2、s3保存的地址都是指向串池StringTable，且是运行过程执行到了这一行，才将对象放入串池中</p>
<p>s4是s1+s2，底层是&#x3D;&#x3D;new StringBuilder.append(“a”).append(“b”).toString()&#x3D;&#x3D;，而StringBuilder.toString()方法是new String(value,0 count)，则是创建了一个新的字符串对象，最后得到的是一个对象的引用</p>
<p>s5底层是直接在串池中查找String ab，和s3的底层过程是完全一样的，且发现串池中已经有了ab，则不再新建ab，直接指向原有的ab</p>
<p> <strong>5.3.1 特性</strong></p>
<ul>
<li>常量池中的字符串仅是符号，第一次用到时才变成对象，并将以该对象为key保存在串池中</li>
<li>利用串池HashTable的机制，来避免重复创建字符串对象</li>
<li>字符串**&#x3D;&#x3D;变量&#x3D;&#x3D;**拼接的原理是StringBuilder（jvm 1.8）</li>
<li>字符串**&#x3D;&#x3D;常量&#x3D;&#x3D;**拼接的原理是编译期优化</li>
<li>可以使用**intern()**方法，主动将串池中还没有的字符串对象放入串池<ul>
<li>1.6将这个字符串对象尝试方式串池，如果有则不会放入，如果没有<strong>会把此对象复制一份</strong>（此时原字符串和放入的字符串不一样），放入串池，再把串池中的对象返回。</li>
<li>1.7以后这个字符串对象尝试放入串池，如果有则不会放入，如果没有则放入串池，再把串池中的对象返回。</li>
</ul>
</li>
</ul>
<p><strong>5.3.2 位置</strong></p>
<p>在1.6版本及以前，StringTable存放在永久代PermGen中</p>
<p>在1.7版本及以后，StringTable存放在堆内存中</p>
<p>永久代的垃圾回收效率会很慢(在FULL GC时，才会进行垃圾回收，而Stringtable的更新十分频繁，所以不合适在永久代中，放在堆中可实现Minor GC即可回收)</p>
<p>&#x3D;&#x3D;<strong>5.3.3  StringTable的垃圾回收</strong>&#x3D;&#x3D;</p>
<p>StringTable会发生垃圾回收【这里具体是怎么进行垃圾回收的呢？】</p>
<p><strong>5.3.4  StringTable的性能调优</strong></p>
<p>扩大StringTable的buckets【桶】的个数，hash查找的速度会变快</p>
<figure class="highlight gams"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs gams">前面VM <span class="hljs-keyword">options</span>指打印StringTable的相关信息，后面VM <span class="hljs-keyword">Options</span>指修改StringTable的桶的个数<br>-XX:+PrintStringStatistics -XX:StringTableSize=<span class="hljs-number">1009</span><br></code></pre></td></tr></table></figure>

<h2 id="6-直接内存"><a href="#6-直接内存" class="headerlink" title="6. 直接内存"></a>6. 直接内存</h2><h1 id="三、垃圾回收【堆】"><a href="#三、垃圾回收【堆】" class="headerlink" title="三、垃圾回收【堆】"></a>三、垃圾回收【堆】</h1><h2 id="1-如何判断对象可以回收"><a href="#1-如何判断对象可以回收" class="headerlink" title="1.如何判断对象可以回收"></a>1.如何判断对象可以回收</h2><h3 id="1-1-引用计数法"><a href="#1-1-引用计数法" class="headerlink" title="1.1 引用计数法"></a>1.1 <strong>引用计数法</strong></h3><p>如果有变量引用了对象，则计数器+1，当该变量引用了其他对象，则计数器-1，计数器为0，该对象可以被回收。但是循环引用（如下图）即使没有用到对象，但是由于互相引用，还是不会被垃圾回收</p>
<img src="/2022/02/09/JVM/image-20211121151726713.png" srcset="/img/loading.gif" lazyload alt="image-20211121151726713 " style="zoom:50%;">

<h3 id="1-2-可达性分析算法"><a href="#1-2-可达性分析算法" class="headerlink" title="1.2 可达性分析算法"></a>1.2 <strong>可达性分析算法</strong></h3><ul>
<li>扫描堆中的对象，看是否能够沿着GC Root对象为七点的引用链找到该对象，如果找不到，则该对象可以回收</li>
<li>哪些对象可以作为GC Root对象？<ul>
<li>System Class系统类，核心类</li>
<li>Native Stack  操作系统在执行时引用的java对象</li>
<li>Thread 当前活动线程执行过程中，局部变量所引用的对象</li>
<li>Busy Monitor  被加锁的对象</li>
</ul>
</li>
</ul>
<h3 id="1-3-五种引用"><a href="#1-3-五种引用" class="headerlink" title="1.3 五种引用"></a>1.3 五种引用</h3><img src="/2022/02/09/JVM/image-20211121160307960.png" srcset="/img/loading.gif" lazyload alt="image-20211121160307960" style="zoom:40%;">

<p>1.强引用</p>
<ul>
<li>只有所有GC Root对象都不通过【强引用】引用该对象，该对象才能被垃圾回收</li>
</ul>
<p>2.软引用（SoftReference）</p>
<ul>
<li><strong>仅有</strong>软引用引用该对象时，在垃圾回收<strong>后</strong>，内存<strong>仍</strong>不足时会再次触发垃圾回收，回收软引用对象</li>
<li>可以配合引用队列来释放软引用自身</li>
</ul>
<p>3.弱引用（WeakReference）</p>
<ul>
<li><strong>仅有</strong>软引用引用该对象时，在垃圾回收<strong>时</strong>，无论内存是否充足，都会回收弱引用对象</li>
<li>可以配合引用队列来释放弱引用自身</li>
</ul>
<p>4.虚引用（PhantomReference）&#x2F;ˈfæntəm&#x2F; 幽灵</p>
<ul>
<li>必须配合引用队列使用。主要配合ByteBuffer<ul>
<li>创建ByteBuffer对象时，还会创建一个Cleaner虚引用对象，ByteBuffer会分配一块直接内存，并将直接内存地址传递给虚引用对象。当ByteBuffer不被强引用时垃圾回收，直接内存不会被java垃圾回收管理，此时让虚引用Cleaner对象进入引用队列，Refefence Handler线程定时确认队列中是否有新入的Cleaner，如果有，则调用Cleaner.clean()，根据直接内存地址调用Unsafe.freeMemory()释放直接内存。</li>
</ul>
</li>
</ul>
<img src="/2022/02/09/JVM/image-20211121160736903.png" srcset="/img/loading.gif" lazyload alt="image-20211121160736903 " style="zoom:50%;">

<p>4.虚引用</p>
<p>5.终结器引用（FinalReference）</p>
<ul>
<li>在垃圾回收时，终结器引用入队（被引用对象暂时没有被回收），再由Finalize Handler线程【优先级很低】通过终结器引用找到引用对象，调用其重写的finalize()方法，第二次GC时才能回收其引用对象</li>
</ul>
<p><strong>案例</strong></p>
<h2 id="2-垃圾回收-x2F-收集算法"><a href="#2-垃圾回收-x2F-收集算法" class="headerlink" title="2. 垃圾回收&#x2F;收集算法"></a>2. 垃圾回收&#x2F;收集算法</h2><h3 id="2-1-标记清除算法"><a href="#2-1-标记清除算法" class="headerlink" title="2.1 标记清除算法"></a>2.1 标记清除算法</h3><p>Mark Sweep</p>
<p>【标记阶段】对没有GC Root直接引用的对象进行标记</p>
<p>【清除阶段】将对象的开始结束地址放进空闲的地址列表里，下一次分配新对象的时候在空闲地址列表里找是否有合适内存空间</p>
<ul>
<li>优点：速度快，清除内存只是保存地址信息</li>
<li>缺点：容易产生内存碎片【原因：内存空间不连续】，容易产生内存溢出</li>
</ul>
<img src="/2022/02/09/JVM/image-20211208152202902.png" srcset="/img/loading.gif" lazyload alt="image-20211208152202902" style="zoom:70%;">

<h3 id="2-2-标记整理"><a href="#2-2-标记整理" class="headerlink" title="2.2 标记整理"></a>2.2 标记整理</h3><p>Mark Compact</p>
<p>【标记阶段】对没有GC Root直接引用的对象进行标记</p>
<p>【整理阶段】移动对象，进行内存整理</p>
<ul>
<li>优点：没有内存碎片</li>
<li>缺点：速度较慢</li>
</ul>
<img src="/2022/02/09/JVM/image-20211208152839135.png" srcset="/img/loading.gif" lazyload alt="image-20211208152839135 " style="zoom:67%;">

<h3 id="2-3-标记复制【半区复制】"><a href="#2-3-标记复制【半区复制】" class="headerlink" title="2.3 标记复制【半区复制】"></a>2.3 标记复制【半区复制】</h3><p>Copy</p>
<p>创建两个大小一模一样的堆内存空间，一个叫做【FROM】，一个叫做【TO】，每次只使用其中的一块</p>
<p>将存活对象复制到【TO】中，并按顺序分配空间，全部清除【FROM】中的可回收对象，最后交换【FROM】和【TO】的位置，<strong>保证【TO】里面是空的</strong></p>
<ul>
<li>优点：没有内存碎片</li>
<li>缺点：需要占用两倍内存空间</li>
<li><img src="/2022/02/09/JVM/image-20211208161229475.png" srcset="/img/loading.gif" lazyload alt="image-20211208161229475 " style="zoom:67%;"></li>
</ul>
<h3 id="2-4-分代垃圾回收机制"><a href="#2-4-分代垃圾回收机制" class="headerlink" title="2.4 分代垃圾回收机制"></a>2.4 分代垃圾回收机制</h3><img src="/2022/02/09/JVM/image-20211208161242615.png" srcset="/img/loading.gif" lazyload alt="image-20211208161242615 " style="zoom:80%;">

<ul>
<li>对象首先分配在伊甸园区</li>
<li>新生代空间不足时，触发<strong>Minor GC</strong>， 对伊甸园区和【FROM】区使用复制标记算法——存活对象复制到【TO】，存活对象年龄加1，并删除其他所有的可回收对象，交换【FROM】和【TO】<ul>
<li>注1：Minor GC时会引发<strong>stop the world</strong>——暂停其他用户的线程，直到Minor GC结束，用户线程才恢复正常【一般时间比较短，因为存活对象少，复制量少】</li>
<li>注2：当对象寿命超过阈值【最大寿命是15(4bit)，也可能提前晋升】时，会晋升至老年代</li>
</ul>
</li>
<li>当老年代空间不足时，会先尝试触发<strong>Minor GC</strong>，如果之后空间仍然不足，触发<strong>Full GC</strong>，此时STW的时间更长【会采用标记清除或者标记整理算法】</li>
<li>当新生代本来空间就不足而老年代空间足够，会直接晋升，将大对象放入老年代中</li>
<li>当一个线程抛出OOM【OutOfMemoryError】异常，会清空该线程占用的堆内存</li>
</ul>
<table>
<thead>
<tr>
<th>含义</th>
<th>参数</th>
<th>举例</th>
</tr>
</thead>
<tbody><tr>
<td>堆初始大小</td>
<td>-Xms</td>
<td>-Xms20M</td>
</tr>
<tr>
<td>堆最大大小</td>
<td>-Xmx或-XX:MaxHeapSize&#x3D;size</td>
<td>-Xmx10M</td>
</tr>
<tr>
<td>新生代大小</td>
<td>-Xmn或-XX:NewSize&#x3D;size + -XX:MaxNewSize&#x3D;size</td>
<td>-Xmn10Ｍ</td>
</tr>
<tr>
<td>幸存区比例（动态）</td>
<td>-XX:InitialSurvivorRatio&#x3D;ratio和-XX:+UseAdaptiveSizePolicy，其中这个ratio是伊甸园的占比</td>
<td></td>
</tr>
<tr>
<td>幸存区比例</td>
<td>-XX:SurvivorRatio&#x3D;ratio</td>
<td></td>
</tr>
<tr>
<td>晋升阈值</td>
<td>-XX:MaxTenuringThreshold&#x3D;threshold</td>
<td></td>
</tr>
<tr>
<td>晋升详情</td>
<td>-XX:+PrintTenuringDistribution</td>
<td></td>
</tr>
<tr>
<td>GC详情</td>
<td>-XX:+PrintGCDetails -verbose:gc</td>
<td></td>
</tr>
<tr>
<td>FullGC前MinorGC</td>
<td>-XX:+ScavengeBeforeFullGC</td>
<td></td>
</tr>
</tbody></table>
<h2 id="3-垃圾回收器"><a href="#3-垃圾回收器" class="headerlink" title="3.垃圾回收器"></a>3.垃圾回收器</h2><p>新生代都采用复制算法，老年代串行和吞吐量优先采用标记整理算法，响应时间优先采用标记清除算法</p>
<h3 id="3-1-Serial串行"><a href="#3-1-Serial串行" class="headerlink" title="3.1 Serial串行"></a>3.1 Serial串行</h3><p>Serial：工作在新生代，采用的是<strong>复制算法</strong></p>
<p>SerialOld：工作在老年代，采用的是<strong>标记整理算法</strong></p>
<p>垃圾回收的时候此线程不阻塞，其他线程都处于阻塞状态</p>
<p>-XX:+UseSerialGC&#x3D;Serial+SerialOld</p>
<img src="/2022/02/09/JVM/image-20211208165715959.png" srcset="/img/loading.gif" lazyload alt="image-20211208165715959 " style="zoom:67%;">

<h3 id="3-2-Parallel-吞吐量优先"><a href="#3-2-Parallel-吞吐量优先" class="headerlink" title="3.2 Parallel 吞吐量优先"></a>3.2 Parallel 吞吐量优先</h3><p>UseParalleGC：Paralle是并行的意思，UseParalleGC工作在新生代，采用<strong>复制算法</strong></p>
<p>UseParalleoldGC：工作在老年代，采用<strong>标记整理算法</strong></p>
<figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs stata">-XX:+UseParallelGC ~ -XX:+UseParallelOldGC【只要打开一个，另外一个就默认开启】<br>-XX:+UseAdaptiveSizePolicy【动态调整eden和survivor区的比例】<br>-XX:GCTimeRatio=<span class="hljs-keyword">ratio</span>【通过公式1/(1+<span class="hljs-keyword">ratio</span>)计算垃圾回收时间占总运行时间的比例，一般<span class="hljs-keyword">ratio</span>=19，<span class="hljs-keyword">ratio</span>越大，则占总运行时间越小，jvm内部会增大堆内存以减少GC次数，降低GC运行时间】（radio默认为99）【这里显示吞吐量，<span class="hljs-keyword">ratio</span>越大吞吐量越大】<br>-XX:MaxGCPauseMillis=ms【垃圾回收STW的时间，和<span class="hljs-keyword">ratio</span>之间需要权衡，<span class="hljs-keyword">ratio</span>↑，堆↑，暂停时间也会变大】（默认200ms）<br>-XX:ParallelGCThreads=<span class="hljs-keyword">n</span>【控制垃圾回收的线程数】<br></code></pre></td></tr></table></figure>

<p>多个线程运行到安全点的时候STW，垃圾回收器开启多个线程【线程数和已开启线程数相关】</p>
<img src="/2022/02/09/JVM/image-20211208211536605.png" srcset="/img/loading.gif" lazyload alt="image-20211208211536605 " style="zoom:67%;">

<h3 id="3-3-CMS响应时间优先"><a href="#3-3-CMS响应时间优先" class="headerlink" title="3.3 CMS响应时间优先"></a>3.3 CMS响应时间优先</h3><p>老年代<strong>标记清除算法</strong>的并发(Concurrent)CMS，当CMS发生并发失败【碎片太多】时，老年代算法变为SerialOld单线程GC，此时垃圾回收时间很长</p>
<p>新生代<strong>复制</strong>算法</p>
<p>这里并发是指：用户线程和垃圾回收线程并发执行</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs xml">-XX:+UseConcMarkSweepGC ~ -XX:+UseParNewGC ~ SerialOld<br>-XX:ParallelGCThreads=n ~ -XX:ConcGCThreads=threads<br>-XX:CMSInitiatingOccupancyFraction=percent【当老年代空间用了percent，开启CMS，这样做是预留空间给浮动垃圾】（默认68%）<br>-XX:+CMSScavengeBeforeRemark【在重新标记之前强制minor gc，减少remark的时间 +打开 -禁用】<br></code></pre></td></tr></table></figure>

<img src="/2022/02/09/JVM/image-20211208212814746.png" srcset="/img/loading.gif" lazyload alt="image-20211208212814746" style="zoom:67%;">

<p>初始标记(CMS-initial-mark)：标记<strong>根对象</strong>，较快，此时<strong>STW</strong></p>
<p>并发标记(CMS-concurrent-mark)：和用户线程并发执行，标记可回收对象</p>
<p>重新标记(CMS-remark)：标记在并发标记时没有标记到的对象，<strong>STW</strong></p>
<p>并发清理(CMS-concurrent-sweep)：和其他用户线程并发执行，但是无法清理此时用户线程产生的新垃圾【<strong>浮动垃圾</strong>】，要下次垃圾回收才能清理</p>
<h3 id="3-4-Garbage-First-G1——优先收集垃圾多的区域，达到最大暂停时间的目标"><a href="#3-4-Garbage-First-G1——优先收集垃圾多的区域，达到最大暂停时间的目标" class="headerlink" title="3.4 Garbage First  G1——优先收集垃圾多的区域，达到最大暂停时间的目标"></a>3.4 Garbage First  G1——优先收集垃圾多的区域，达到最大暂停时间的目标</h3><p>同时注重吞吐量（Throughput）和低延迟（Low latency），默认的暂停目标是 200 ms</p>
<p>超大堆内存，会将堆划分为多个大小相等的 Region</p>
<p>整体上是 标记+整理 算法，两个区域之间是 复制 算法</p>
<figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs routeros">-XX:+UseG1GC【jdk1.8需要开启G1作为垃圾回收器】<br>-XX:<span class="hljs-attribute">G1HeapRegionSize</span>=size<br>-XX:<span class="hljs-attribute">MaxGCPauseMillis</span>=time<br></code></pre></td></tr></table></figure>

<h4 id="3-4-1工作流程"><a href="#3-4-1工作流程" class="headerlink" title="3.4.1工作流程"></a>3.4.1<strong>工作流程</strong></h4><p><img src="/2022/02/09/JVM/image-20220117133712153.png" srcset="/img/loading.gif" lazyload alt="image-20220117133712153"></p>
<img src="/2022/02/09/JVM/image-20220116223304511.png" srcset="/img/loading.gif" lazyload alt="image-20220116223304511" style="zoom:50%;">

<h4 id="3-4-2-Young-Collection——会STW"><a href="#3-4-2-Young-Collection——会STW" class="headerlink" title="3.4.2 Young Collection——会STW"></a>3.4.2 <strong>Young Collection</strong>——会STW</h4><p>新创建的对象被分配到<strong>伊甸园区E</strong>，当被占满时会触发Young Collection，将E中的对象拷贝到<strong>幸存区S</strong>中，当幸存区满或幸存区中的对象年龄超过一定阈值，会触发Young Collection，S中的对象会晋升到<strong>老年代O</strong>中</p>
<img src="/2022/02/09/JVM/image-20220116225620091.png" srcset="/img/loading.gif" lazyload alt="image-20220116225620091" style="zoom:67%;">

<img src="/2022/02/09/JVM/image-20220116225710287.png" srcset="/img/loading.gif" lazyload alt="image-20220116225710287" style="zoom:67%;">

<h4 id="3-4-3-Young-Collection-Concurrent-Mark（并发标记）——"><a href="#3-4-3-Young-Collection-Concurrent-Mark（并发标记）——" class="headerlink" title="3.4.3 Young Collection + Concurrent Mark（并发标记）——"></a>3.4.3 Young Collection + Concurrent Mark（并发标记）——</h4><ul>
<li>在Young Collection时会进行GC Root的<strong>初始标记</strong></li>
<li>当老年代占用堆空间比例达到阈值时会进行CM（<strong>并发标记</strong>，在标记的同时不会影响到用户工作线程，在root的基础上通过引用链找到其他对象，不会STW），阈值由参数决定(-XX:InitiatingHeapOccupancyPercent&#x3D;percent)，默认45%</li>
</ul>
<img src="/2022/02/09/JVM/image-20220116230249008.png" srcset="/img/loading.gif" lazyload alt="image-20220116230249008" style="zoom:67%;">

<h4 id="3-4-4-Mixed-Collection——对E、S、O进行全面垃圾回收"><a href="#3-4-4-Mixed-Collection——对E、S、O进行全面垃圾回收" class="headerlink" title="3.4.4 Mixed Collection——对E、S、O进行全面垃圾回收"></a>3.4.4 <strong>Mixed Collection</strong>——对E、S、O进行全面垃圾回收</h4><ul>
<li>最终标记（Remark），会STW，弥补并发标记没有被标记的对象【在并发阶段还在工作的线程所产生的对象】</li>
<li>拷贝存活（Evacuation），会STW：</li>
</ul>
<p>​        E会复制到新的S中，满了的S也会复制到新的S中，满的S中够年龄的对象会被复制到O中</p>
<p>​        O【&#x3D;&#x3D;优先收集垃圾最多的区域&#x3D;&#x3D;】：根据最大暂停时间(-XX:MaxGCPauseMillis&#x3D;ms)有选择地对老年代进行垃圾回收，如果可能会超过这个时间，那么JVM会挑出最有回收价值的老年代区域【能释放的空间更大】进行回收，那么复制的区域少了，则复制时间更少。如果复制的对象没有那么多，则会回收所有的老年代——这也是叫做<strong>Garbage First的原因</strong></p>
<img src="/2022/02/09/JVM/image-20220116224538710.png" srcset="/img/loading.gif" lazyload alt="image-20220116224538710" style="zoom:67%;">

<h4 id="3-4-5-避免全堆扫描——Rememberd-Set-CardTable"><a href="#3-4-5-避免全堆扫描——Rememberd-Set-CardTable" class="headerlink" title="3.4.5 避免全堆扫描——Rememberd Set + CardTable"></a>3.4.5 <strong>避免全堆扫描——Rememberd Set + CardTable</strong></h4><p>每一个Region都有一个对应的Rememberd Set，在对Reference类型的数据进行写操作的时候，会产生一个Write Barrier暂时中断写操作，检查Reference引用的对象是否处于不同的Region之中，如果是，在concurrent refinememt threads线程中，通过CartTable将相关引用信息记录到被引用对象（新生代对象）所属Region的Rememberd Set中</p>
<p>新生代在GC Root的时候大部分是去老年代找，而老年代很大，直接找效率低，采用&#x3D;&#x3D;卡表&#x3D;&#x3D;Card Table的技术，将老年代的区域进行划分成Card，每一个区域512Kb</p>
<img src="/2022/02/09/JVM/image-20220116232640057.png" srcset="/img/loading.gif" lazyload alt="image-20220116232640057" style="zoom:67%;">

<p>粉红色的区是**&#x3D;&#x3D;脏卡区&#x3D;&#x3D;**，表示老年代的对象被新生代引用。</p>
<p>新生代中有**&#x3D;&#x3D;Rememberd Set&#x3D;&#x3D;**，记录in coming reference，有哪些脏卡，将来遍历GC Root</p>
<img src="/2022/02/09/JVM/image-20220116233223658.png" srcset="/img/loading.gif" lazyload alt="image-20220116233223658" style="zoom:67%;">

<h4 id="3-4-6-Final-Marking阶段细讲"><a href="#3-4-6-Final-Marking阶段细讲" class="headerlink" title="3.4.6 Final Marking阶段细讲"></a>3.4.6 <strong>Final Marking阶段细讲</strong></h4><p>在并发标记阶段，如果<strong>对象引用发生变化</strong>，则触发写屏障，将<strong>该对象的引用对象（如下图的A对象）</strong>加入到satb_mark_queue队列中，在Final Marking时将这中的数据进行检查合并到Remembered Set中</p>
<p>pre-write barrier +satb_mark_queue</p>
<img src="/2022/02/09/JVM/image-20220117135034871.png" srcset="/img/loading.gif" lazyload alt="image-20220117135034871" style="zoom:67%;">

<h4 id="3-4-7"><a href="#3-4-7" class="headerlink" title="3.4.7"></a>3.4.7</h4><h3 id="3-5-小总结"><a href="#3-5-小总结" class="headerlink" title="3.5 小总结"></a>3.5 小总结</h3><ul>
<li>SerialGC——<ul>
<li>新生代内存不足发生的垃圾收集：minor gc  <strong>Serial 复制算法</strong></li>
<li>老年代内存不足发生的垃圾收集：full gc    <strong>SerialOld  标记-整理算法</strong></li>
</ul>
</li>
<li>ParallelGC<ul>
<li>新生代内存不足发生的垃圾收集： minor gc  <strong>Parallel Scavenge 复制算法</strong></li>
<li>老年代内存不足发生的垃圾收集：full gc    <strong>ParallelOld  标记-整理算法</strong></li>
</ul>
</li>
<li>CMS<ul>
<li>新生代内存不足发生的垃圾收集： minor gc  <strong>Serial 复制算法</strong></li>
<li>老年代内存不足                                                  <ul>
<li>如果回收速度&gt;垃圾产生速度，<strong>CMS 标记-清除算法</strong></li>
<li>如果回收速度&lt;垃圾产生速度，退化为串行<strong>SerialOld</strong>收集</li>
</ul>
</li>
</ul>
</li>
<li>G1    <strong>标记-整理算法</strong><ul>
<li>新生代内存不足发生的垃圾收集： minor gc   </li>
<li>老年代内存不足（并发标记+混合收集）<ul>
<li>如果回收速度&gt;垃圾产生速度，则还处于Mixed Collection阶段，虽然也有STW，但是时间都没有full gc的STW时间长</li>
<li>如果回收速度&lt;垃圾产生速度，并发标记失败，退化为串行收集，更长时间STW</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><img src="/2022/02/09/JVM/image-20220117195213775.png" srcset="/img/loading.gif" lazyload alt="image-20220117195213775"></p>
<h2 id="4-垃圾回收调优"><a href="#4-垃圾回收调优" class="headerlink" title="4. 垃圾回收调优"></a>4. 垃圾回收调优</h2><h1 id="四、类加载与字节码技术-ClassLoader"><a href="#四、类加载与字节码技术-ClassLoader" class="headerlink" title="四、类加载与字节码技术(ClassLoader)"></a>四、类加载与字节码技术(ClassLoader)</h1><p><img src="/2022/02/09/JVM/image-20220117203826429.png" srcset="/img/loading.gif" lazyload alt="image-20220117203826429"></p>
<h2 id="4-1-类文件【class文件】结构"><a href="#4-1-类文件【class文件】结构" class="headerlink" title="4.1 类文件【class文件】结构"></a>4.1 类文件【class文件】结构</h2><p><a target="_blank" rel="noopener" href="https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-4.html">java虚拟机规范文档</a></p>
<p>魔数【0-3字节】、版本号【4-7字节】、<strong>常量池</strong>【到29 56结束】、访问标识与继承关系、Field信息、Method信息、附加属性</p>
<h2 id="4-2-字节码指令"><a href="#4-2-字节码指令" class="headerlink" title="4.2 字节码指令"></a>4.2 字节码指令</h2><h3 id="4-2-1字节码指令demo"><a href="#4-2-1字节码指令demo" class="headerlink" title="4.2.1字节码指令demo"></a>4.2.1字节码指令demo</h3><p>如下图的红框中是main函数的字节码指令</p>
<p><img src="/2022/02/09/JVM/image-20220117222505659.png" srcset="/img/loading.gif" lazyload alt="image-20220117222505659"></p>
<p>类加载器加载class文件时，常量池的数据会放进运行时常量池，<strong>方法字节码指令</strong>【和方法有关】存入方法区</p>
<p><img src="/2022/02/09/JVM/image-20220117221347233.png" srcset="/img/loading.gif" lazyload alt="image-20220117221347233"></p>
<p>执行引擎逐行执行方法区内的指令</p>
<p><img src="/2022/02/09/JVM/image-20220118142106682.png" srcset="/img/loading.gif" lazyload alt="image-20220118142106682"></p>
<p>这里小的数字都是和字节码指令存在一起，超过 short 范围的数字存入了常量池</p>
<h3 id="4-2-2-经典面试题用字节码角度分析"><a href="#4-2-2-经典面试题用字节码角度分析" class="headerlink" title="4.2.2 经典面试题用字节码角度分析"></a>4.2.2 经典面试题用字节码角度分析</h3><p><strong>1.</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java">a = <span class="hljs-number">10</span>;<br>b = a++ + ++a + a--;<br>print(a);<br>print(b);<br></code></pre></td></tr></table></figure>

<p>最终，a &#x3D; 11， b &#x3D; 34</p>
<p><strong>过程见原笔记</strong></p>
<p><strong>2.x &#x3D; x++，最终x还是不变</strong></p>
<p>正常分析思路：x将值先赋给x，再自增，但是x还是x本身</p>
<p>字节码角度分析：iload_x将槽中的数读取出来放入操作数槽中，iinc x 1 将槽中的数+1，<strong>但是不影响操作数栈中的数值</strong>，istore x又将操作数栈中的数放入槽中，覆盖了原来的值，所以x的值一直不会变</p>
<p><strong>3.代码块执行顺序问题</strong></p>
<p>按照先后来分：静态代码块-&gt;非静态代码块-&gt;类的构造方法，</p>
<p>如果都是静态的或者都是非静态的，则按照程序的顺序进行加载</p>
<p><strong>4.不要在finally中写return，这样会吞掉所有的异常</strong>，但是可以在try中return，finally中也照样给抛出其他异常athrow</p>
<img src="/2022/02/09/JVM/image-20220118143527208.png" srcset="/img/loading.gif" lazyload alt="image-20220118143527208 " style="zoom:67%;">

<img src="/2022/02/09/JVM/image-20220118143543953.png" srcset="/img/loading.gif" lazyload alt="image-20220118143543953 " style="zoom:67%;">

<h3 id="4-2-3-多态原理"><a href="#4-2-3-多态原理" class="headerlink" title="4.2.3 多态原理"></a>4.2.3 多态原理</h3><h3 id="4-2-4-异常字节码指令"><a href="#4-2-4-异常字节码指令" class="headerlink" title="4.2.4 异常字节码指令"></a>4.2.4 异常字节码指令</h3><h2 id="4-3-编译期处理【语法糖优化】"><a href="#4-3-编译期处理【语法糖优化】" class="headerlink" title="4.3 编译期处理【语法糖优化】"></a>4.3 编译期处理【语法糖优化】</h2><p>将.java源码编译为.class字节码的过程，自动生成和转换的一些代码【class字节码的形式】</p>
<h3 id="4-3-1-默认生成构造器"><a href="#4-3-1-默认生成构造器" class="headerlink" title="4.3.1 默认生成构造器"></a>4.3.1 默认生成构造器</h3><h3 id="4-3-2-自动拆装箱"><a href="#4-3-2-自动拆装箱" class="headerlink" title="4.3.2 自动拆装箱"></a>4.3.2 自动拆装箱</h3><p>JDK5之后编译器自动加上的</p>
<figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">Integer x = <span class="hljs-number">1</span>;<br><span class="hljs-built_in">int</span> y = x<br><br><span class="hljs-comment">//======================【自动拆装箱】生成的字节码的伪代码为:</span><br>Integer x = <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Integer</span>.</span></span>value<span class="hljs-constructor">Of(1)</span>;<br><span class="hljs-built_in">int</span> y = x.<span class="hljs-built_in">int</span><span class="hljs-constructor">Value()</span>;<br></code></pre></td></tr></table></figure>

<h3 id="4-3-3-泛型集合取值"><a href="#4-3-3-泛型集合取值" class="headerlink" title="4.3.3 泛型集合取值"></a>4.3.3 泛型集合取值</h3><p>泛型擦除——在编译时将泛型信息删除，泛型类型的参数被替换成Object类型，并在得到这个泛型数据的时候进行强制转换checkcast操作。</p>
<p>在字节码文件【LocalVariableTypeTable】中保存了泛型的信息，这个信息并没有被擦除</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Candy3</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        List&lt;Integer&gt; list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        list.add(<span class="hljs-number">10</span>); <span class="hljs-comment">// 实际调用的是 List.add(Object e)</span><br>        <span class="hljs-type">Integer</span> <span class="hljs-variable">x</span> <span class="hljs-operator">=</span> list.get(<span class="hljs-number">0</span>); <span class="hljs-comment">// 实际调用的是 Object obj = List.get(int index);</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p><img src="/2022/02/09/JVM/image-20220118165434177.png" srcset="/img/loading.gif" lazyload alt="image-20220118165434177"></p>
<p><img src="/2022/02/09/JVM/image-20220118165711020.png" srcset="/img/loading.gif" lazyload alt="image-20220118165711020"></p>
<h3 id="4-3-4-foreach循环"><a href="#4-3-4-foreach循环" class="headerlink" title="4.3.4 foreach循环"></a>4.3.4 foreach循环</h3><p>数组的foreach循环会被编译成正常的for循环</p>
<p>继承自Collection接口的集合的foreach循环会被编译成迭代器循环</p>
<h3 id="4-3-5-switch"><a href="#4-3-5-switch" class="headerlink" title="4.3.5 switch"></a>4.3.5 switch</h3><h2 id="4-4-类加载阶段"><a href="#4-4-类加载阶段" class="headerlink" title="4.4 类加载阶段"></a>4.4 类加载阶段</h2><h3 id="4-4-1-加载"><a href="#4-4-1-加载" class="headerlink" title="4.4.1 加载"></a>4.4.1 加载</h3><p>将类的字节码class文件载入方法区，内部采用C++的<strong>instanceKlass</strong>描述java类，它的重要field有：</p>
<ul>
<li>_java_mirror：java的类镜像，例如对于String来说，string.class【<strong>String的类对象</strong>】就是类镜像，作用是把<strong>klass</strong>暴露给java使用【使用者和klass之间的桥梁】</li>
<li>_super  父类</li>
<li>_fields  成员变量</li>
<li>_method  方法</li>
<li>_constants  常量池</li>
<li>_class_loader  类加载器</li>
<li>_vtable  虚拟方法表</li>
<li>_itable  接口方法表</li>
</ul>
<p>如图所示是jdk1.8以后的版本，方法区用元空间实现的，其中java_mirror中保存了Person.class的地址，Person.class中保存了instanceKlass的地址</p>
<p>当Person对象要调用成员变量或者方法的时候，会在对象头部找到Person.class的地址，再在Person.class中找到InstanceKlass的地址，最后访问方法区中的InstanceKlass得到相关信息。</p>
<p><img src="/2022/02/09/JVM/image-20220118200043460.png" srcset="/img/loading.gif" lazyload alt="image-20220118200043460"></p>
<p><img src="/2022/02/09/JVM/image-20220118194722163.png" srcset="/img/loading.gif" lazyload alt="image-20220118194722163"></p>
<h3 id="4-4-2-连接"><a href="#4-4-2-连接" class="headerlink" title="4.4.2 连接"></a>4.4.2 连接</h3><h4 id="1、-验证"><a href="#1、-验证" class="headerlink" title="1、 验证"></a>1、 验证</h4><p>验证.class文件是否符合JVM规范，安全性检查，主要检查以下，目的是保证输入的字节流能正确地解析并储存于方法区之内，只有通过了这个阶段的验证后，字节流才会进入内存的方法区中进行存储，后面的阶段全部是基于方法区的存储结构进行的，不会再直接操作字节流</p>
<ul>
<li>是否以魔数0xCAFEBABE开头</li>
<li>主次版本号是否在当前虚拟机处理范围之内</li>
<li>常量池中的常量中是否有不被支持的常量类型（检查常量tag标志）</li>
<li>指向常量的各种索引值中是否有指向不存在的常量或者不符合类型的常量</li>
<li>class文件中各个部分及文件本身是否有被删除的或者附加的其他信息</li>
<li>……</li>
</ul>
<h4 id="2、-准备"><a href="#2、-准备" class="headerlink" title="2、 准备"></a>2、 准备</h4><p>为类变量（static修饰的变量）分配空间并设置初始值的阶段</p>
<ul>
<li>static变量在JDK7之前储存于instanceKlass末尾（方法区），之后在类对象末尾（堆中）</li>
<li>static变量——准备阶段分配空间，初始化阶段赋值</li>
<li>static final基本类型变量——准备阶段分配空间+赋值</li>
<li>static final引用类型变量——准备阶段分配空间，初始化阶段赋值</li>
</ul>
<p><img src="/2022/02/09/JVM/image-20220118201412153.png" srcset="/img/loading.gif" lazyload alt="image-20220118201412153"></p>
<h4 id="3、-解析"><a href="#3、-解析" class="headerlink" title="3、 解析"></a>3、 解析</h4><p>将常量池内的符号引用替换为直接引用的过程</p>
<h3 id="4-4-3-初始化"><a href="#4-4-3-初始化" class="headerlink" title="4.4.3 初始化"></a>4.4.3 初始化</h3><p>类的初始化是【懒惰的】，触发类初始化的时机有：</p>
<ul>
<li>main 方法所在的类，总会被首先初始化</li>
<li>首次访问这个类的静态变量或静态方法时</li>
<li>子类初始化，如果父类还没初始化，会引发</li>
<li>子类访问父类的静态变量，只会触发父类的初始化</li>
<li>Class.forName</li>
<li>new 会导致初始化</li>
</ul>
<p>不会导致类初始化有：</p>
<ul>
<li>访问类的 static final 静态常量（基本类型和字符串）不会触发初始化</li>
<li>类对象.class 不会触发初始化</li>
<li>创建该类的数组不会触发初始化</li>
<li>类加载器的 loadClass 方法</li>
<li>Class.forName 的参数 2 为 false 时</li>
</ul>
<h3 id="x3D-x3D-4-4-4-面试题——懒汉式-x3D-x3D"><a href="#x3D-x3D-4-4-4-面试题——懒汉式-x3D-x3D" class="headerlink" title="&#x3D;&#x3D;4.4.4 面试题——懒汉式&#x3D;&#x3D;"></a>&#x3D;&#x3D;4.4.4 面试题——懒汉式&#x3D;&#x3D;</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TestSingTon</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        Sington.test();<br>        Sington.getInstance();<br>    &#125;<br>&#125;<br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 懒汉式，即只有触发初始化的操作的时候，才能初始化一个类，否则这个类是不会初始化的</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Sington</span>&#123;<br>    <span class="hljs-comment">//private修饰的构造方法，让外部访问不到</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-title function_">Sington</span><span class="hljs-params">()</span>&#123;&#125;;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 定义一个静态内部类</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">LasyHolder</span>&#123;<br>        <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">Sington</span> <span class="hljs-variable">SINGTON</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Sington</span>();<br>        <span class="hljs-keyword">static</span>&#123;<br>            System.out.println(<span class="hljs-string">&quot;lasyHolder init&quot;</span>);<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">//定义一个测试方法，直接用类名调用</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test</span><span class="hljs-params">()</span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;test&quot;</span>);<br>    &#125;<br>    <span class="hljs-comment">//定义一个懒汉测试方法，调用的时候会触发懒汉类的初始化</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Sington <span class="hljs-title function_">getInstance</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-keyword">return</span> LasyHolder.SINGTON;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="x3D-x3D-4-5-类加载器-x3D-x3D"><a href="#x3D-x3D-4-5-类加载器-x3D-x3D" class="headerlink" title="&#x3D;&#x3D;4.5 类加载器&#x3D;&#x3D;"></a>&#x3D;&#x3D;4.5 类加载器&#x3D;&#x3D;</h2><table>
<thead>
<tr>
<th>名称</th>
<th>加载类的路径</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>Bootstrap ClassLoader启动类加载器</td>
<td>JAVA_HOME&#x2F;jre&#x2F;lib</td>
<td>无法直接访问</td>
</tr>
<tr>
<td>Extension ClassLoader扩展类加载器</td>
<td>JAVA_HOME&#x2F;jre&#x2F;lib&#x2F;ext</td>
<td>上级为Bootstrap，显示为null，因为无法直接访问Bootstrap ClassLoader</td>
</tr>
<tr>
<td>Application ClassLoader应用类加载器</td>
<td>classpath</td>
<td>上级为Extension</td>
</tr>
<tr>
<td>自定义类加载器</td>
<td>自定义</td>
<td>上级为Application</td>
</tr>
</tbody></table>
 <figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-comment">//得到类对象，此时会进行类的加载、连接和初始化</span><br>Class&lt;?&gt; aClass = <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Class</span>.</span></span><span class="hljs-keyword">for</span><span class="hljs-constructor">Name(<span class="hljs-string">&quot;类路径&quot;</span>)</span>;<br><span class="hljs-comment">//调用类加载方法</span><br>.<span class="hljs-keyword">class</span>.get<span class="hljs-constructor">ClassLoader()</span>.load<span class="hljs-constructor">Class(<span class="hljs-string">&quot;类路径&quot;</span>)</span>;<br></code></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//自定义类加载器</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyClassLoader</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">ClassLoader</span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">protected</span> Class&lt;?&gt; findClass(String name) <span class="hljs-keyword">throws</span> ClassNotFoundException &#123;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">path</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;&quot;</span>;   <span class="hljs-comment">//class文件所在的路径</span><br>        <span class="hljs-type">ByteArrayOutputStream</span> <span class="hljs-variable">os</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ByteArrayOutputStream</span>();<br>        <span class="hljs-keyword">try</span> &#123;<br>            Files.copy(Paths.get(path), os);<br>            <span class="hljs-type">byte</span>[] bytes = os.toByteArray();<br>            <span class="hljs-keyword">return</span> defineClass(name, bytes, <span class="hljs-number">0</span>, bytes.length);<br>        &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>            e.printStackTrace();<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ClassNotFoundException</span>(<span class="hljs-string">&quot;类文件未找到&quot;</span>,e);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>



<h3 id="4-5-1-双亲委派模型"><a href="#4-5-1-双亲委派模型" class="headerlink" title="4.5.1 双亲委派模型"></a>4.5.1 双亲委派模型</h3><p>调用类加载器**loadClass()**方法的时候查找类的规则</p>
<p>源码如下：先在当前查找已加载的类对象中是否有，如果没有，去上级类加载器中找是否有此类【这里一般是在AppClassLoader，所以parent是ExtClassLoader】，ExtClassLoader查找当前已加载的类对象是否有，如果没有，此时其parent为null，调用findBootstrapClassOrNull在启动类加载器中查找，如果也找不到，则检查一遍ExtClassLoader，如果找不到会抛出异常，这个异常被AppClassLoader接收，此时c还是没有，AppClassLoader查找当前路径下是否有，如果有则返回。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">protected</span> Class&lt;?&gt; loadClass(String name, <span class="hljs-type">boolean</span> resolve)<br>        <span class="hljs-keyword">throws</span> ClassNotFoundException<br>    &#123;<br>        <span class="hljs-keyword">synchronized</span> (getClassLoadingLock(name)) &#123;<br>            <span class="hljs-comment">// First, check if the class has already been loaded</span><br>            Class&lt;?&gt; c = findLoadedClass(name);<br>            <span class="hljs-keyword">if</span> (c == <span class="hljs-literal">null</span>) &#123;<br>                <span class="hljs-type">long</span> <span class="hljs-variable">t0</span> <span class="hljs-operator">=</span> System.nanoTime();<br>                <span class="hljs-keyword">try</span> &#123;<br>                    <span class="hljs-keyword">if</span> (parent != <span class="hljs-literal">null</span>) &#123;<br>                        <span class="hljs-comment">//如果有上级，则委派上级loadClass</span><br>                        c = parent.loadClass(name, <span class="hljs-literal">false</span>);<br>                    &#125; <span class="hljs-keyword">else</span> &#123;<br>                        <span class="hljs-comment">//如果没有上级，则委派BootstrapClassLoader</span><br>                        c = findBootstrapClassOrNull(name);<br>                    &#125;<br>                &#125; <span class="hljs-keyword">catch</span> (ClassNotFoundException e) &#123;<br>                    <span class="hljs-comment">// ClassNotFoundException thrown if class not found</span><br>                    <span class="hljs-comment">// from the non-null parent class loader</span><br>                &#125;<br><br>                <span class="hljs-keyword">if</span> (c == <span class="hljs-literal">null</span>) &#123;<br>                    <span class="hljs-comment">// If still not found, then invoke findClass in order</span><br>                    <span class="hljs-comment">// to find the class.</span><br>                    <span class="hljs-type">long</span> <span class="hljs-variable">t1</span> <span class="hljs-operator">=</span> System.nanoTime();<br>                    <span class="hljs-comment">//在自己的类加载器路径下查找</span><br>                    c = findClass(name);<br><br>                    <span class="hljs-comment">// this is the defining class loader; record the stats</span><br>                    sun.misc.PerfCounter.getParentDelegationTime().addTime(t1 - t0);<br>                    sun.misc.PerfCounter.getFindClassTime().addElapsedTimeFrom(t1);<br>                    sun.misc.PerfCounter.getFindClasses().increment();<br>                &#125;<br>            &#125;<br>            <span class="hljs-keyword">if</span> (resolve) &#123;<br>                resolveClass(c);<br>            &#125;<br>            <span class="hljs-keyword">return</span> c;<br>        &#125;<br>    &#125;<br></code></pre></td></tr></table></figure>

<h3 id="4-5-2-线程上下文类加载器——破坏双亲委派模型"><a href="#4-5-2-线程上下文类加载器——破坏双亲委派模型" class="headerlink" title="4.5.2 线程上下文类加载器——破坏双亲委派模型"></a>4.5.2 线程上下文类加载器——破坏双亲委派模型</h3><p>以jdbc.Driver举例</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">DriverManager</span> &#123;<br><span class="hljs-comment">/* Prevent the DriverManager class from being instantiated. */</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-title function_">DriverManager</span><span class="hljs-params">()</span>&#123;&#125;<br><br>    <span class="hljs-keyword">static</span> &#123;<br>        loadInitialDrivers();<br>        println(<span class="hljs-string">&quot;JDBC DriverManager initialized&quot;</span>);<br>    &#125;<br></code></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">loadInitialDrivers</span><span class="hljs-params">()</span> &#123;<br>        String drivers;<br>        <span class="hljs-keyword">try</span> &#123;<br>            drivers = AccessController.doPrivileged(<span class="hljs-keyword">new</span> <span class="hljs-title class_">PrivilegedAction</span>&lt;String&gt;() &#123;<br>                <span class="hljs-keyword">public</span> String <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>                    <span class="hljs-keyword">return</span> System.getProperty(<span class="hljs-string">&quot;jdbc.drivers&quot;</span>);<br>                &#125;<br>            &#125;);<br>        &#125; <span class="hljs-keyword">catch</span> (Exception ex) &#123;<br>            drivers = <span class="hljs-literal">null</span>;<br>        &#125;<br><br>    	<span class="hljs-comment">//1.使用ServiceLoader机制加载驱动，SPI(Service Provider Interface)</span><br>        AccessController.doPrivileged(<span class="hljs-keyword">new</span> <span class="hljs-title class_">PrivilegedAction</span>&lt;Void&gt;() &#123;<br>            <span class="hljs-keyword">public</span> Void <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br><br>                ServiceLoader&lt;Driver&gt; loadedDrivers = ServiceLoader.load(Driver.class);<br>                Iterator&lt;Driver&gt; driversIterator = loadedDrivers.iterator();<br>               <br>                <span class="hljs-keyword">try</span>&#123;<br>                    <span class="hljs-keyword">while</span>(driversIterator.hasNext()) &#123;<br>                        driversIterator.next();<br>                    &#125;<br>                &#125; <span class="hljs-keyword">catch</span>(Throwable t) &#123;<br>                <span class="hljs-comment">// Do nothing</span><br>                &#125;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>            &#125;<br>        &#125;);<br><br>        println(<span class="hljs-string">&quot;DriverManager.initialize: jdbc.drivers = &quot;</span> + drivers);<br>		<br>    	<span class="hljs-comment">//2.使用jdbc.Drivers定义的驱动名加载驱动</span><br>        <span class="hljs-keyword">if</span> (drivers == <span class="hljs-literal">null</span> || drivers.equals(<span class="hljs-string">&quot;&quot;</span>)) &#123;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        String[] driversList = drivers.split(<span class="hljs-string">&quot;:&quot;</span>);<br>        println(<span class="hljs-string">&quot;number of Drivers:&quot;</span> + driversList.length);<br>        <span class="hljs-keyword">for</span> (String aDriver : driversList) &#123;<br>            <span class="hljs-keyword">try</span> &#123;<br>                println(<span class="hljs-string">&quot;DriverManager.Initialize: loading &quot;</span> + aDriver);<br>                <span class="hljs-comment">//getSystemClassLoader()就是应用程序类加载器</span><br>                Class.forName(aDriver, <span class="hljs-literal">true</span>,<br>                        ClassLoader.getSystemClassLoader());<br>            &#125; <span class="hljs-keyword">catch</span> (Exception ex) &#123;<br>                println(<span class="hljs-string">&quot;DriverManager.Initialize: load failed: &quot;</span> + ex);<br>            &#125;<br>        &#125;<br>    &#125;<br></code></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> &lt;S&gt; ServiceLoader&lt;S&gt; <span class="hljs-title function_">load</span><span class="hljs-params">(Class&lt;S&gt; service)</span> &#123;<br>    <span class="hljs-comment">//获取线程上下文类加载器，默认就是应用程序类加载器</span><br>    <span class="hljs-type">ClassLoader</span> <span class="hljs-variable">cl</span> <span class="hljs-operator">=</span> Thread.currentThread().getContextClassLoader();<br>    <span class="hljs-keyword">return</span> ServiceLoader.load(service, cl);<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> &lt;S&gt; ServiceLoader&lt;S&gt; <span class="hljs-title function_">load</span><span class="hljs-params">(Class&lt;S&gt; service,ClassLoader loader)</span><br>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ServiceLoader</span>&lt;&gt;(service, loader);<br>&#125;<br><span class="hljs-comment">//在ServiceLoader类中的内部类LazyIterator中的nextService()方法使用class.forName方法从应用类加载器开始加载</span><br></code></pre></td></tr></table></figure>

<p>&#x3D;&#x3D;SPI详细&#x3D;&#x3D;：在 jar 包的 META-INF&#x2F;services 包下，以接口全限定名名为文件，文件内容是实现类名称</p>
<img src="/2022/02/09/JVM/image-20220118233933846.png" srcset="/img/loading.gif" lazyload alt="image-20220118233933846 " style="zoom:67%;">

<p>只要做了这样的配置，就可以使用这种写法加载接口的实现类</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java">ServiceLoader&lt;接口类型&gt; allImpls = ServiceLoader.load(接口类型.class);<br>Iterator&lt;接口类型&gt; iter = allImpls.iterator();<br><span class="hljs-keyword">while</span>(iter.hasNext()) &#123;<br>	iter.next();<br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="4-6-运行期优化"><a href="#4-6-运行期优化" class="headerlink" title="4.6 运行期优化"></a>4.6 运行期优化</h2>
            </div>
            <hr>
            <div>
              <div class="post-metas mb-3">
                
                
              </div>
              
                <p class="note note-warning">
                  
                    本博客所有文章除特别声明外，均采用 <a target="_blank" href="https://creativecommons.org/licenses/by-sa/4.0/deed.zh" rel="nofollow noopener noopener">CC BY-SA 4.0 协议</a> ，转载请注明出处！
                  
                </p>
              
              
                <div class="post-prevnext">
                  <article class="post-prev col-6">
                    
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2022/02/09/MyBatis/">
                        <span class="hidden-mobile">MyBatis笔记</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
          </article>
        </div>
      </div>
    </div>
    
      <div class="d-none d-lg-block col-lg-2 toc-container" id="toc-ctn">
        <div id="toc">
  <p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;目录</p>
  <div class="toc-body" id="toc-body"></div>
</div>

      </div>
    
  </div>
</div>

<!-- Custom -->


    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v"
                 for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>
    

    
  </main>

  <footer class="text-center mt-5 py-3">
  <div class="footer-content">
     <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> 
  </div>
  

  

  
</footer>


  <!-- SCRIPTS -->
  
  <script  src="https://cdn.jsdelivr.net/npm/nprogress@0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/nprogress@0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js" ></script>
<script  src="https://cdn.jsdelivr.net/npm/bootstrap@4/dist/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>

<!-- Plugins -->


  <script  src="/js/local-search.js" ></script>



  
    <script  src="/js/img-lazyload.js" ></script>
  



  



  
    <script  src="https://cdn.jsdelivr.net/npm/tocbot@4/dist/tocbot.min.js" ></script>
  
  
    <script  src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3/dist/jquery.fancybox.min.js" ></script>
  
  
    <script  src="https://cdn.jsdelivr.net/npm/anchor-js@4/anchor.min.js" ></script>
  
  
    <script defer src="https://cdn.jsdelivr.net/npm/clipboard@2/dist/clipboard.min.js" ></script>
  






  <script  src="https://cdn.jsdelivr.net/npm/typed.js@2/lib/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var title = document.getElementById('subtitle').title;
      
        typing(title);
      
    })(window, document);
  </script>















<!-- 主题的启动项 保持在最底部 -->
<script  src="/js/boot.js" ></script>


</body>
</html>
